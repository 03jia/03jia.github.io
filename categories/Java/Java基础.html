<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础 | Jia's Blog</title><meta name="author" content="Jia"><meta name="copyright" content="Jia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章&gt;&gt;&gt;基础语法1. Java基础知识图解 2. 关键字和保留字2.1 关键字(keyword)定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所有字母都为小写 官方地址： https:&#x2F;&#x2F;docs.orace.com&#x2F;javase&#x2F;tutoria&#x2F;java&#x2F;nutsandbots&#x2F;_keywords.htm 2.2 保留字(reserved">
<meta property="og:type" content="website">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://example.com/categories/Java/Java%E5%9F%BA%E7%A1%80.html">
<meta property="og:site_name" content="Jia&#39;s Blog">
<meta property="og:description" content="第一章&gt;&gt;&gt;基础语法1. Java基础知识图解 2. 关键字和保留字2.1 关键字(keyword)定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所有字母都为小写 官方地址： https:&#x2F;&#x2F;docs.orace.com&#x2F;javase&#x2F;tutoria&#x2F;java&#x2F;nutsandbots&#x2F;_keywords.htm 2.2 保留字(reserved">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/06/19/RNZqH4gnkWSpeDm.jpg">
<meta property="article:published_time" content="2023-06-19T09:48:12.337Z">
<meta property="article:modified_time" content="2023-06-19T07:11:50.886Z">
<meta property="article:author" content="Jia">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/06/19/RNZqH4gnkWSpeDm.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2023/06/19/MAhdEmn3HJaKXqC.png"><link rel="canonical" href="http://example.com/categories/Java/Java%E5%9F%BA%E7%A1%80.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-06-19 15:11:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/06/19/RNZqH4gnkWSpeDm.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-home-page" id="page-header" style="background-image: url('https://s2.loli.net/2023/06/19/GkW9qPHwQpR3Dre.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Jia's Blog"><span class="site-name">Jia's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="page-site-info"><h1 id="site-title">Java基础</h1></div></header><main class="layout" id="content-inner"><div id="page"><div id="article-container"><h1 id="第一章-gt-gt-gt-基础语法"><a href="#第一章-gt-gt-gt-基础语法" class="headerlink" title="第一章&gt;&gt;&gt;基础语法"></a>第一章&gt;&gt;&gt;基础语法</h1><h2 id="1-Java基础知识图解"><a href="#1-Java基础知识图解" class="headerlink" title="1. Java基础知识图解"></a>1. Java基础知识图解</h2><p><img src="/assets/image-20221115002213051.png" alt="image-20221115002213051"></p>
<h2 id="2-关键字和保留字"><a href="#2-关键字和保留字" class="headerlink" title="2. 关键字和保留字"></a>2. 关键字和保留字</h2><h3 id="2-1-关键字-keyword"><a href="#2-1-关键字-keyword" class="headerlink" title="2.1 关键字(keyword)"></a>2.1 关键字(keyword)</h3><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</p>
<p>特点：关键字中所有字母都为小写</p>
<p>官方地址： <a target="_blank" rel="noopener" href="https://docs.orace.com/javase/tutoria/java/nutsandbots/_keywords.htm">https://docs.orace.com/javase/tutoria/java/nutsandbots/_keywords.htm</a></p>
<h3 id="2-2-保留字-reserved-word"><a href="#2-2-保留字-reserved-word" class="headerlink" title="2.2 保留字(reserved word)"></a>2.2 保留字(reserved word)</h3><p> Java保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字</p>
<h2 id="3-标识符-Identifier"><a href="#3-标识符-Identifier" class="headerlink" title="3.  标识符(Identifier)"></a>3.  标识符(Identifier)</h2><p><strong>标识符：</strong> </p>
<p>Java 对各种<strong>变量、方法和类</strong>等要素命名时使用的字符序列称为标识符 </p>
<p>技巧：凡是自己可以起名字的地方都叫标识符。 </p>
<hr>
<p><strong>定义合法标识符规则：</strong> </p>
<ul>
<li>由26个英文字母大小写，0-9 ，_或 $ 组成 </li>
<li>数字不可以开头。 </li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。 </li>
<li>Java中严格区分大小写，长度无限制。 </li>
<li>标识符不能包含空格</li>
</ul>
<hr>
<p><strong>Java中的名称命名规范：</strong> </p>
<p><strong>包名</strong>：多单词组成时所有字母都小写：xxxyyyzzz </p>
<p><strong>类名、接口名</strong>：多单词组成时，所有单词的首字母大写：XxxYyyZzz </p>
<p><strong>变量名、方法名</strong>：多单词组成时，第一个单词首字母小写，第二个单词开始每个 单词首字母大写：xxxYyyZzz </p>
<p><strong>常量名</strong>：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p>
<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><h3 id="4-1-使用变量注意："><a href="#4-1-使用变量注意：" class="headerlink" title="4.1 使用变量注意："></a>4.1 使用变量注意：</h3><ul>
<li>Java中每个变量必须先声明，后使用 </li>
<li>使用变量名来访问这块区域的数据 </li>
<li>变量的作用域：其定义所在的一对{ }内 </li>
<li>变量只有在其作用域内才有效 </li>
<li>同一个作用域内，不能定义重名的变量</li>
</ul>
<h3 id="4-2-声明变量"><a href="#4-2-声明变量" class="headerlink" title="4.2 声明变量"></a>4.2 声明变量</h3><p> 语法：&lt;数据类型&gt; &lt;变量名称&gt; </p>
<p> 例如：int var; </p>
<h3 id="4-3-变量的赋值"><a href="#4-3-变量的赋值" class="headerlink" title="4.3 变量的赋值"></a>4.3 变量的赋值</h3><p>语法：&lt;变量名称&gt; &#x3D; &lt;值&gt; </p>
<p>例如：var &#x3D; 10; </p>
<h3 id="4-4-声明和赋值变量"><a href="#4-4-声明和赋值变量" class="headerlink" title="4.4  声明和赋值变量"></a>4.4  声明和赋值变量</h3><p>语法： &lt;数据类型&gt; &lt;变量名&gt; &#x3D; &lt;初始化值&gt; </p>
<p> 例如：int var &#x3D; 10;</p>
<h3 id="4-5-补充：变量的分类-按声明的位置的不同"><a href="#4-5-补充：变量的分类-按声明的位置的不同" class="headerlink" title="4.5 补充：变量的分类-按声明的位置的不同"></a>4.5 补充：变量的分类-按声明的位置的不同</h3><p>在方法体外，类体内声明的变量称为<strong>成员变量</strong>。</p>
<p>在方法体内部声明的变量称为<strong>局部变量</strong>。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221115004851603.png" alt="image-20221115004851603"></p>
<p>二者在初始化值方面的异同: </p>
<p>同：都有生命周期</p>
<p>异：局部变量除形参外，需显式初始化。</p>
<h3 id="4-6-变量的分类——按数据类型"><a href="#4-6-变量的分类——按数据类型" class="headerlink" title="4.6 变量的分类——按数据类型"></a>4.6 变量的分类——按数据类型</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221115004525695.png" alt="image-20221115004525695"></p>
<h4 id="4-6-1-整数类型"><a href="#4-6-1-整数类型" class="headerlink" title="4.6.1 整数类型"></a>4.6.1 整数类型</h4><p><strong>byte、short、int、long</strong></p>
<ul>
<li>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证java程序的可移植性。</li>
<li>java的整型常量默认为 int 型，声明ong型常量须后加‘’或‘’</li>
<li>java程序中变量通常声明为int型，除非不足以表示较大的数，才使用ong</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用存储空间</th>
<th>表示范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1字节&#x3D;8bit位</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-215 ~215-1</td>
</tr>
<tr>
<td>int（默认）</td>
<td>4字节</td>
<td>-231 ~ 231-1 (约21亿)</td>
</tr>
<tr>
<td>ong</td>
<td>8字节</td>
<td>-263 ~ 263-1</td>
</tr>
</tbody></table>
<h4 id="4-6-2-浮点类型"><a href="#4-6-2-浮点类型" class="headerlink" title="4.6.2 浮点类型"></a>4.6.2 浮点类型</h4><p><strong>float、double</strong></p>
<ul>
<li><p>与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响。</p>
</li>
<li><p>浮点型常量有两种表示形式：</p>
<p>​	十进制数形式：如：5.12、512.0f、.512 (必须有小数点）</p>
<p>​	科学计数法形式:如：5.12e2、512E2、100E-2</p>
</li>
<li><p>float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。</p>
<p>double:双精度，精度是float的两倍。通常采用此类型。</p>
</li>
<li><p>Java的浮点型常量默认为double型<strong>，</strong>声明float型常量，须后加 ‘f’ 或  ‘F’。</p>
</li>
</ul>
<h4 id="4-6-3-字符类型"><a href="#4-6-3-字符类型" class="headerlink" title="4.6.3 字符类型"></a>4.6.3 字符类型</h4><p><strong>char</strong></p>
<ul>
<li><p>char 型数据用来表示通常意义上“字符”(2字节)</p>
</li>
<li><p>Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。</p>
</li>
<li><p>字符型变量的三种表现形式：</p>
<p>字符常量是用单引号(‘ ’)括起来的单个字符。例如：char c1 &#x3D; ‘a’;  char c2 	&#x3D; ‘中’; char c3 &#x3D; ‘9’；</p>
</li>
</ul>
<p>​		Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。例		如：char c3 &#x3D; ‘\n’; &#x2F;&#x2F; ‘\n’表示换行符；</p>
<p>​		直接使用 Unicode 值来表示字符型常量：‘\uXXXX’。其中，XXXX代表一个		十六进制整数。如：\u000a 表示 \n。</p>
<ul>
<li>char类型是可以进行运算的。因为它都对应有Unicode码。</li>
</ul>
<h4 id="4-6-4-布尔类型"><a href="#4-6-4-布尔类型" class="headerlink" title="4.6.4 布尔类型"></a>4.6.4 布尔类型</h4><p><strong>boolean</strong></p>
<ul>
<li><p>boolean 类型用来判断逻辑条件，一般用于程序流程控制：</p>
<p>​	if条件控制语句； </p>
<p>​	while循环控制语句； </p>
<p>​	do-while循环控制语句； </p>
<p>​	for循环控制语句;</p>
</li>
<li><p>boolean类型数据只允许取值true和false，无nu。 </p>
<p>​	不可以使用0或非 0 的整数替代false和true，这点和C语言不同。</p>
</li>
</ul>
<h3 id="4-7-基本数据转换"><a href="#4-7-基本数据转换" class="headerlink" title="4.7 基本数据转换"></a>4.7 基本数据转换</h3><ul>
<li><p><strong>自动类型转换</strong>：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：</p>
<p>特别的：当byte、char、short三种类型的变量做运算时，结果为int型</p>
</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221115010414542.png" alt="image-20221115010414542"></p>
<ul>
<li><p>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。</p>
</li>
<li><p>byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。</p>
</li>
<li><p>boolean类型不能与其它数据类型运算。</p>
</li>
<li><p>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。</p>
</li>
</ul>
<h3 id="4-8-字符串类型"><a href="#4-8-字符串类型" class="headerlink" title="4.8 字符串类型"></a>4.8 字符串类型</h3><p><strong>String</strong></p>
<ul>
<li><p>String不是基本数据类型，属于引用数据类型 </p>
</li>
<li><p>使用方式与基本数据类型一致。例如：String str &#x3D; “abcd”; </p>
</li>
<li><p>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。</p>
<p>例如： str &#x3D; str + “xyz” ; </p>
<p>​			 int n &#x3D; 100; </p>
<p>​			 str &#x3D; str + n；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="number">4</span>;                      <span class="comment">//判断对错：no</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="number">3.5f</span> + “”;              <span class="comment">//判断str2对错：yes</span></span><br><span class="line">System.out.printn(str2);             <span class="comment">//输出：”3.5”</span></span><br><span class="line">System.out .printn(<span class="number">3</span>+<span class="number">4</span>+“Heo!”);    <span class="comment">//输出：7Heo!</span></span><br><span class="line">System.out.printn(“Heo!”+<span class="number">3</span>+<span class="number">4</span>);     <span class="comment">//输出：Heo!34</span></span><br><span class="line">System.out.printn(‘a’+<span class="number">1</span>+“Heo!”);   <span class="comment">//输出：98Heo!</span></span><br><span class="line">System.out.printn(“Heo”+‘a’+<span class="number">1</span>);    <span class="comment">//输出：Heoa1</span></span><br></pre></td></tr></table></figure>



<h3 id="4-9-强制类型转换"><a href="#4-9-强制类型转换" class="headerlink" title="4.9 强制类型转换"></a>4.9 强制类型转换</h3><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。</p>
<p>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> “<span class="number">43</span>”; <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(a)</span><br></pre></td></tr></table></figure>

<p><strong>boolean类型不可以转换为其它的数据类型。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">判断是否能通过编译</span><br><span class="line"><span class="number">1</span>） <span class="type">short</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="number">5</span>; s = s-<span class="number">2</span>;</span><br><span class="line"><span class="number">2</span>） <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;        <span class="comment">//判断：no </span></span><br><span class="line">	b = b + <span class="number">4</span>;         <span class="comment">//判断：no</span></span><br><span class="line">	b = (<span class="type">byte</span>)(b+<span class="number">4</span>);   <span class="comment">//判断：yes</span></span><br><span class="line"><span class="number">3</span>） <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ‘a’;</span><br><span class="line">	<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">	<span class="type">float</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">.314F</span>; </span><br><span class="line">	<span class="type">double</span> <span class="variable">resut</span> <span class="operator">=</span> c+i+d;	<span class="comment">//判断：yes</span></span><br><span class="line"><span class="number">4</span>） <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">	<span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">short</span> <span class="variable">t</span> <span class="operator">=</span> s + b;        <span class="comment">//判断：no</span></span><br></pre></td></tr></table></figure>



<h2 id="5-进制"><a href="#5-进制" class="headerlink" title="5. 进制"></a>5. 进制</h2><p>所有数字在计算机底层都以二进制形式存在。</p>
<p>对于整数，有四种表示方式：</p>
<ul>
<li>二进制**(binary)<strong>：0,1 ，满2进1.以</strong>0b<strong>或</strong>0B**开头。</li>
<li>十进制**(decimal)**：0-9 ，满10进1。</li>
<li>八进制**(octal)<strong>：0-7 ，满8进1. 以数字</strong>0**开头表示。</li>
<li>十六进制**(hex)<strong>：0-9及A-F，满16进1. 以</strong>0x<strong>或</strong>0X**开头表示。此处的A-F不区分大小写。 如：0x21AF +1&#x3D; 0X21B0</li>
</ul>
<h3 id="5-1-二进制"><a href="#5-1-二进制" class="headerlink" title="5.1 二进制"></a>5.1 二进制</h3><p>二进制的整数有如下三种形式：</p>
<ul>
<li>原码：直接将一个数值换成二进制数。最高位是符号位</li>
<li>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。</li>
<li>负数的补码：其反码加1。</li>
</ul>
<hr>
<p>计算机以<strong>二进制补码</strong>的形式保存所有的整数。</p>
<ul>
<li>正数的原码、反码、补码都相同（三码合一)</li>
<li>负数的补码是其反码+1</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221115204755207.png" alt="image-20221115204755207"></p>
<h3 id="5-2-进制的基本转换"><a href="#5-2-进制的基本转换" class="headerlink" title="5.2 进制的基本转换"></a>5.2 进制的基本转换</h3><ol>
<li><p>十进制 二进制互转</p>
<p>二进制转成十进制 乘以<strong>2</strong>的幂数</p>
<p>十进制转成二进制 除以<strong>2</strong>取余数</p>
</li>
<li><p>二进制 八进制互转（8&#x3D;2^3）</p>
</li>
<li><p>二进制 十六进制互转（8&#x3D;2^4）</p>
</li>
<li><p>十进制 八进制互转</p>
</li>
<li><p>十进制 十六进制互转</p>
</li>
</ol>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221115205008639.png" alt="image-20221115205008639"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221115205151035.png" alt="image-20221115205151035"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221115205228610.png" alt="image-20221115205228610"></p>
<h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6. 运算符"></a>6. 运算符</h2><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p>
<ol>
<li>算术运算符</li>
<li>赋值运算符</li>
<li>比较运算符（关系运算符）</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>三元运算符</li>
</ol>
<h3 id="6-1-算术运算符"><a href="#6-1-算术运算符" class="headerlink" title="6.1 算术运算符"></a>6.1 算术运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th>运算</th>
<th>范例</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td>正号</td>
<td>+3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">-</td>
<td>负号</td>
<td>b&#x3D;4;  -b</td>
<td align="center">-4</td>
</tr>
<tr>
<td align="center">+</td>
<td>加</td>
<td>5+5</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">-</td>
<td>减</td>
<td>6-4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">*</td>
<td>乘</td>
<td>3*4</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td>除(取整)</td>
<td>5&#x2F;5</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">%</td>
<td>取模(取余)</td>
<td>7%5</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">++ ++</td>
<td>自增（前）：先运算后取值                自增（后）：先取值后运算</td>
<td>a&#x3D;2;b&#x3D;++a; a&#x3D;2;b&#x3D;a++;</td>
<td align="center">a&#x3D;3;b&#x3D;3 a&#x3D;3;b&#x3D;2</td>
</tr>
<tr>
<td align="center">-  -  -  -</td>
<td>自减（前）：先运算后取值               自减（后）：先取值后运算</td>
<td>a&#x3D;2;b&#x3D;-  -a  a&#x3D;2;b&#x3D;a-  -</td>
<td align="center">a&#x3D;1;b&#x3D;1  a&#x3D;1;b&#x3D;2</td>
</tr>
<tr>
<td align="center">+</td>
<td>字符串连接</td>
<td>“Hell”+”o”</td>
<td align="center">&gt;“Hello</td>
</tr>
</tbody></table>
<blockquote>
<ol>
<li><p>&#x2F;&#x2F;(前)++ :先自增1，后运算</p>
<p>&#x2F;&#x2F;(后)++ :先运算，后自增1</p>
</li>
<li><p>&#x2F;&#x2F;(前)– :先自减1，后运算</p>
<p>&#x2F;&#x2F;(后)– :先运算，后自减1</p>
</li>
<li><p>连接符：+ 只能使用在String与其他类型变量之间使用</p>
</li>
</ol>
</blockquote>
<hr>
<blockquote>
<p>注意：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数型相除，如果除不尽就会截断，只保留整数部分，所以结果是1，然后转换成浮点型就变成1.0</span></span><br><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">9</span></span><br><span class="line">System.out.println(a) <span class="comment">//输出：1.0</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="number">10.0</span> / <span class="number">9.0</span>) <span class="comment">//输出：1.1111112</span></span><br></pre></td></tr></table></figure>

<hr>
<p>在Java中，整数相除除不尽的时候会取整，即<strong>向下取整</strong>。这是因为Java中整数类型的除法是基于整数的除法（也称为<strong>截断除法</strong>）实现的。整数的除法是指两个整数相除时，结果只保留整数部分，而舍去小数部分，即将小数部分向零取整。因此，如果两个整数相除结果不能整除，那么余数会被舍去，结果就会变成0。</p>
</blockquote>
<h3 id="6-2-赋值运算符"><a href="#6-2-赋值运算符" class="headerlink" title="6.2 赋值运算符"></a>6.2 赋值运算符</h3><p>符号：&#x3D;</p>
<ul>
<li>当“&#x3D;”两侧数据类型不一致时，可以使用自动类型转换或使用强制 类型转换原则进行处理。</li>
<li>支持连续赋值。</li>
</ul>
<p>扩展赋值运算符： +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D;</p>
<blockquote>
<ol>
<li>&#x2F;&#x2F;开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num &#x3D; 10;)<br>&#x2F;&#x2F;方式一：num &#x3D; num + 2;<br>&#x2F;&#x2F;方式二：num +&#x3D; 2; (推荐)</li>
<li>&#x2F;&#x2F;开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num &#x3D; 10;)<br>&#x2F;&#x2F;方式一：num &#x3D; num + 1;<br>&#x2F;&#x2F;方式二：num +&#x3D; 1;<br>&#x2F;&#x2F;方式三：num++; (推荐)</li>
<li>运算的结果不会改变本身变量的数据类型</li>
</ol>
</blockquote>
<h3 id="6-3-比较运算符"><a href="#6-3-比较运算符" class="headerlink" title="6.3 比较运算符"></a>6.3 比较运算符</h3><p>比较运算符的结果都是boolean型，也就是要么是true，要么是false。</p>
<p>比较运算符“**&#x3D;&#x3D;”<strong>不能误写成“</strong>&#x3D;”** 。</p>
<hr>
<p><strong>特别说明：</strong></p>
<ol>
<li>比较运算符的结果是boolean类型</li>
<li>&gt; &lt; &gt;&#x3D; &lt;&#x3D;：只能使用在数值类型的数据之间</li>
<li>&#x3D;&#x3D; 和 !&#x3D;：不仅可以使用在数值类型数据之间，还可以使用在其它应用类型变量之间</li>
</ol>
<h3 id="6-4-逻辑运算符"><a href="#6-4-逻辑运算符" class="headerlink" title="6.4 逻辑运算符"></a>6.4 逻辑运算符</h3><ul>
<li><p>&amp;—逻辑与</p>
</li>
<li><p>| —逻辑或</p>
</li>
<li><p>！—逻辑非</p>
</li>
<li><p>&amp;&amp; —短路与（推荐)</p>
</li>
<li><p>|| —短路或（推荐）</p>
</li>
<li><p>^ —逻辑异或</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a&amp;b</th>
<th align="center">a&amp;&amp;b</th>
<th align="center">a|b</th>
<th align="center">a||b</th>
<th align="center">!a</th>
<th align="center">a^b</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>true</strong></td>
<td align="center"><strong>true</strong></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center"><strong>true</strong></td>
<td align="center"><strong>false</strong></td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><strong>false</strong></td>
<td align="center"><strong>true</strong></td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><strong>false</strong></td>
<td align="center"><strong>false</strong></td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">true</td>
<td align="center">false</td>
</tr>
</tbody></table>
<p>“&amp;”和“&amp;&amp;”的区别：</p>
<ul>
<li>相同点1：运算结果都相同</li>
<li>相同点2：当符号左边是true时，二者都会执行符号右边的运算</li>
<li>不同点：当符号左边是false时，&amp; 继续执行符号右边的运算，&amp;&amp; 不再执行符号右边的运算</li>
</ul>
<hr>
<p>“|”和“||”的区别</p>
<ul>
<li>相同点1：运算结果都相同</li>
<li>相同点2：当符号左边是false时，二者都会执行符号右边的运算</li>
<li>不同点：当符号左边是true时，| 继续执行符号右边的运算，|| 不再执行符号右边的运算</li>
</ul>
<hr>
<p>异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。 </p>
<p>理解：异或，追求的是“异”!</p>
<hr>
<blockquote>
<p>逻辑运算符操作的都是boolean类型的变量，而且结果也都是boolean类型</p>
</blockquote>
<h3 id="6-5-位运算符"><a href="#6-5-位运算符" class="headerlink" title="6.5 位运算符"></a>6.5 位运算符</h3><table>
<thead>
<tr>
<th></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td>&lt;&lt;</td>
<td align="left">空位补0，被移除的高位丢弃，空缺位补0。</td>
</tr>
<tr>
<td><strong>&gt;&gt;</strong></td>
<td align="left">被移位的二进制最高位是0，右移后，空缺位补0； 最高位是1，空缺位补1。</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td align="left">被移位二进制最高位无论是0或者是1，空缺位都用0补。</td>
</tr>
<tr>
<td>&amp;</td>
<td align="left">二进制位进行&amp;运算，只有1&amp;1时结果是1，否则是0;</td>
</tr>
<tr>
<td>|</td>
<td align="left">二进制位进行  |  运算，只有0  |  0时结果是0，否则是1;</td>
</tr>
<tr>
<td>^</td>
<td align="left">相同二进制位进行  ^  运算，结果是0；1^1&#x3D;0  ,  0^0&#x3D;0  不相同二进制位  ^ 运算结果是1。1^0&#x3D;1  , 0^1&#x3D;1</td>
</tr>
<tr>
<td>~</td>
<td align="left">正数取反，各二进制码按补码各位取反  负数取反，各二进制码按补码各位取反</td>
</tr>
</tbody></table>
<p><strong>特别说明</strong>：</p>
<ol>
<li><p>位运算符操作都是整型数据</p>
</li>
<li><p>&lt;&lt;：在一定范围内，每向左移1位，相当于 *2</p>
<p>&gt;&gt;：在一定范围内，每向右移1位，相当于 &#x2F;2</p>
</li>
</ol>
<h3 id="6-6-三元运算符"><a href="#6-6-三元运算符" class="headerlink" title="6.6 三元运算符"></a>6.6 三元运算符</h3><p>格式:</p>
<p><strong>(<strong>条件表达式</strong>)?<strong>表达式</strong>1</strong>：表达式<strong>2</strong>；</p>
<p> ？如果为<strong>true</strong>，运算后的结果是表达式1；为<strong>false</strong>，运算后的结果是表达式2</p>
<p>表达式<strong>1</strong>和表达式<strong>2</strong>为同种类型</p>
<hr>
<p>三元运算符与<strong>if-else</strong>的联系与区别：  </p>
<ul>
<li>三元运算符可简化if-else语句   </li>
<li>三元运算符要求必须返回一个结果。 </li>
<li>if后的代码块可有多个语句</li>
</ul>
<hr>
<p><strong>运算符的优先级</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221116205632933.png" alt="image-20221116205632933"></p>
<p><strong>特别注意：</strong></p>
<ol>
<li>结构：(条件表达式)? 表达式1 : 表达式2</li>
<li>说明：<br>① 条件表达式的结果为boolean类型<br>② 根据条件表达式真或假，决定执行表达式1，还是表达式2.<br>  如果表达式为true，则执行表达式1。<br>  如果表达式为false，则执行表达式2。<br>③ 表达式1 和表达式2要求是一致的。<br>④ 三元运算符可以嵌套使用</li>
<li>凡是可以使用三元运算符的地方，都可以改写为if-else<br>反之，不成立。</li>
<li>如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。</li>
</ol>
<h2 id="7-程序流程控制"><a href="#7-程序流程控制" class="headerlink" title="7. 程序流程控制"></a>7. 程序流程控制</h2><p><strong>顺序结构</strong></p>
<ul>
<li>程序从上到下逐行地执行，中间没有任何判断和跳转。</li>
</ul>
<p><strong>分支结构</strong></p>
<ul>
<li>根据条件，选择性地执行某段代码。</li>
<li>有if…else和switch-case两种分支语句。</li>
</ul>
<p><strong>循环结构</strong></p>
<ul>
<li><p>根据循环条件，重复性的执行某段代码。</p>
</li>
<li><p>有while、do…while、for三种循环语句。</p>
</li>
<li><p>注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素。</p>
</li>
</ul>
<h3 id="7-1-顺序结构"><a href="#7-1-顺序结构" class="headerlink" title="7.1 顺序结构"></a>7.1 顺序结构</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221117225405826.png" alt="image-20221117225405826"></p>
<h3 id="7-2-分支结构"><a href="#7-2-分支结构" class="headerlink" title="7.2 分支结构"></a>7.2 分支结构</h3><p>if和switch语句很像，具体什么场景下，应用哪个语句呢？</p>
<ul>
<li>如果判断的具体数值不多，而且符合byte、short 、char、int、String、枚举等几 种类型。虽然两个语句都可以使用，建议使用swtich语句。因为效率稍高。</li>
<li>其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广。</li>
</ul>
<p>也就是说，使用switch-case的，都可以改写为if-else。反之不成立。</p>
<h4 id="7-2-1-if-else结构"><a href="#7-2-1-if-else结构" class="headerlink" title="7.2.1 if-else结构"></a>7.2.1 if-else结构</h4><p>分支结构：if-else使用说明</p>
<ul>
<li>条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量</li>
<li>语句块只有一条执行语句时，一对{}可以省略，但建议保留</li>
<li>if-else语句结构，根据需要可以嵌套使用</li>
<li>当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略</li>
<li>当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓 当多个条件是“包含”关系时，“小上大下 &#x2F; 子上父下”</li>
</ul>
<hr>
<p><strong>if语句</strong>的三种格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行代码块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221117225959781.png" alt="image-20221117225959781"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行代码块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">执行代码块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221117225856067.png" alt="image-20221117225856067"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)&#123;</span><br><span class="line">执行代码块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">2</span>)&#123;</span><br><span class="line">执行代码块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">执行代码块n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221117225944037.png" alt="image-20221117225944037"></p>
<p><strong>说明：</strong></p>
<ol>
<li><p>else 结构是可选的。</p>
</li>
<li><p>针对于条件表达式：</p>
<ul>
<li><p>如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。</p>
</li>
<li><p>如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。</p>
</li>
<li><p>如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了。</p>
</li>
</ul>
</li>
<li><p>if-else结构是可以相互嵌套的。</p>
</li>
<li><p>如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。</p>
</li>
</ol>
<h4 id="7-2-2-switch-case结构"><a href="#7-2-2-switch-case结构" class="headerlink" title="7.2.2 switch-case结构"></a>7.2.2 switch-case结构</h4><p><strong>switch</strong>语句有关规则：</p>
<ul>
<li><p>switch(表达式)中表达式的值必须是下述几种类型之一：<strong>byte</strong>，<strong>short</strong>，</p>
</li>
<li><p><strong>char</strong>，<strong>int</strong>，枚举 <strong>(jdk</strong> <strong>5.0)<strong>，</strong>String</strong> <strong>(jdk</strong> **7.0)**；</p>
</li>
<li><p>case子句中的值必须是常量，不能是变量名或不确定的表达式值；</p>
</li>
<li><p>同一个switch语句，所有case子句中的常量值互不相同；</p>
</li>
<li><p>break语句用来在执行完一个case分支后使程序跳出switch语句块；如果没有break，程序会顺序执行到switch结尾</p>
</li>
<li><p>default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时，</p>
<p>执行default</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;  </span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">	语句<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// break;  </span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">	语句<span class="number">2</span>;</span><br><span class="line">	<span class="comment">// break;</span></span><br><span class="line">… …</span><br><span class="line"><span class="keyword">case</span> 常量N:</span><br><span class="line">	语句N;</span><br><span class="line">	<span class="comment">// break;</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	语句;</span><br><span class="line">	<span class="comment">// break;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pubic cass SwitchTest &#123;</span><br><span class="line">		pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">switch</span> (i) &#123; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				System.out.printn(<span class="string">&quot;zero&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				System.out.printn(<span class="string">&quot;one&quot;</span>);  </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				System.out.printn(<span class="string">&quot;default&quot;</span>); </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221117231922311.png" alt="image-20221117231922311"></p>
<p><strong>说明：</strong><br>① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。</p>
<p>② break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构</p>
<p>③ switch结构中的表达式，只能是如下的6种数据类型之一：byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)</p>
<p>④ case 之后只能声明常量。不能声明范围。</p>
<p>⑤ break关键字是可选的。</p>
<p>⑥ default:相当于if-else结构中的else。default结构是可选的，而且位置是灵活的。</p>
<p>⑦ 如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。</p>
<blockquote>
<p>如果前面满足条件的case语句中没有加break语句，仍然会执行后面的case语句中的代码，直到执行完所有的case语句才跳出switch-case结构。case语句中加了break时，一旦常量匹配到case语句，则跳出switch-case结构。</p>
</blockquote>
<h4 id="7-2-3拓展：Scanner类"><a href="#7-2-3拓展：Scanner类" class="headerlink" title="7.2.3拓展：Scanner类"></a>7.2.3拓展：Scanner类</h4><p>如何从键盘获取不同类型的变量：需要使用Scanner类</p>
<p>具体实现步骤：<br>1.导包：<code>import java.util.Scanner;</code></p>
<p>2.Scanner的实例化:<code>Scanner scan = new Scanner(System.in);</code></p>
<p>3.调用Scanner类的相关方法（next() &#x2F; nextXxx()），来获取指定类型的变量</p>
<ul>
<li><p>​	nextDouble()，nextInt()，nextByte()，nextShort()，next()。</p>
</li>
<li><p>​	对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>导包</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScannerTest</span>&#123;	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//2.Scanner的实例化</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3.调用Scanner类的相关方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的姓名：&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scan.next();</span><br><span class="line">		System.out.println(name);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的芳龄：&quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		System.out.println(age);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的体重：&quot;</span>);</span><br><span class="line">		<span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> scan.nextDouble();</span><br><span class="line">		System.out.println(weight);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;你是否相中我了呢？(true/false)&quot;</span>);</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">isLove</span> <span class="operator">=</span> scan.nextBoolean();</span><br><span class="line">		System.out.println(isLove);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//char型的获取，Scanner没有提供相关的方法。只能获取一个字符串</span></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的性别：(男/女)&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> scan.next();<span class="comment">//&quot;男&quot;</span></span><br><span class="line">		<span class="comment">//获取索引为0位置上的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">genderChar</span> <span class="operator">=</span> gender.charAt(<span class="number">0</span>);</span><br><span class="line">		System.out.println(genderChar);		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>注意：</strong><br>需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：<code>InputMisMatchException  </code>  导致程序终止</p>
<h3 id="7-3-循环结构"><a href="#7-3-循环结构" class="headerlink" title="7.3 循环结构"></a>7.3 循环结构</h3><p>循环结构</p>
<ul>
<li>在某些条件满足的情况下，反复执行特定代码的功能</li>
</ul>
<hr>
<p>循环语句分类</p>
<ul>
<li>for 循环</li>
<li>while 循环</li>
<li>do-while 循环</li>
</ul>
<hr>
<p>循环语句的四个组成部分</p>
<ul>
<li>初始化部分(init_statement)</li>
<li>循环条件部分(test_exp)</li>
<li>循环体部分(body_statement)</li>
<li>迭代部分(alter_statement)</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221117234547249.png" alt="image-20221117234547249"></p>
<p><strong>拓展：</strong></p>
<ol>
<li><p>（无限循环）不在循环条件部分限制次数的结构：for(;;) 或 while(true)</p>
</li>
<li><p>结束循环有几种方式？</p>
<ul>
<li><p>方式一：循环条件部分返回false</p>
</li>
<li><p>方式二：在循环体中，执行break</p>
</li>
</ul>
</li>
</ol>
<h4 id="7-3-1-for循环"><a href="#7-3-1-for循环" class="headerlink" title="7.3.1 for循环"></a>7.3.1 for循环</h4><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221117235450959.png" alt="image-20221117235450959"></p>
<p>语法格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(①初始化部分; ②循环条件部分; ④迭代部分)｛</span><br><span class="line"></span><br><span class="line">③循环体部分;</span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pubic cass Foroop &#123;</span><br><span class="line">	pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">resut</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">			resut += i;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printn(<span class="string">&quot;resut=&quot;</span> + resut);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<p>①-②-③-④-②-③-④-②-③-④-…..-②</p>
<hr>
<p><strong>说明：</strong></p>
<p>②循环条件部分为boolean类型表达式，当值为false时，退出循环</p>
<p>①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔</p>
<p>④可以有多个变量更新，用逗号分隔</p>
<hr>
<p><strong>易错：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(System.out.print(<span class="string">&#x27;a&#x27;</span>);num&lt;=<span class="number">3</span>;System.out.print(<span class="string">&#x27;c&#x27;</span>),num++)&#123;</span><br><span class="line">			System.out.print(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：abcbcbc</span></span><br></pre></td></tr></table></figure>



<h4 id="7-3-2-while循环"><a href="#7-3-2-while循环" class="headerlink" title="7.3.2 while循环"></a>7.3.2 while循环</h4><p>语法格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①初始化部分</span><br><span class="line"><span class="keyword">while</span>(②循环条件部分)｛</span><br><span class="line">	③循环体部分;</span><br><span class="line">	④迭代部分;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pubic cass whieoop &#123;</span><br><span class="line">	pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">resut</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">			resut += i;</span><br><span class="line">            i++;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printn(<span class="string">&quot;resut=&quot;</span> + resut);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>执行过程：</p>
<p>①**-<strong>②</strong>-<strong>③</strong>-<strong>④</strong>-<strong>②</strong>-<strong>③</strong>-<strong>④</strong>-<strong>②</strong>-<strong>③</strong>-<strong>④</strong>-…-**②</p>
<hr>
<p><strong>说明：</strong></p>
<ul>
<li><p>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</p>
</li>
<li><p>for循环和while循环可以相互转换</p>
<p>区别：for循环和while循环的初始化条件部分的作用范围不同。</p>
</li>
</ul>
<h4 id="7-3-3-do-while循环"><a href="#7-3-3-do-while循环" class="headerlink" title="7.3.3 do-while循环"></a>7.3.3 do-while循环</h4><p>语法格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①初始化部分;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	③循环体部分</span><br><span class="line">	④迭代部分</span><br><span class="line">&#125;<span class="keyword">while</span>(②循环条件部分);</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pubic cass Dowhieoop &#123;</span><br><span class="line">	pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;  </span><br><span class="line">		<span class="type">int</span> <span class="variable">resut</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			resut += i;</span><br><span class="line">			i++;</span><br><span class="line">		&#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br><span class="line">			System.out.printn(<span class="string">&quot;resut=&quot;</span> + resut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>执行过程：</p>
<p>①**-<strong>③</strong>-<strong>④</strong>-<strong>②</strong>-<strong>③</strong>-<strong>④</strong>-<strong>②</strong>-<strong>③</strong>-<strong>④</strong>-…<strong>②（与其他两个相比一开始多了“</strong>-<strong>③</strong>-**④”）</p>
<hr>
<p><strong>说明：</strong></p>
<ul>
<li>do-while循环至少执行一次循环体。</li>
<li>while和for使用的比较多，do-while使用的比较少</li>
</ul>
<h3 id="7-4-嵌套循环（多重循环）"><a href="#7-4-嵌套循环（多重循环）" class="headerlink" title="7.4 嵌套循环（多重循环）"></a>7.4 嵌套循环（多重循环）</h3><ul>
<li><p>将一个循环放在另一个循环体内，就形成了嵌套循环。</p>
<p>其中，for ,while ,do…while均可以作为外层循环或内层循环。</p>
</li>
<li><p>实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的 循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开 始下一次的循环。</p>
</li>
<li><p>设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次。</p>
</li>
<li><p>技巧：外层循环控制行数，内层循环控制列数</p>
</li>
</ul>
<h3 id="7-5-关键字的使用"><a href="#7-5-关键字的使用" class="headerlink" title="7.5 关键字的使用"></a>7.5 关键字的使用</h3><h4 id="7-5-1-break语句"><a href="#7-5-1-break语句" class="headerlink" title="7.5.1 break语句"></a>7.5.1 break语句</h4><ul>
<li>break语句用于终止某个语句块的执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;		……  <span class="keyword">break</span>;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是</p>
<p>哪一层语句块</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abe1:	&#123;	……  </span><br><span class="line">abe2:			&#123;	……</span><br><span class="line">abe3:				&#123;	……</span><br><span class="line">					<span class="keyword">break</span> abe2;</span><br><span class="line">					……</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pubic cass BreakTest&#123;</span><br><span class="line">	pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">3</span>)</span><br><span class="line">				<span class="keyword">break</span>;  </span><br><span class="line">			System.out.printn(<span class="string">&quot; i =&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printn(<span class="string">&quot;Game Over!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-5-2-continue语句"><a href="#7-5-2-continue语句" class="headerlink" title="7.5.2 continue语句"></a>7.5.2 continue语句</h4><ul>
<li>continue只能使用在循环结构中</li>
<li>continue语句用于跳过其所在循环语句块的一次执行，继续下一次循环</li>
<li>continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pubic cass ContinueTest &#123;</span><br><span class="line">	pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;  </span><br><span class="line">            System.out.printn(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>特别说明：</strong></p>
<ul>
<li><strong>break</strong>只能用于switch语句和循环语句中。</li>
<li><strong>continue</strong> 只能用于循环语句中。</li>
<li>二者功能类似，但<strong>continue</strong>是终止<strong>本次</strong>循环，<strong>break</strong>是终止<strong>本层</strong>循环。</li>
<li><strong>break</strong>、<strong>continue</strong>之后不能有其他的语句，因为程序永远不会执行其后的语句。</li>
<li>标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。</li>
</ul>
<h1 id="第二章-gt-gt-gt-数组"><a href="#第二章-gt-gt-gt-数组" class="headerlink" title="第二章&gt;&gt;&gt;数组"></a>第二章&gt;&gt;&gt;数组</h1><h2 id="1-数组的概述"><a href="#1-数组的概述" class="headerlink" title="1. 数组的概述"></a>1. 数组的概述</h2><p>数组(Array)，是多个<strong>相同类型数据</strong>按<strong>一定顺序排列</strong>的集合，并使用一个名字命名，并通过编号的方式 对这些数据进行统一管理。</p>
<p><strong>数组变量（引用类型）中要么存的是地址值，要么是数组元素默认初始值</strong></p>
<p>数组的常见概念</p>
<ul>
<li>数组名</li>
<li>下标(或索引)</li>
<li>元素</li>
<li>数组的长度</li>
</ul>
<ol>
<li><p>数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括</p>
<p>基本数据类型和引用数据类型。</p>
</li>
<li><p>创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是</p>
<p>这块连续空间的首地址。</p>
</li>
<li><p>数组的长度一旦确定，就不能修改。</p>
</li>
<li><p>我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。</p>
</li>
<li><p>数组的分类：</p>
</li>
</ol>
<ul>
<li>按照维度：一维数组、二维数组、三维数组、…</li>
<li>按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组（即对象数组）</li>
</ul>
<h2 id="2-一维数组的使用"><a href="#2-一维数组的使用" class="headerlink" title="2. 一维数组的使用"></a>2. 一维数组的使用</h2><p>一维数组的声明方式：</p>
<p>type  var[] 或 type[]  var；</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] a1;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> b[];</span><br><span class="line"></span><br><span class="line">String[] c; <span class="comment">//引用类型变量数组</span></span><br></pre></td></tr></table></figure>

<hr>
<p>Java语言中<strong>声明数组</strong>时不能指定其长度(数组中元素的数)</p>
<p><strong>易错写法：在[ ]中指定了长度的就不能后面加{ }了。</strong></p>
<p>例如： <code>int a[5]; //非法</code></p>
<hr>
<p>定义并用运算符<strong>new</strong>为之分配空间后，才可以引用数组中的每个元素；</p>
<hr>
<p>数组元素的引用方式：数组名[数组元素下标]</p>
<ul>
<li><p>数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i];}}}</p>
</li>
<li><p>数组元素下标从0开始；长度为n的数组合法下标取值范围: 0 —&gt;n-1；如int a[]&#x3D;new int[3]; 可引用的数组元素为a[0]、a[1]、a[2]</p>
</li>
</ul>
<hr>
<p>每个数组都有一个属性<strong>length</strong>指明它的长度，例如：<strong>a.length</strong> 指明数组<strong>a</strong>的长度(元素个数)。数组一旦初始化，其长度是不可变的。</p>
<h3 id="2-1-初始化方法"><a href="#2-1-初始化方法" class="headerlink" title="2.1 初始化方法"></a>2.1 初始化方法</h3><p><strong>动态初始化</strong>：数组声明且为数组元素分配空间与赋值的操作分开进行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准写法</span></span><br><span class="line">① <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">//指定长度为3</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他写法</span></span><br><span class="line">② String names[];</span><br><span class="line">names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>]; <span class="comment">//指定长度为3</span></span><br><span class="line">names[<span class="number">0</span>] = “钱学森”;</span><br><span class="line">names[<span class="number">1</span>] = “邓稼先”;</span><br><span class="line">names[<span class="number">2</span>] = “袁隆平”;</span><br></pre></td></tr></table></figure>

<p><strong>静态初始化</strong>：在定义数组的同时就为数组元素分配空间并赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准写法</span></span><br><span class="line">① <span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123; <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下都是其他写法</span></span><br><span class="line">② <span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于前面已经声明了String了，所以后面的new String[]可以省略，但是如果是动态写法的先声明然后换行赋值的，就不能省略</span></span><br><span class="line">③ String names[] = &#123;</span><br><span class="line">“李四光”,“茅以升”,“华罗庚”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法：</span></span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[];</span><br><span class="line"><span class="type">int</span>[<span class="number">5</span>] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>[] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他正确的写法：</span></span><br><span class="line"><span class="type">int</span>[] arr4 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//类型推断</span></span><br></pre></td></tr></table></figure>

<hr>
<p>数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化，会有一个默认初始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> a[]= <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">		System.out.println(a[<span class="number">3</span>]);	<span class="comment">//a[3]的默认值为0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于基本数据类型而言，默认初始化值各有不同</li>
<li>对于引用数据类型而言，默认初始化值为**null(**注意与0不同！)</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221120214920910.png" alt="image-20221120214920910"></p>
<h3 id="2-2-内存简化结构"><a href="#2-2-内存简化结构" class="headerlink" title="2.2 内存简化结构"></a>2.2 内存简化结构</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221120215032727.png" alt="image-20221120215032727"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221120215148929.png" alt="image-20221120215148929"></p>
<h2 id="3-二维数组"><a href="#3-二维数组" class="headerlink" title="3. 二维数组"></a>3. 二维数组</h2><p>对于二维数组的理解，我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。其实，从数组底层的运行机制来看，其实没有多维数组。</p>
<h3 id="3-1-初始化方法"><a href="#3-1-初始化方法" class="headerlink" title="3.1 初始化方法"></a>3.1 初始化方法</h3><p><strong>格式1（动态初始化）</strong>：<code>int[][] arr = new int[3][2];</code>  </p>
<p>定义了名称为arr的二维数组 二维数组中有3个一维数组   每一个一维数组中有2个元素  一维数组的名称分别为arr[0],  arr[1],  arr[2]  给第一个一维数组1脚标位赋值为78写法是：arr[0][1]  &#x3D;  78;    </p>
<p><strong>格式2（动态初始化）</strong>：<code>int[][] arr = new int[3][];</code>    </p>
<p>二维数组中有3个一维数组。  每个一维数组都是默认初始化值null  (注意：区别于格式1) 可以对这个三个一维数组分别进行初始化  </p>
<p>arr[0]  &#x3D;  new int[3];  arr[1] &#x3D;  new  int[1];  arr[2]  &#x3D;  new int[2]; </p>
<p> <strong>注</strong>：  int[][]arr &#x3D; new int[][3]; &#x2F;&#x2F;非法  </p>
<p><strong>格式3（静态初始化）</strong>：<code>int[][] arr = new int[][]&#123;&#123;3,8,2&#125;,&#123;2,7&#125;,&#123;9,0,1,6&#125;&#125;;</code></p>
<p>定义一个名称为arr的二维数组，二维数组中有三个一维数组 每一个一维数组中具体元素也都已初始化</p>
<p>第一个一维数组 arr[0] &#x3D; {3,8,2};</p>
<p>第二个一维数组 arr[1] &#x3D; {2,7};</p>
<p>第三个一维数组 arr[2] &#x3D; {9,0,1,6};</p>
<p>第三个一维数组的长度表示方式：arr[2].length;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line">String[][] arr4 = <span class="keyword">new</span> <span class="title class_">String</span>[][<span class="number">4</span>];</span><br><span class="line">String[<span class="number">4</span>][<span class="number">3</span>] arr5 = <span class="keyword">new</span> <span class="title class_">String</span>[][];</span><br><span class="line"><span class="type">int</span>[][] arr6 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他正确的写法</span></span><br><span class="line"><span class="type">int</span>[] arr4[] = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[] arr5[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-内存解析"><a href="#3-2-内存解析" class="headerlink" title="3.2 内存解析"></a>3.2 内存解析</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221124205912973.png" alt="image-20221124205912973"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221124210049178.png" alt="image-20221124210049178"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221124210107003.png" alt="image-20221124210107003"></p>
<p><strong>总结：</strong></p>
<p><strong>规定：</strong>二维数组分为外层数组的元素，内层数组的元素</p>
<p><code>int[][] arr = new int[4][3];</code></p>
<ul>
<li>外层元素：arr[0], arr[1]等</li>
<li>内层元素：arr[0][0], arr[1][2]等</li>
</ul>
<p><strong>数组元素的默认初始化值 ：</strong></p>
<p>针对于初始化方式一：</p>
<p><code>int[][] arr = new int[4][3];</code></p>
<ul>
<li>外层元素的初始化值为：地址值</li>
<li>内层元素的初始化值为：与一维数组初始化情况相同</li>
</ul>
<p>针对于初始化方式二<strong>：</strong></p>
<p><code>int[][] arr = new int[4][];</code></p>
<ul>
<li>外层元素的初始化值为：null</li>
<li>内层元素的初始化值为：不能调用，否则报错。</li>
</ul>
<h2 id="4-数组中涉及到的常见算法"><a href="#4-数组中涉及到的常见算法" class="headerlink" title="4. 数组中涉及到的常见算法"></a>4. 数组中涉及到的常见算法</h2><ol>
<li><p>数组元素的赋值(杨辉三角、回形数等)</p>
</li>
<li><p>数值型数组中元素的最大值、最小值、平均数、总和等</p>
</li>
<li><p>数组的复制、反转、查找(线性查找、二分法查找)</p>
<p>（复制是创建新的数组，反转是在它本身中进行操作）</p>
</li>
<li><p>（*）数组元素的排序算法</p>
</li>
</ol>
<h3 id="4-1-复制操作"><a href="#4-1-复制操作" class="headerlink" title="4.1 复制操作"></a>4.1 复制操作</h3><p>赋值array2变量等于array1，不能称作数组的复制</p>
<p>array1和array2地址值相同，都指向堆空间的唯一的一个数组实体</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221125201356603.png" alt="image-20221125201356603"></p>
<p>数组的复制</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221125201414181.png" alt="image-20221125201414181"></p>
<h3 id="4-2-查找（或搜索）"><a href="#4-2-查找（或搜索）" class="headerlink" title="4.2 查找（或搜索）"></a>4.2 查找（或搜索）</h3><p>① 线性查找</p>
<p>② 二分法查找：所查找的数组要是有序的</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221125205746615.png" alt="image-20221125205746615"></p>
<h3 id="4-3-排序算法"><a href="#4-3-排序算法" class="headerlink" title="4.3 排序算法"></a>4.3 排序算法</h3><p><strong>衡量排序算法的优劣：</strong></p>
<ol>
<li>时间复杂度：分析关键字的比较次数和记录的移动次数</li>
<li>空间复杂度：分析排序算法中需要多少辅助内存</li>
<li>稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保 持不变，则称这种排序算法是稳定的。</li>
</ol>
<p><strong>排序算法分类：内部排序和外部排序</strong></p>
<ol>
<li><p>内部排序：</p>
<p>整个排序过程不需要借助于外部存储器（如磁盘等），所有排 序操作都在内存中完成。</p>
</li>
<li><p>外部排序：</p>
<p>参与排序的数据非常多，数据量非常大，计算机无法把整个排 序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最 常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。</p>
</li>
</ol>
<hr>
<p><strong>十大内部排序算法：</strong></p>
<ul>
<li><p>（选择排序）</p>
<ul>
<li><p>直接选择排序</p>
</li>
<li><p><strong>堆排序</strong></p>
</li>
</ul>
</li>
<li><p>（交换排序）</p>
<ul>
<li><p><strong>冒泡排序</strong></p>
</li>
<li><p><strong>快速排序</strong></p>
</li>
</ul>
</li>
<li><p>（插入排序）</p>
<ul>
<li><p>直接插入排序</p>
</li>
<li><p>折半插入排序</p>
</li>
<li><p>Shell排序</p>
</li>
</ul>
</li>
<li><p><strong>归并排序</strong></p>
</li>
<li><p>桶式排序</p>
</li>
<li><p>基数排列</p>
</li>
</ul>
<hr>
<p><strong>算法的五大特征</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221125130014403.png" alt="image-20221125130014403"></p>
<p>说明：满足确定性的算法也称为：确定性算法。现在人们也关注更广泛的概念，例如 考虑各种非确定性的算法，如并行算法、概率算法等。另外，人们也关注并不要求终 止的计算描述，这种描述有时被称为过程（procedure）。</p>
<h4 id="4-3-1-冒泡排序"><a href="#4-3-1-冒泡排序" class="headerlink" title="4.3.1 冒泡排序"></a>4.3.1 冒泡排序</h4><p><strong>介绍：</strong></p>
<p>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元 素，如果他们的顺序错误就把他们交换过来。</p>
<p><strong>排序思想：</strong></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步 做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要 比较为止。</li>
</ol>
<h4 id="4-3-2-快速排序"><a href="#4-3-2-快速排序" class="headerlink" title="4.3.2 快速排序"></a>4.3.2 快速排序</h4><p><strong>介绍：</strong></p>
<p>快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快</p>
<p>排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见，</p>
<p>掌握快排的重要性。</p>
<p>快速排序（Quick Sort）由图灵奖获得者Tony Hoare发明，被列为20世纪十 大</p>
<p>算法之一，是迄今为止所有内排序算法中速度最快的一种。冒泡排序的升级版，</p>
<p>交换排序的一种。快速排序的时间复杂度为O(nlog(n))。</p>
<p><strong>排序思想：</strong></p>
<ol>
<li><p>从数列中挑出一个元素，称为”基准”（pivot），</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值</p>
<p>大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后， </p>
<p>该基准就处于数列的中间位置。这个称为分区（partition）操作。</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数 列排序。</p>
</li>
<li><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好</p>
<p>了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭</p>
<p>（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
</li>
</ol>
<p><strong>各种内部排序方法性能比较：</strong></p>
<ol>
<li><p>从<strong>平均时间</strong>而言：快速排序最佳。但在最坏情况下时间性能不如堆排序和归</p>
<p>并排序。</p>
</li>
<li><p>从<strong>算法简单性</strong>看：由于直接选择排序、直接插入排序和冒泡排序的算法比较 简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序 算法，其算法比较复杂，认为是复杂排序。</p>
</li>
<li><p>从<strong>稳定性</strong>看：直接插入排序、冒泡排序和归并排序时稳定的；而直接选择排</p>
<p> 序、快速排序、 Shell排序和堆排序是不稳定排序</p>
</li>
<li><p>从<strong>待排序的记录数n的大小</strong>看，n较小时，宜采用简单排序；而n较大时宜采</p>
<p>用改进排序。</p>
</li>
</ol>
<p><strong>排列算法的选择：</strong></p>
<ol>
<li><p>若n较小(如n≤50)，可采用<strong>直接插入</strong>或<strong>直接选择排序</strong>。</p>
<p>当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。</p>
</li>
<li><p>若文件初始状态基本有序(指正序)，则应选用<strong>直接插入</strong>、<strong>冒泡或随机的快速排序</strong>为宜；</p>
</li>
<li><p>若n较大，则应采用时间复杂度为O(nlgn)的排序方法：<strong>快速排序</strong>、<strong>堆排序</strong>或 <strong>归并排序</strong>。</p>
</li>
</ol>
<h2 id="5-Arrays工具类的使用"><a href="#5-Arrays工具类的使用" class="headerlink" title="5. Arrays工具类的使用"></a>5. Arrays工具类的使用</h2><p>java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>boolean  equals(int[]  a,int[]  b)</td>
<td>判断两个数组是否相等。</td>
</tr>
<tr>
<td>2</td>
<td>String  toString(int[]  a)</td>
<td>输出数组信息。</td>
</tr>
<tr>
<td>3</td>
<td>void  fill(int[]  a,int  val)</td>
<td>将指定值填充到数组之中。</td>
</tr>
<tr>
<td>4</td>
<td>void  sort(int[]  a)</td>
<td>对数组进行排序。</td>
</tr>
<tr>
<td>5</td>
<td>int  binarySearch(int[]  a,int key)</td>
<td>对排序后的数组进行二分法检索指定的值。</td>
</tr>
</tbody></table>
<h2 id="6-数组使用中的常见异常"><a href="#6-数组使用中的常见异常" class="headerlink" title="6. 数组使用中的常见异常"></a>6. 数组使用中的常见异常</h2><p>数组脚标越界异常**(ArrayIndexOutOfBoundsException)**</p>
<p>访问到了数组中的不存在的脚标时发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; </span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);  </span><br><span class="line">System.out.println(arr[-<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<hr>
<p>空指针异常**(NullPointerException)**</p>
<p>arr引用没有指向实体，却在操作实体中的元素时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况一：</span></span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr1 = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//情况二：</span></span><br><span class="line"><span class="type">int</span>[][] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line">System.out.println(arr2[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//情况三：</span></span><br><span class="line">String[] arr3 = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;;</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr3[<span class="number">0</span>].toString());</span><br></pre></td></tr></table></figure>



<h1 id="第三章-gt-gt-gt-面向对象基础"><a href="#第三章-gt-gt-gt-面向对象基础" class="headerlink" title="第三章&gt;&gt;&gt;面向对象基础"></a>第三章&gt;&gt;&gt;面向对象基础</h1><p>学习面向对象内容的<strong>三条主线</strong></p>
<ul>
<li>Java类及类的成员</li>
<li>面向对象的三大特征</li>
<li>其它关键字</li>
</ul>
<hr>
<p><strong>面向对象的思想概述</strong></p>
<p>程序员从面向过程的执行者转化成了面向对象的指挥者</p>
<p>面向对象分析方法分析问题的思路和步骤：</p>
<ul>
<li>根据问题需要，选择问题所针对的<strong>现实世界中的实体</strong>。</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了<strong>概念世界中的类</strong>。</li>
<li>把抽象的实体用计算机语言进行描述，<strong>形成计算机世界中类的定义</strong>。即借助某种程序 语言，把类构造成计算机能够识别和处理的数据结构。</li>
<li>将<strong>类实例化成计算机世界中的对象</strong>。对象是计算机世界中解决问题的最终工具。</li>
</ul>
<hr>
<p><strong>面向对象的三大特征</strong></p>
<ul>
<li>封装 (Encapsulation)</li>
<li>继承 (Inheritance)</li>
<li>多态 (Polymorphism)</li>
</ul>
<h2 id="1-面向过程与面向对象"><a href="#1-面向过程与面向对象" class="headerlink" title="1. 面向过程与面向对象"></a>1. 面向过程与面向对象</h2><p><strong>面向过程(POP)</strong> 与 <strong>面向对象(OOP)</strong></p>
<p>二者都是一种思想，面向对象是相对于面向过程而言的。</p>
<ul>
<li>面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。</li>
<li>面向对象，将功能封装进对 象，强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。</li>
</ul>
<p>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。</p>
<hr>
<p>例子（人把大象装进冰箱）：</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221126175104160.png" alt="image-20221126175104160"></p>
<h2 id="2-类和对象"><a href="#2-类和对象" class="headerlink" title="2. 类和对象"></a>2. 类和对象</h2><p> Java语言的<strong>基本元素</strong>：类和对象</p>
<p>**类(Class)<strong>和</strong>对象(Object)**是面向对象的核心概念。</p>
<ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。</li>
</ul>
<hr>
<p>Java类及<strong>类的成员</strong></p>
<ul>
<li><strong>属 性</strong>：对应类中的成员变量		Field &#x3D; 属性 &#x3D; 成员变量 &#x3D; 域、字段</li>
<li><strong>行 为</strong>：对应类中的成员方法		Method &#x3D; (成员)方法 <strong>&#x3D;</strong> 函数</li>
</ul>
<hr>
<p><strong>类的语法格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class  类名 &#123;</span><br><span class="line">属性声明;</span><br><span class="line">方法声明;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：修饰符<span class="keyword">public</span>：类可以被任意访问 类的正文要用&#123; &#125;括起来</span><br><span class="line">    </span><br><span class="line">举例：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age ;	<span class="comment">//声明私有变量 age  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAge</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="comment">//声明方法showAge( )</span></span><br><span class="line">		age = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>创建Java自定义类的步骤：</strong></p>
<ol>
<li>定义类（考虑修饰符、类名）</li>
<li>编写类的属性（考虑修饰符、属性类型、属性名、初始化值）</li>
<li>编写类的方法（考虑修饰符、返回值类型、方法名、形参等）</li>
</ol>
<h2 id="3-对象的创建和使用"><a href="#3-对象的创建和使用" class="headerlink" title="3. 对象的创建和使用"></a>3. 对象的创建和使用</h2><p>类和对象的使用（面向对象思想落地的实现）：</p>
<ol>
<li>创建类，设计类的成员</li>
<li>创建类的对象</li>
<li>通过“对象.属性”或“对象.方法”调用对象的结构</li>
</ol>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221126233758623.png" alt="image-20221126233758623"></p>
<p>创建类的对象 &#x3D; 类的实例化 &#x3D; 实例化类</p>
<p>创建对象语法： <code>类名 对象名 = new 类名();</code></p>
<p>使用 <code>对象名.对象成员</code> 的方式访问对象成员（属性和方法）</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221126234118602.png" alt="image-20221126234118602"></p>
<p>说明：</p>
<p>如果创建了一个类的多个对象，对于类中定义的属性，每个对 象都拥有各自的一套 副本，且互不干扰。</p>
<hr>
<p><strong>类的访问机制：</strong></p>
<ul>
<li><p>在一个类中的访问机制：类中的方法可以直接访问类中的成员变量。</p>
<p>（例外：<strong>static</strong>方法访问非<strong>static</strong>，编译不通过。）</p>
</li>
<li><p>在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中 定义</p>
<p>的成员。</p>
</li>
</ul>
<h3 id="3-1-内存解析"><a href="#3-1-内存解析" class="headerlink" title="3.1 内存解析"></a>3.1 内存解析</h3><ul>
<li>堆（Heap），此内存区域的唯一目的 就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</li>
<li>通常所说的栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。 局部变量表存放了编译期可知长度的 各种基本数据类型（boolean、byte、 char 、 short 、 int 、 float 、 long 、 double）、对象引用（reference类型， 它不等同于对象本身，是对象在堆内 存的首地址）。方法执行完，自动释放。</li>
<li>方法区（Method Area），用于存储已被虚拟机加载的类信息、常量、静态 变量、即时编译器编译后的代码等数 据。</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221126235430578.png" alt="image-20221126235430578"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221126235506823.png" alt="image-20221126235506823"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221126235856391.png" alt="image-20221126235856391"></p>
<h2 id="4-属性-field"><a href="#4-属性-field" class="headerlink" title="4. 属性(field)"></a>4. 属性(field)</h2><p><strong>语法格式：</strong></p>
<p><code>修饰符 数据类型 属性名 = 初始化值;</code></p>
<hr>
<p>变量的分类：<strong>成员变量</strong>与<strong>局部变量</strong></p>
<ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部声明的变量称为局部变量。</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221127000956318.png" alt="image-20221127000956318"></p>
<h3 id="4-1-局部变量和属性"><a href="#4-1-局部变量和属性" class="headerlink" title="4.1 局部变量和属性"></a>4.1 局部变量和属性</h3><p>二者在初始化值方面的异同:</p>
<ul>
<li>同：都有生命周期</li>
<li>异：局部变量除形参外，均需显式初始化。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">成员变量</th>
<th align="center">局部变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">声明的位置</td>
<td align="center">直接声明在类中</td>
<td align="center">方法形参或内部、代码块内、构造器内等</td>
</tr>
<tr>
<td align="center">修饰符</td>
<td align="center">private、public、static、final等</td>
<td align="center">不能用权限修饰符修饰，可以用final修饰</td>
</tr>
<tr>
<td align="center">初始化值</td>
<td align="center">有默认初始化值</td>
<td align="center">没有默认初始化值，必须显式赋值，方可使用</td>
</tr>
<tr>
<td align="center">内存加载位置</td>
<td align="center">堆空间 或 静态域内</td>
<td align="center">栈空间</td>
</tr>
</tbody></table>
<p><strong>成员变量和局部变量的内存位置</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221127001411277.png" alt="image-20221127001411277"></p>
<p><strong>说明：方法中声明的变量、形参是生成在栈空间里面的，类中的属性（成员变量）是生成在堆空间里面！！！</strong></p>
<p><strong>对象属性的默认初始化赋值</strong> </p>
<p>当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。除了 </p>
<p>基本数据类型之外的变量类型都是引用类型，如上面的Person及前面讲过的数</p>
<p>组。</p>
<hr>
<p><strong>属性 总结：</strong></p>
<p><em>属性（成员变量）   vs  局部变量</em></p>
<p><strong>相同点：</strong></p>
<ol>
<li>定义变量的格式：数据类型  变量名 &#x3D; 变量值</li>
<li>先声明，后使用</li>
<li>变量都有其对应的作用域</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li><p>在类中声明的位置的不同</p>
<ul>
<li><p>属性：</p>
<p>直接定义在类的一对{}内</p>
</li>
<li><p>局部变量：</p>
<p>声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</p>
</li>
</ul>
</li>
<li><p>关于权限修饰符的不同</p>
<ul>
<li><p>属性：</p>
<p>可以在声明属性时，指明其权限，使用权限修饰符。</p>
<p>常用的权限修饰符：private、public、缺省、protected  —&gt;封装性</p>
<p>目前，大家声明属性时，都使用缺省就可以了。</p>
</li>
<li><p>局部变量：</p>
<p>不可以使用权限修饰符。</p>
</li>
</ul>
</li>
<li><p>默认初始化值的情况：</p>
<ul>
<li><p>属性：</p>
<p>类的属性，根据其类型，都有默认初始化值。</p>
<p>整型（byte、short、int、long）：0</p>
<p>浮点型（float、double）：0.0</p>
<p>字符型（char）：0  （或’\u0000’）</p>
<p>布尔型（boolean）：false</p>
<p>引用数据类型（类、数组、接口）：null</p>
</li>
<li><p>局部变量：</p>
<p>没有默认初始化值。</p>
<p>意味着，我们在调用局部变量之前，一定要显式赋值。</p>
<p>特别地：形参在调用时，我们赋值即可。</p>
</li>
</ul>
</li>
<li><p>在内存中加载的位置：</p>
<ul>
<li><p>属性：</p>
<p>加载到堆空间中   （非static）</p>
</li>
<li><p>局部变量：</p>
<p>加载到栈空间</p>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>说明：</strong></p>
<ol>
<li><p>修饰符</p>
<ul>
<li><p>常用的权限修饰符有：private、缺省、protected、public</p>
</li>
<li><p>其他修饰符：static、final (暂不考虑)</p>
</li>
</ul>
</li>
<li><p>数据类型</p>
<ul>
<li>任何基本数据类型(如int、boolean) 或 任何引用数据类型。</li>
</ul>
</li>
<li><p>属性名</p>
<ul>
<li>属于标识符，符合命名规则和规范即可。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;	<span class="comment">//声明private变量 age</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> “Lila”;	<span class="comment">//声明public变量 name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-方法（method）"><a href="#5-方法（method）" class="headerlink" title="5. 方法（method）"></a>5. 方法（method）</h2><p>什么是方法(method、函数)：</p>
<ul>
<li><p>方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中 </p>
<p>也称为函数或过程。</p>
</li>
<li><p>将功能封装为方法的目的是，可以实现代码重用，简化代码</p>
</li>
<li><p>Java里的方法不能独立存在，所有的方法必须定义在类里。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="comment">//声明方法getAge()</span></span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="comment">//声明方法setAge</span></span><br><span class="line">	age = i;	<span class="comment">//将参数i的值赋给类的成员变量age</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>关于权限修饰符：默认方法的权限修饰符先都使用public</p>
<ul>
<li><pre><code>        Java规定的4种权限修饰符：private、public、缺省、protected
</code></pre>
</li>
</ul>
<h3 id="5-1-方法的声明格式"><a href="#5-1-方法的声明格式" class="headerlink" title="5.1 方法的声明格式"></a>5.1 方法的声明格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 形参<span class="number">1</span>, 参数类型 形参<span class="number">2</span>,…）｛</span><br><span class="line">	方法体程序代码</span><br><span class="line">	<span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰符：<strong>public,<strong>缺省</strong>,private,</strong> <strong>protected</strong>等</p>
<p>返回值类型：</p>
<ul>
<li><p>没有返回值：<strong>void</strong>。</p>
</li>
<li><p>有返回值，声明出返回值的类型。与方法体中“<strong>return</strong> 返回值”搭配使用方</p>
<p>法名：属于标识符，命名时遵循标识符命名规则和规范，“见名知意” 形参</p>
<p>列表：可以包含零个，一个或多个参数。多个参数时，中间用“**,**”隔开 返回</p>
<p>值。方法在执行完毕后返还给调用它的程序的数据。</p>
</li>
</ul>
<hr>
<p>return关键字的使用：</p>
<ul>
<li><p>使用范围：使用在方法体中</p>
</li>
<li><p>作用：</p>
<p>① 结束方法</p>
<p>② 针对于有返回值类型的方法，使用”return 数据”方法返回所要的数据。</p>
</li>
<li><p>注意点：return关键字后面不可以声明执行语句。</p>
</li>
</ul>
<hr>
<p><strong>方法的调用</strong></p>
<p>方法通过方法名被调用，且只有被调用才会执行。</p>
<hr>
<p><strong>方法调用的过程分析</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221127002257970.png" alt="image-20221127002257970"></p>
<hr>
<p><strong>注 意：</strong></p>
<ul>
<li><p>方法被调用一次，就会执行一次</p>
</li>
<li><p>没有具体返回值的情况，返回值类型用关键字void表示，那么方法体中可 </p>
<p>以不必使用return语句。如果使用，仅用来结束方法。</p>
</li>
<li><p>定义方法时，方法的结果应该返回给调用者，交由调用者处理。</p>
</li>
<li><p>方法中只能调用方法或属性，不可以在方法内部定义方法。</p>
</li>
</ul>
<h3 id="5-2-匿名方法"><a href="#5-2-匿名方法" class="headerlink" title="5.2 匿名方法"></a>5.2 匿名方法</h3><p>匿名对象的使用</p>
<ul>
<li>理解：我们创建的对象，没有显式的赋给一个变量名。即为匿名对象</li>
<li>特征：匿名对象只能调用一次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Phone</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();	</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 匿名对象</span></span><br><span class="line"><span class="comment">//		new Phone().sendEmail();</span></span><br><span class="line"><span class="comment">//		new Phone().playGame();</span></span><br><span class="line">		</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Phone</span>().price = <span class="number">1999</span>;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Phone</span>().showPrice();<span class="comment">//0.0</span></span><br><span class="line"></span><br><span class="line">		<span class="type">PhoneMall</span> <span class="variable">mall</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneMall</span>();</span><br><span class="line"><span class="comment">//		mall.show(p); --&gt; 不使用匿名对象</span></span><br><span class="line">		<span class="comment">// 匿名对象的使用</span></span><br><span class="line">		mall.show(<span class="keyword">new</span> <span class="title class_">Phone</span>());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneMall</span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Phone phone)</span>&#123;</span><br><span class="line">		phone.sendEmail();</span><br><span class="line">		phone.playGame();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">	<span class="type">double</span> price; <span class="comment">//价格</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;发送邮件&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playGame</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showPrice</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;手机价格为：&quot;</span> + price);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-再谈方法"><a href="#6-再谈方法" class="headerlink" title="6 再谈方法"></a>6 再谈方法</h2><h3 id="6-1-方法的重载-overload"><a href="#6-1-方法的重载-overload" class="headerlink" title="6.1 方法的重载(overload)"></a>6.1 方法的重载(overload)</h3><p><strong>重载的概念</strong></p>
<p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。</p>
<p><strong>重载的特点</strong></p>
<p>与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</p>
<p><strong>重载示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回两个整数的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="comment">//返回三个整数的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span>&#123;<span class="keyword">return</span> x+y+z;&#125;</span><br><span class="line"><span class="comment">//返回两个小数的和</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;……&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">float</span> f)</span> &#123;……&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;……&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		print(<span class="number">3</span>);</span><br><span class="line">		print(<span class="number">1.2f</span>);</span><br><span class="line">		print(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>方法的重载 总结：</strong></p>
<p> 方法的重载（overload） </p>
<ol>
<li><p>定义：</p>
<p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p>
<ul>
<li><p>“两同一不同”:同一个类、相同方法名</p>
</li>
<li><p>参数列表不同：参数个数不同，参数类型不同</p>
</li>
</ul>
</li>
<li><p>举例：</p>
<p>Arrays类中重载的<code>sort() / binarySearch()</code></p>
</li>
<li><p>判断是否重载：</p>
<p>严格按照方法重载的<strong>定义</strong>来判断</p>
<p>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！</p>
</li>
<li><p>在通过对象调用方法时，如何确定某一个指定的方法：</p>
<p>方法名 —&gt; 参数列表</p>
</li>
</ol>
<h3 id="6-2-可变个数的参数"><a href="#6-2-可变个数的参数" class="headerlink" title="6.2 可变个数的参数"></a>6.2 可变个数的参数</h3><p>JavaSE 5.0 中提供了**Varargs(<strong>variable number of arguments</strong>)**机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可 变的实参。</p>
<hr>
<p><strong>说明：</strong></p>
<ol>
<li><p>声明格式：方法名(参数的类型名 …参数名)</p>
</li>
<li><p>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个</p>
</li>
<li><p>可变个数形参的方法与同名的方法之间，彼此构成重载</p>
</li>
<li><p>可变参数方法的使用与方法参数部分使用数组是一致的，</p>
<p>形参可以传入一个数组，也可以多个值分别传入</p>
</li>
<li><p>方法的参数部分有可变形参，需要放在形参声明的最后</p>
<p><code>public void show(int i, String ...strs)&#123;&#125;</code></p>
</li>
<li><p>在一个方法的形参位置，最多只能声明一个可变个数形参</p>
</li>
</ol>
<h3 id="6-3-方法参数的值传递机制"><a href="#6-3-方法参数的值传递机制" class="headerlink" title="6.3 方法参数的值传递机制"></a>6.3 方法参数的值传递机制</h3><p>方法，必须由其所在类或对象调用才有意义。若方法含有参数：</p>
<ul>
<li><strong>形参</strong>：方法声明时的参数</li>
<li><strong>实参</strong>：方法调用时实际传给形参的参数值</li>
</ul>
<hr>
<p><strong>Java的实参值如何传入方法呢？</strong></p>
<p>Java里方法的参数传递方式只有一种：<strong>值传递</strong>。 即将实际参数值的副本</p>
<p>（复制品）传入方法内，而参数本身不受影响。</p>
<ul>
<li>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</li>
<li>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</li>
</ul>
<hr>
<p><strong>方法参数的值传递机制 总结：</strong></p>
<p>关于变量的赋值：</p>
<ul>
<li>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。</li>
<li>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m;		</span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);<span class="comment">// m = 10, n = 10</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);<span class="comment">// m = 10, n = 20</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用数据类型</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.personId = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1;<span class="comment">//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。</span></span><br><span class="line"><span class="comment">// p1.personId = p2.personId = 1001</span></span><br><span class="line">System.out.println(<span class="string">&quot;o1.personId = &quot;</span> + p1.personId + <span class="string">&quot;,p2.personId = &quot;</span> +p2.personId);</span><br><span class="line"></span><br><span class="line">p2.personId = <span class="number">1002</span>;</span><br><span class="line"><span class="comment">// p1.personId = p2.personId = 1002</span></span><br><span class="line">System.out.println(<span class="string">&quot;p1.personId = &quot;</span> + p1.personId + <span class="string">&quot;,p2.personId = &quot;</span> +p2.personId);</span><br></pre></td></tr></table></figure>

<hr>
<p>方法的形参的传递机制：值传递</p>
<ul>
<li><p>形参：方法定义时，声明的小括号内的参数</p>
</li>
<li><p>实参：方法调用时，实际传递给形参的数据</p>
</li>
<li><p>值传递机制：</p>
<ul>
<li><p>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。</p>
</li>
<li><p>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型--无法实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValueTransferTest1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">		<span class="type">ValueTransferTest1</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValueTransferTest1</span>();</span><br><span class="line">		test.swap(m, n);</span><br><span class="line">		<span class="comment">//m = 10, n = 20 --&gt; 因为swap中的形参m，n，执行完之后就出栈了（销毁了），所以下列的变量m，			n是main方法里面的m，n</span></span><br><span class="line">		System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//交换两个变量的值的操作</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> m ;</span><br><span class="line">		m = n;</span><br><span class="line">		n = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221128181048082.png" alt="image-20221128181048082"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221128181030390.png" alt="image-20221128181030390"></p>
<p><strong>说明：</strong></p>
<ul>
<li><strong>局部变量</strong>（方法中声明的变量、形参）是生成在栈空间里面的，基本数据类型变量存储的是数据值，引用类型存储的是地址值。</li>
<li><strong>成员变量</strong>（类中的属性）是生成在堆空间里面，new出来的类对象和引用类型对象等存储的是地址值和一些相关的属性值。</li>
</ul>
<hr>
<p>方法里面声明的变量的<strong>“先进后出”</strong>的特性：</p>
<p>即栈空间中的变量先加载出来，然后堆空间new出来的对象再加载出来，根据地址值对应，执行完之后，方法中声明的变量在方法执行完之后就先出栈了，紧接着如果堆空间中new出来的对象的地址值没有与栈空间中的变量对应的地址值来指向，然后堆中的的此结构便也被当作垃圾被回收。</p>
<h3 id="6-4-递归-recursion-方法"><a href="#6-4-递归-recursion-方法" class="headerlink" title="6.4 递归(recursion)方法"></a>6.4 递归(recursion)方法</h3><ul>
<li>递归方法：一个方法体内调用它自身。</li>
<li>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执 行无须循环控制。</li>
<li>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</li>
</ul>
<p>例：汉诺塔、斐波那契数列、阶乘、快速排列</p>
<h2 id="7-封装与隐藏"><a href="#7-封装与隐藏" class="headerlink" title="7. 封装与隐藏"></a>7. 封装与隐藏</h2><p>我们程序设计追求“<strong>高内聚，低耦合</strong>”。</p>
<ul>
<li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li>低耦合 ：仅对外暴露少量的方法用于使用。</li>
</ul>
<hr>
<p>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露 的暴露出来。这就是封装性的设计思想。</p>
<h3 id="7-1-信息的封装和隐藏"><a href="#7-1-信息的封装和隐藏" class="headerlink" title="7.1 信息的封装和隐藏"></a>7.1 信息的封装和隐藏</h3><p>Java中通过将类的结构声明为私有的(private)，再提供公共的（public）方法：**getXxx()<strong>和</strong>setXxx()**实现对该属性的操作，以实现下述目的：</p>
<ul>
<li>隐藏一个类中不需要对外提供的实现细节；</li>
<li>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑， 限制对属性的不合理操作；</li>
<li>便于修改，增强代码的可维护性；</li>
</ul>
<h3 id="7-2-四种权限修饰符"><a href="#7-2-四种权限修饰符" class="headerlink" title="7.2 四种权限修饰符"></a>7.2 四种权限修饰符</h3><p>Java权限修饰符public、protected、(缺省)、private置于类的成员定义前，用来限定对象对该类成员的访问权限。</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(缺省)</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>对于class的权限修饰只可以用public和default(缺省)。</p>
<ul>
<li>public类可以在任意地方被访问。</li>
<li>default类只可以被同一个包内部的类访问。</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221128234301851.png" alt="image-20221128234301851"></p>
<hr>
<p><strong>封装性 总结：</strong></p>
<blockquote>
<p>封装的（private）私有属性和私有方法只能在类里面调用，不能在类以外的域调用。</p>
</blockquote>
<p> <strong>一、问题的引入：</strong></p>
<p>当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属</p>
<p>性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此</p>
<p>之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值</p>
<p>加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法</p>
<p>进行限制条件的添加。（比如：setlegs()）</p>
<p>同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private).</p>
<p>–&gt;此时，针对于属性就体现了封装性。</p>
<p><strong>二、封装性的体现：</strong></p>
<p>我们将类的属性xxx私有化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值（封装性体现的其中一种）</p>
<p>拓展：封装性的体现：① 不对外暴露的私有属性  ② 不对外暴露的私有的方法  ③ 单例模式   …</p>
<p><strong>三、封装性的体现，需要权限修饰符来配合。</strong></p>
<ul>
<li><p>Java规定的4种权限（从小到大排列）：private、缺省、protected 、public </p>
</li>
<li><p>4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类</p>
</li>
<li><p>具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p>
<p>修饰类的话，只能使用：缺省、public</p>
</li>
</ul>
<p>Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。</p>
<h2 id="8-构造器"><a href="#8-构造器" class="headerlink" title="8. 构造器"></a>8. 构造器</h2><p><strong>构造器的特征</strong></p>
<ul>
<li><p>它具有与类相同的名称</p>
</li>
<li><p>它不声明返回值类型。（与声明为void不同）</p>
</li>
<li><p>不能被static、final、synchronized、abstract、native修饰，不能有</p>
<p>return语句返回值</p>
</li>
</ul>
<hr>
<p><strong>构造器的作用</strong>：创建对象；给对象进行初始化</p>
<p>如：<code>Order o = new Order(); Person p = new Person(“Peter”,15);</code></p>
<p>如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的 构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自 动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们 要“洗澡”了。</p>
<hr>
<p><strong>语法格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">修饰符 类名 (参数列表) &#123;</span><br><span class="line">初始化语句；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> legs;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">	legs = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setegs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	legs = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getegs</span><span class="params">()</span> &#123;  <span class="keyword">return</span> legs;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="comment">// 创建Animal类的实例：Animal	a = new Animal();</span></span><br><span class="line"><span class="comment">// 调用构造器，将legs初始化为4。</span></span><br></pre></td></tr></table></figure>

<hr>
<p>根据参数不同，构造器可以分为如下两类：</p>
<ul>
<li>隐式无参构造器（系统默认提供）</li>
<li>显式定义一个或多个构造器（无参、有参）</li>
</ul>
<hr>
<p><strong>注 意：</strong></p>
<ul>
<li>Java语言中，每个类都至少有一个构造器</li>
<li>默认构造器的修饰符与所属类的修饰符一致</li>
<li>一旦显式定义了构造器，则系统不再提供默认构造器</li>
<li>一个类可以创建多个重载的构造器</li>
<li>父类的构造器不可被子类继承</li>
</ul>
<hr>
<p><strong>构造器 总结：</strong></p>
<p>一、构造器的作用：</p>
<ul>
<li>创建对象</li>
<li>初始化对象的信息</li>
</ul>
<p>二、说明：</p>
<ul>
<li>如果没有显式的定义类的构造器的话，则系统默认提供一个<strong>空参的构造器</strong></li>
<li>定义构造器的格式：<code>权限修饰符  类名(形参列表)&#123;&#125;</code></li>
<li>一个类中定义的多个构造器，彼此构成重载</li>
<li>一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</li>
<li>一个类中，至少会有一个构造器。</li>
</ul>
<h3 id="8-1-构造器的重载"><a href="#8-1-构造器的重载" class="headerlink" title="8.1 构造器的重载"></a>8.1 构造器的重载</h3><ul>
<li>构造器一般用来创建对象的同时初始化对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;  </span><br><span class="line">	String name; </span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n , <span class="type">int</span> a)</span>&#123;name=n;age=a;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。</p>
<p>构造器重载举例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, Date d)</span>&#123;<span class="built_in">this</span>(name,age);…&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;…&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Date d)</span> &#123;…&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;…&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造器重载，参数列表必须不同</li>
</ul>
<h3 id="8-2-属性赋值过程"><a href="#8-2-属性赋值过程" class="headerlink" title="8.2 属性赋值过程"></a>8.2 属性赋值过程</h3><p>截止到目前，我们讲到了很多位置都可以对类的属性赋值。现总结这几个位</p>
<p>置，并指明赋值的先后顺序。</p>
<p><strong>赋值的位置：</strong></p>
<p>① 默认初始化</p>
<p>② 显式初始化</p>
<p>③ 构造器中初始化</p>
<p>④ 通过“对象.属性“或“对象.方法”的方式赋值</p>
<p><strong>赋值的先后顺序：</strong></p>
<p>① - ② - ③ - ④</p>
<h3 id="8-3-拓展：JavaBean"><a href="#8-3-拓展：JavaBean" class="headerlink" title="8.3 拓展：JavaBean"></a>8.3 拓展：JavaBean</h3><p>JavaBean是一种Java语言写成的可重用组件。</p>
<hr>
<p>所谓javaBean，是指符合如下标准的Java类：</p>
<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ul>
<hr>
<p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以 用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP  页面、Servet、其他JavaBean、appet程序或者应用来使用这些对象。用 户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关 心任何改变。</p>
<hr>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaBean</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 属性一般定义为private  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">JavaBean</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;  </span><br><span class="line">        age = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String n)</span> &#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-4-拓展：UM类图"><a href="#8-4-拓展：UM类图" class="headerlink" title="8.4 拓展：UM类图"></a>8.4 拓展：UM类图</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221129000121759.png" alt="image-20221129000121759"></p>
<h2 id="9-this的使用"><a href="#9-this的使用" class="headerlink" title="9. this的使用"></a>9. this的使用</h2><p>在Java中，this关键字比较难理解，它的作用和其词义很接近。</p>
<ul>
<li>它在方法内部使用，即这个方法所属对象的引用；</li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象。</li>
</ul>
<p>this 可以调用类的属性、方法和构造器</p>
<hr>
<p>什么时候使用this关键字呢？</p>
<ul>
<li><p>当在方法内需要用到调用该方法的对象时，就用this。</p>
<p>具体的：我们可以用this来区分属性和局部变量。</p>
<p>比如：this.name &#x3D; name;</p>
</li>
</ul>
<hr>
<p>使用this调用属性、方法、构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;	<span class="comment">// 定义Person类</span></span><br><span class="line">	<span class="keyword">private</span> String name ; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 调用构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123; <span class="comment">//无参构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;新对象实例化&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>();	<span class="comment">// 调用本类中的无参构造器</span></span><br><span class="line">		<span class="built_in">this</span>.name = name ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>(name) ; <span class="comment">// 调用有一个参数的构造器</span></span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123; </span><br><span class="line">        <span class="built_in">this</span>.name = name ;  </span><br><span class="line">        <span class="built_in">this</span>.age = age ;	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span> + name) ;</span><br><span class="line">		<span class="built_in">this</span>.speak();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(“年龄：” + <span class="built_in">this</span>.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其</p>
<p>前面添加this， 增强程序的阅读性。不过，通常我们都习惯省略this。</p>
</li>
<li><p>当形参与成员变量同名时， 如果在方法内或构造器内需要使用成员变量，</p>
<p>必须添加this来表明该变量是类的成员变量</p>
</li>
<li><p>使用this访问属性和方法时， 如果在本类中未找到，会从父类中查找</p>
</li>
<li><p>this可以作为一个类中构造器相互调用的特殊格式</p>
</li>
</ol>
<hr>
<p><strong>this关键字 总结：</strong></p>
<p>this关键字的使用：</p>
<ol>
<li><p>this可以用来修饰、调用：属性、方法、构造器</p>
</li>
<li><p>this修饰属性和方法：</p>
<p>this理解为：当前对象  或 当前正在创建的对象</p>
<p>① 在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前</p>
<p>对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况</p>
<p>下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的</p>
<p>方式，表明此变量是属性，而非形参。</p>
<p>② 在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当</p>
<p>前正在创建的对象属性或方法。但是，通常情况下，我们都选择省</p>
<p>略”this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显</p>
<p>式的使用”this.变量”的方式，表明此变量是属性，而非形参。</p>
</li>
<li><p>this调用构造器</p>
<p>① 我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的<strong>其他构造器</strong></p>
<p>② 构造器中不能通过”this(形参列表)”方式调用自己</p>
<p>③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”</p>
<p>④ 规定：”this(形参列表)”必须声明在当前构造器的首行</p>
<p>⑤ 构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器（反证法：如果声明了两个，那么其中一个就不在首行，所以不成立）</p>
</li>
</ol>
<h2 id="10-packag关键字"><a href="#10-packag关键字" class="headerlink" title="10. packag关键字"></a>10. packag关键字</h2><p>package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。它的格式为：</p>
<p><strong>package 顶层包名.子包名 ;</strong></p>
<p>包对应于文件系统的目录，package语句中，用 “**.<strong>” 来指明包</strong>(<strong>目录</strong>)**的层次；</p>
<p>包通常用小写单词标识。通常使用所在公司域名的倒置：com.atguigu.xxx</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pack1\pack2\PackageTest.java</span><br><span class="line"><span class="keyword">package</span> pack1.pack2; <span class="comment">//指定类PackageTest属于包pack1.pack2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageTest</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;in method display()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>package关键字 总结：</strong></p>
<ul>
<li>为了更好的实现项目中类的管理，提供包的概念</li>
<li>使用package声明类或接口所属的包，声明在源文件的首行</li>
<li>包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</li>
<li>每”.”一次，就代表一层文件目录。</li>
</ul>
<p><strong>补充：</strong></p>
<ul>
<li>同一个包下，不能命名同名的接口、类。</li>
<li>不同的包下，可以命名同名的接口、类。</li>
</ul>
<h3 id="10-1-拓展：MVC设计模式"><a href="#10-1-拓展：MVC设计模式" class="headerlink" title="10.1 拓展：MVC设计模式"></a>10.1 拓展：MVC设计模式</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221129190034265.png" alt="image-20221129190034265"></p>
<h3 id="10-2-JDK中主要的包的介绍"><a href="#10-2-JDK中主要的包的介绍" class="headerlink" title="10.2 JDK中主要的包的介绍"></a>10.2 JDK中主要的包的介绍</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221129190154447.png" alt="image-20221129190154447"></p>
<h2 id="11-import关键字"><a href="#11-import关键字" class="headerlink" title="11. import关键字"></a>11. import关键字</h2><p>为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类或全部类(.*)。import语句告诉编译器到哪里去寻找类。</p>
<hr>
<p>语法格式：</p>
<p><strong>import 包名. 类名;</strong></p>
<hr>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pack1.pack2.Test;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackTest</span>&#123; <span class="comment">//import pack1.pack2.*;表示引入pack1.pack2包中的所有结构</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">		<span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();	<span class="comment">//Test类在pack1.pack2包中定义  		 t.display();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong></p>
<ul>
<li>在源文件中使用import显式的导入指定包下的类或接口</li>
<li>声明在包的声明和类的声明之间。</li>
<li>如果需要导入多个类或接口，那么就并列显式多个import语句即可</li>
<li>举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。</li>
<li>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。</li>
<li>如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的 是哪个类。</li>
<li>如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。</li>
<li>import static组合的使用：调用指定类或接口下的静态的属性或方法</li>
</ul>
<h1 id="第四章-gt-gt-gt-面向对象进阶"><a href="#第四章-gt-gt-gt-面向对象进阶" class="headerlink" title="第四章&gt;&gt;&gt;面向对象进阶"></a>第四章&gt;&gt;&gt;面向对象进阶</h1><h2 id="1-继承性-inheritance"><a href="#1-继承性-inheritance" class="headerlink" title="1. 继承性(inheritance)"></a>1. 继承性(inheritance)</h2><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221202212308126.png" alt="image-20221202212308126"></p>
<p>为什么要有继承？</p>
<p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中， 那么多个类无需再定义这些属性和行为，只要继承那个类即可。</p>
<hr>
<p>此处的多个类称为**子类(派生类)<strong>，单独的这个类称为</strong>父类(基类 或超类)**。可以理解为:“子类 is a 父类”</p>
<ul>
<li>子类、派生类、subclass</li>
<li>父类、超类、基类、superclass</li>
</ul>
<hr>
<p>类继承语法规则:</p>
<p><code>class Subclass extends Superclass&#123; &#125;</code></p>
<hr>
<p>作用：</p>
<p>继承的出现减少了代码冗余，提高了代码的复用性。</p>
<p>继承的出现，更有利于功能的扩展。</p>
<p>继承的出现让类与类之间产生了关系，提供了多态的前提。</p>
<blockquote>
<p>不要仅为了获取其他类中某个功能而去继承</p>
</blockquote>
<ul>
<li><p>子类继承了父类，就继承了父类的方法和属性。</p>
</li>
<li><p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和 方法。</p>
</li>
<li><p>在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，</p>
<p>而是对父类的“扩展”。</p>
</li>
</ul>
<hr>
<p>关于继承的规则：</p>
<p>子类不能直接访问父类中私有的(private)的成员变量和方法。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221202212552679.png" alt="image-20221202212552679"></p>
<p>Java只支持单继承和多层继承，不允许多重继承</p>
<ul>
<li>一个子类只能有一个父类</li>
<li>一个父类可以派生出多个子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubDemo</span> <span class="keyword">extends</span> <span class="title class_">Demo</span>&#123; &#125;<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubDemo</span> <span class="keyword">extends</span> <span class="title class_">Demo1</span>,Demo2...<span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221202212706358.png" alt="image-20221202212706358"></p>
<hr>
<p><strong>继承性 总结:</strong></p>
<ul>
<li>体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只有因为封装性的影响，使得子类不能直接调用父类的结构而已。</li>
<li>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。</li>
</ul>
<hr>
<p>Java中关于继承性的规定：</p>
<ol>
<li>一个类可以被多个子类继承。</li>
<li>Java中类的单继承性：一个类只能有一个父类</li>
<li>子父类是相对的概念。</li>
<li>子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类</li>
<li>子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</li>
</ol>
<hr>
<ul>
<li><p>如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类</p>
</li>
<li><p>所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类</p>
</li>
<li><p>意味着，所有的java类具有java.lang.Object类声明的功能。</p>
</li>
</ul>
<h2 id="2-方法的重写-override-x2F-overwrite"><a href="#2-方法的重写-override-x2F-overwrite" class="headerlink" title="2. 方法的重写(override&#x2F;overwrite)"></a>2. 方法的重写(override&#x2F;overwrite)</h2><p><strong>定义：</strong>在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</p>
<hr>
<p><strong>要求：</strong></p>
<ol>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限<ul>
<li>子类不能重写父类中声明为private权限的方法</li>
</ul>
</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ol>
<hr>
<p><strong>注意：</strong></p>
<p>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</p>
<hr>
<p><strong>方法的重写 总结：</strong></p>
<p>一、 重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</p>
<hr>
<p>二、应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p>
<hr>
<p>三、重写的规定：</p>
<p>方法的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line">	<span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p>
<p>① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</p>
<p>② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</p>
<blockquote>
<p>特殊情况：子类不能重写父类中声明为private权限的方法</p>
</blockquote>
<p>③ 返回值类型：</p>
<ul>
<li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li>
<li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</li>
<li>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</li>
</ul>
<p>④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）</p>
<blockquote>
<p>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不叫做重写）。	</p>
</blockquote>
<hr>
<p>四、建议直接从父类中复制方法的声明然后再粘贴到子类中，或者在子类中输入方法名，然后调用快捷键补全</p>
<h2 id="3-四种访问权限修饰符"><a href="#3-四种访问权限修饰符" class="headerlink" title="3. 四种访问权限修饰符"></a>3. 四种访问权限修饰符</h2><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221202213421760.png" alt="image-20221202213421760"></p>
<h2 id="4-super-关键字"><a href="#4-super-关键字" class="headerlink" title="4. super 关键字"></a>4. super 关键字</h2><p>在Java类中使用super来调用父类中的指定操作：</p>
<ul>
<li><p>super可用于访问父类中定义的属性</p>
</li>
<li><p>super可用于调用父类中定义的成员方法</p>
</li>
<li><p>super可用于在子类构造器中调用父类的构造器</p>
</li>
</ul>
<hr>
<p><strong>注意：</strong></p>
<ul>
<li><p>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</p>
</li>
<li><p>super的追溯不仅限于直接父类</p>
</li>
<li><p>super和this的用法相像，this代表本类对象的引用，super代表父类的内存 空间的标识</p>
</li>
</ul>
<h3 id="4-1-调用父类构造器"><a href="#4-1-调用父类构造器" class="headerlink" title="4.1 调用父类构造器"></a>4.1 调用父类构造器</h3><ul>
<li>子类中所有的构造器默认都会访问父类中空参数的构造器</li>
<li>当父类中没有空参数的构造器时，子类的构造器必须通过**this(<strong>参数列表</strong>)<strong>或者</strong>super(<strong>参数列表</strong>)**语句指定调用本类或者父类中相应的 构造器。同时，只能”二选一”，且必须放在构造器的首行</li>
<li>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错</li>
</ul>
<h3 id="4-2-this和super的区别"><a href="#4-2-this和super的区别" class="headerlink" title="4.2 this和super的区别"></a>4.2 this和super的区别</h3><table>
<thead>
<tr>
<th align="center">No.</th>
<th align="left">区别点</th>
<th align="left">this</th>
<th align="left">super</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">访问属性</td>
<td align="left">访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td align="left">直接访问父类中的属性</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">调用方法</td>
<td align="left">访问本类中的方法，如果本类没有此方法则从父类中继续查找</td>
<td align="left">直接访问父类中的方法</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">调用构造器</td>
<td align="left">调用本类构造器，必须放在构造器的首行</td>
<td align="left">调用父类构造器，必须放在子类构造器的首行</td>
</tr>
</tbody></table>
<ul>
<li>this是先从本类中查找有没有相应的结构，如果没有则去父类中查找</li>
<li>super直接到父类中找相应的结构</li>
</ul>
<blockquote>
<p>如果对象调用类的结构时的前面省略了”this.”或者”super.”的时候，则默认现在本来中查找相应的结构名，如果没有找到，再去父类中查找。</p>
</blockquote>
<hr>
<p><strong>super() 总结：</strong></p>
<p>一、super理解为：父类的</p>
<p>二、super可以用来调用：属性、方法、构造器</p>
<p>三、super的使用：调用属性和方法</p>
<ol>
<li>我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</li>
<li>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。</li>
<li>特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</li>
</ol>
<p>四、super调用构造器</p>
<ol>
<li>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</li>
<li>“super(形参列表)”的使用，必须声明在子类构造器的首行！</li>
<li>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现</li>
<li>在构造器的首行，没有显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</li>
<li>在类的多个构造器中，至少有一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</li>
</ol>
<hr>
<p><strong>情境：</strong></p>
<p>如果一个父类中没有提供空参构造器，那么子类在声明空参构造器的时候会报错。因为一个类中如果没有声明构造器的话，那么会自动提供一个空参构造器，而如果在父类中只声明了含参构造器，而没有声明空参构造器时，则就不会默认再提供空参构造器了，所以此时子类中声明空参构造器的时候，由于首行默认是super()来调用父类的构造器，而此时父类没有空参构造器，则会报错。</p>
<p>解决方法：在父类中声明一个空参构造器，或者在子类中提供含参构造器</p>
<h2 id="5-子类对象实例化过程"><a href="#5-子类对象实例化过程" class="headerlink" title="5. 子类对象实例化过程"></a>5. 子类对象实例化过程</h2><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221202214150103.png" alt="image-20221202214150103"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221202214207101.png" alt="image-20221202214207101"></p>
<p><strong>继承性 总结：</strong></p>
<ol>
<li><p>从结果上来看：（继承性）</p>
<p>子类继承父类以后，就获取了父类中声明的属性或方法。</p>
<p>创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。</p>
</li>
<li><p>从过程上来看：</p>
<p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，…</p>
<p>直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有</p>
<p>父类中的结构，子类对象才可以考虑进行调用。</p>
</li>
</ol>
<p>明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p>
<h2 id="6-多态性"><a href="#6-多态性" class="headerlink" title="6. 多态性"></a>6. 多态性</h2><p>作用：可以减少方法的重载</p>
<p>多态性，是面向对象中最重要的概念，在Java中的体现：对象的多态性：父类的引用指向子类的对象</p>
<ul>
<li>抽象类、接口使用肯定体现了多态性（抽象类、接口不能实例化）</li>
</ul>
<hr>
<p>Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明 该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。</p>
<p>简称：编译时，看左边；运行时，看右边。</p>
<ul>
<li><p>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)</p>
</li>
<li><p>多态情况下</p>
<ul>
<li><p>“看左边”：看的是父类的引用（父类中不具备子类特有的方法）</p>
</li>
<li><p>“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>对象的多态 —在Java中,子类的对象可以替代父类的对象使用</p>
<ul>
<li>一个变量只能有一种确定的数据类型</li>
<li>一个引用类型变量可能指向(引用)多种不同类型的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();<span class="comment">//Object类型的变量o，指向Person类型的对象</span></span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">//Object类型的变量o，指向Student类型的对象</span></span><br></pre></td></tr></table></figure>

<p>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。</p>
<hr>
<p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类 对象，那么该变量就不能再访问子类中添加的属性和方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">m.school = “pku”; <span class="comment">//合法,Student类有school成员变量 </span></span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">e.school = “pku”; <span class="comment">//非法,Person类没有school成员变量</span></span><br></pre></td></tr></table></figure>

<p>属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。</p>
<p>不能调用子类所特有的方法、属性，因为编译时，e是Person类型</p>
<h3 id="6-1-虚拟方法"><a href="#6-1-虚拟方法" class="headerlink" title="6.1 虚拟方法"></a>6.1 虚拟方法</h3><p>虚拟方法调用**(Virtual** <strong>Method</strong> <strong>Invocation)</strong></p>
<ul>
<li>正常的方法调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">e.getInfo();</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); e.getInfo();</span><br></pre></td></tr></table></figure>

<ul>
<li>虚拟方法调用(多态情况下)</li>
</ul>
<p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父 类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法 确定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">e.getInfo(); <span class="comment">//调用Student类的getInfo()方法</span></span><br></pre></td></tr></table></figure>

<hr>
<p>编译时类型和运行时类型</p>
<p>编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。——动态绑定</p>
<h3 id="6-2-对象类型转换-Casting"><a href="#6-2-对象类型转换-Casting" class="headerlink" title="6.2 对象类型转换(Casting)"></a>6.2 对象类型转换(Casting)</h3><p><strong>对象类型转换的目的</strong>：由于一开始是左边是父类的引用，子类的对象（new），则转换成左右边都是子类的引用和对象（new），这样就具备了子类的一些结构（属性、方法等）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Man</span> <span class="variable">m</span> <span class="operator">=</span> (Man)p;</span><br></pre></td></tr></table></figure>

<p>如何实现向下转型：</p>
<p>使用强转符：**()**</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221204205545185.png" alt="image-20221204205545185"></p>
<p>问题引出：<strong>如何才能调用子类特有的属性和方法？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person的子类有Man和Woman，Man类中定义了earnMoney方法，Woman中定义了goShoppoing方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向下转型：使用强制类型转换符。</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Man</span> <span class="variable">m</span> <span class="operator">=</span> (Man)p;</span><br><span class="line">m.earnMoney();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用强转时，可能出现ClassCastException的异常。</span></span><br><span class="line"><span class="type">Woman</span> <span class="variable">w</span> <span class="operator">=</span> (Woman)p;</span><br><span class="line">w.goShopping();</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题一：编译时通过，运行时不通过</span></span><br><span class="line"><span class="comment">//举例一：</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line"><span class="type">Man</span> <span class="variable">m</span> <span class="operator">=</span> (Man)p;</span><br><span class="line"><span class="comment">//举例二：</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Man</span> <span class="variable">m</span> <span class="operator">=</span> (Man)p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//问题二：编译通过，运行时也通过</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)obj;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//问题三：编译不通过，无关系类型之间不能进行强转</span></span><br><span class="line">① <span class="type">Man</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();	</span><br><span class="line">② <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();	</span><br><span class="line">③ <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)o;</span><br></pre></td></tr></table></figure>

<hr>
<p>基本数据类型的Casting：</p>
<ul>
<li><p>自动类型转换：小的数据类型可以自动转换成大的数据类型</p>
<p>如long g&#x3D;20; double d&#x3D;12.0f</p>
</li>
<li><p>强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型 </p>
<p>如 float f&#x3D;(float)12.0; int a&#x3D;(int)1200</p>
</li>
</ul>
<p>对<strong>Java</strong>对象的强制类型转换称为造型</p>
<ul>
<li>从子类到父类的类型转换可以自动进行</li>
<li>从父类到子类的类型转换必须通过造型**(<strong>强制类型转换</strong>)**实现</li>
<li>无继承关系的引用类型间的转换是非法的</li>
<li>在造型前可以使用<strong>instanceof</strong>操作符测试一个对象的类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConversionTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//基本数据类型转化</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">13.4</span>;  </span><br><span class="line">        <span class="type">long</span>  = (<span class="type">long</span>) d;</span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="type">int</span> <span class="variable">in</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="comment">// boolean b = (boolean)in; </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对象类型转交换</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">objStr</span> <span class="operator">=</span> (String) obj;  				</span><br><span class="line">        System.out.println(objStr);  </span><br><span class="line">        <span class="type">Object</span> <span class="variable">objPri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>);</span><br><span class="line">		<span class="comment">// 所以下面代码运行时引发CassCastException异常</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) objPri;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="6-3-instanceof-操作符"><a href="#6-3-instanceof-操作符" class="headerlink" title="6.3 instanceof 操作符"></a>6.3 instanceof 操作符</h3><p><strong>x</strong> <strong>instanceof</strong> <strong>A</strong>：检验<strong>x</strong>是否为类<strong>A</strong>的对象，返回值为<strong>boolean</strong>型。</p>
<p>要求x所属的类与类A必须是子类和父类的关系，否则编译错误。</p>
<p>如果x属于类A的子类B，x instanceof A值也为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123;…&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;…&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graduate</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;…&#125;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Person e)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (e <span class="keyword">instanceof</span> Person)&#123;&#125;<span class="comment">// 处理Person类及其子类对象</span></span><br><span class="line">	<span class="keyword">if</span> (e <span class="keyword">instanceof</span> Student)&#123;&#125;<span class="comment">//处理Student类及其子类对象  </span></span><br><span class="line">	<span class="keyword">if</span> (e <span class="keyword">instanceof</span> Graduate)&#123;&#125;<span class="comment">//处理Graduate类及其子类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>instanceof关键字 小结</strong>：</p>
<ul>
<li>a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。</li>
<li>使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</li>
<li>如果 a instanceof A返回true,则 a instanceof B也返回true。其中，类B是类A的父类。</li>
</ul>
<hr>
<p><strong>多态性 总结：</strong></p>
<ol>
<li><p>多态作用：</p>
<ul>
<li>提高了代码的通用性，常称作接口重用</li>
</ul>
</li>
<li><p>前提：</p>
<ul>
<li><p>需要存在继承或者实现关系</p>
</li>
<li><p>有方法的重写</p>
</li>
</ul>
</li>
<li><p>成员方法：</p>
<ul>
<li><p>编译时：要查看引用变量所声明的类中是否有所调用的方法。</p>
</li>
<li><p>运行时：调用实际new的对象所属的类中的重写方法。</p>
</li>
</ul>
</li>
<li><p>成员变量：</p>
<ul>
<li>不具备多态性，只看引用变量所声明的类。</li>
</ul>
</li>
</ol>
<hr>
<p>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的。但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用。</p>
<hr>
<p>一、理解多态性：可以理解为一个事物的多种形态。</p>
<p>二、何为多态性：</p>
<p>​	对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</p>
<p>三、多态的使用：虚拟方法调用</p>
<p>​	有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。（编译，看左边；运行，看右边。）</p>
<p>四、多态性的使用前提：  ① 类的继承关系  ② 方法的重写</p>
<p>五、对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p>
<ul>
<li>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。（编译看左边，运行看右边）</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。（编译运行都看左边）</li>
</ul>
<h2 id="7-Object类的使用"><a href="#7-Object类的使用" class="headerlink" title="7. Object类的使用"></a>7. Object类的使用</h2><p>Object类是所有Java类的根父类</p>
<p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method(Object obj)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="comment">//可以接收任何类作为其参数 </span></span><br><span class="line">method(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>Object类中的主要结构</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>NO.</strong></th>
<th>方法名称</th>
<th align="center">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>public  Object()</td>
<td align="center">构造</td>
<td align="left">构造器</td>
</tr>
<tr>
<td align="center">2</td>
<td>public  boolean  equals(Object  obj)</td>
<td align="center">普通</td>
<td align="left">对象比较</td>
</tr>
<tr>
<td align="center">3</td>
<td>public  int hashCode()</td>
<td align="center">普通</td>
<td align="left">取得Hash码</td>
</tr>
<tr>
<td align="center">4</td>
<td>public String  toString()</td>
<td align="center">普通</td>
<td align="left">对象打印时调用</td>
</tr>
</tbody></table>
<h3 id="7-1-“-x3D-x3D-”-操作符"><a href="#7-1-“-x3D-x3D-”-操作符" class="headerlink" title="7.1 “&#x3D;&#x3D;” 操作符"></a>7.1 “&#x3D;&#x3D;” 操作符</h3><p>用“&#x3D;&#x3D;”进行比较时，符号两边的<strong>数据类型必须兼容</strong>(可自动转换的基本数据类型除外)，否则编译出错</p>
<p>① 基本类型比较值:只要两个变量的值相等，即为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>; <span class="keyword">if</span>(a==<span class="number">6</span>)&#123;…&#125;</span><br></pre></td></tr></table></figure>

<p>② 引用类型比较引用(是否指向同一个对象即地址值是否相等)：只有指向同一个对象时，&#x3D;&#x3D;才返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>();  </span><br><span class="line">Person p2=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1==p2)&#123;…&#125;java</span><br></pre></td></tr></table></figure>



<h3 id="7-2-equals方法"><a href="#7-2-equals方法" class="headerlink" title="7.2 equals方法"></a>7.2 equals方法</h3><ol>
<li><p><strong>equals()<strong>：所有类都继承了</strong>Object</strong>，也就获得了**equals()**方法。还可以重写。</p>
<ul>
<li><p>只能比较引用类型，其作用与“&#x3D;&#x3D;”相同**,**比较是否指向同一个对象。</p>
</li>
<li><p>格式:<code>obj1.equals(obj2)</code></p>
</li>
</ul>
</li>
<li><p>特例：当用<strong>equals()</strong> 方法进行比较时， 对类<strong>Fie 、String 、Date</strong> 及包装类（<strong>Wrapper</strong> <strong>class</strong>）来说，是比较类型及内容而不考虑引用的是否是同一个对象；</p>
<p>（原因：在这些类中重写了Object类的equals()方法。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;BB&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;BB&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">//true</span></span><br><span class="line">System.out.println(s1.equals(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;BB&quot;</span>)));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当自定义使用**equals()**时，可以重写。用于比较两个对象的“内容”是否都相等</p>
</li>
</ol>
<hr>
<p><strong>重写equals()方法的原则</strong></p>
<ol>
<li><p>对称性： 如果<code>x.equals(y)</code>返回是“ true ”， 那么<code>y.equals(x)</code> 也应该返回是</p>
<p>“true”。</p>
</li>
<li><p>自反性：<code>x.equals(x)</code>必须返回是“true”。</p>
</li>
<li><p>传递性：如果<code>x.equals(y)</code>返回是“true”，而且<code>y.equals(z)</code>返回是“true”，</p>
<p>那么<code>z.equals(x)</code>也应该返回是“true”。</p>
</li>
<li><p>一致性：如果<code>x.equals(y)</code>返回是“true”，只要x和y内容一直不变，不管你 重复<code>x.equals(y)</code>多少次，返回都是“true”。</p>
</li>
<li><p>任何情况下，<code>x.equals(nu)</code>，永远返回是“false”；</p>
<p><code>x.equals(和x不同类型的对象)</code>永远返回是“false”。</p>
</li>
</ol>
<hr>
<p><strong>&#x3D;&#x3D;和equals()的区别</strong></p>
<ol>
<li>&#x3D;&#x3D; 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型 就是比较内存地址</li>
<li><strong>equals</strong>的话，它是属于<strong>java.lang.Object</strong>类里面的方法，如果该方法没有被重写过默认也 是**&#x3D;&#x3D;;<strong>我们可以看到</strong>String<strong>等类的</strong>equals<strong>方法是被重写过的，而且</strong>String<strong>类在日常开发中 用的比较多，久而久之，形成了</strong>equals**是比较值的错误观点。</li>
<li>具体要看自定义类里有没有重写Object的equals方法来判断。</li>
<li>通常情况下，重写<strong>equals</strong>方法，会比较类中的相应属性是否都相等。</li>
</ol>
<hr>
<p>&#x3D;&#x3D; 和 equals() 总结：</p>
<p>一、 &#x3D;&#x3D; 的使用：</p>
<p>&#x3D;&#x3D; ：运算符</p>
<ol>
<li><p>可以使用在基本数据类型变量和引用数据类型变量中</p>
</li>
<li><p>① 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</p>
<p>② 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p>
</li>
<li><p>补充： &#x3D;&#x3D; 符号使用时，必须保证符号左右两边的变量类型一致。</p>
</li>
</ol>
<p>二、equals()方法的使用：</p>
<ol>
<li><p>是一个方法，而非运算符</p>
</li>
<li><p>只能适用于引用数据类型</p>
</li>
<li><p>Object类中equals()的定义：</p>
<p>说明：Object类中定义的equals()和&#x3D;&#x3D;的作用是相同的：比较两个对象的地址	值是否相同.即两个引用是否指向同一个对象实体</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</p>
</li>
<li><p>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写。重写的原则：比较两个对象的实体内容是否相同.</p>
</li>
</ol>
<h3 id="7-3-toString-方法"><a href="#7-3-toString-方法" class="headerlink" title="7.3 toString()方法"></a>7.3 toString()方法</h3><p>① toString()方法在Object类中定义，其返回值是String类型，返回类名和它</p>
<p>的引用地址。</p>
<p>② 在进行String与其它类型数据的连接操作时，自动调用toString()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date now=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">System.out.println(“now=”+now); 相当于</span><br><span class="line"></span><br><span class="line">System.out.println(“now=”+now.toString());</span><br></pre></td></tr></table></figure>

<p>③ 可以根据需要在用户自定义类型中重写toString()方法 如String 类重写了toString()方法，返回字符串的值。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1=“hello”;</span><br><span class="line"></span><br><span class="line">System.out.println(s1);<span class="comment">//相当于System.out.println(s1.toString());</span></span><br></pre></td></tr></table></figure>

<p>④ 基本类型数据转换为String类型时，调用了对应包装类的toString()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>; System.out.println(“a=”+a);</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>ToString()方法总结：</strong></p>
<ol>
<li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</p>
</li>
<li><p>Object类中toString()的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Customer</span> <span class="variable">cust1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line">System.out.println(cust1.toString());<span class="comment">//(包的路径）.Customer@15db9742</span></span><br><span class="line">System.out.println(cust1);<span class="comment">//(包的路径）.Customer@15db9742</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;MM&quot;</span>);</span><br><span class="line">System.out.println(str);<span class="comment">//MM</span></span><br><span class="line">System.out.println(str.toString())<span class="comment">//MM</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p>
</li>
</ol>
<h2 id="8-包装类-Wrapper-的使用"><a href="#8-包装类-Wrapper-的使用" class="headerlink" title="8. 包装类(Wrapper)的使用"></a>8. 包装类(Wrapper)的使用</h2><p> 针对<strong>八种基本数据类型</strong>定义相应的引用类型—包装类（封装类） </p>
<p> 有了类的特点，就可以调用类中的方法，Java才是真正的面向对象</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221206124727502.png" alt="image-20221206124727502"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221206130820332.png" alt="image-20221206130820332"></p>
<h3 id="8-1-基本类型-lt-—-gt-包装类"><a href="#8-1-基本类型-lt-—-gt-包装类" class="headerlink" title="8.1 基本类型&lt;—&gt;包装类"></a>8.1 基本类型&lt;—&gt;包装类</h3><p>JDK5.0 新特性：自动装箱和自动拆箱</p>
<p>JDK5.0之后，支持自动装箱，自动拆箱。但类型必须匹配。</p>
<p>① 基本数据类型包装成包装类的实例 —&gt; 装箱</p>
<ul>
<li>通过包装类的构造器实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">500</span>; </span><br><span class="line"><span class="type">Integer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br></pre></td></tr></table></figure>

<ul>
<li>还可以通过字符串参数构造包装类对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(“<span class="number">4.56</span>”);</span><br><span class="line"></span><br><span class="line">Long  = <span class="keyword">new</span> <span class="title class_">Long</span>(“asdf”); <span class="comment">//NumberFormatException</span></span><br></pre></td></tr></table></figure>

<p>② 获得包装类对象中包装的基本类型变量 —&gt; 拆箱</p>
<ul>
<li>调用包装类的<code>.xxxValue()</code>方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Obj.booleanValue();</span><br></pre></td></tr></table></figure>

<hr>
<p>举例：</p>
<p>一、基本数据类型—&gt;包装类</p>
<p>① JDK5.0之前：调用包装类的构造器（较少用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对int和Integer</span></span><br><span class="line">① </span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(num1);--&gt;<span class="comment">//Integer(int value) </span></span><br><span class="line">System.out.println(in1);<span class="comment">//10	</span></span><br><span class="line">② </span><br><span class="line"><span class="type">Integer</span> <span class="variable">in2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;123&quot;</span>);--&gt;<span class="comment">//Integer(String s)</span></span><br><span class="line">System.out.println(in2);<span class="comment">//123		</span></span><br><span class="line">③ </span><br><span class="line"><span class="type">Integer</span> <span class="variable">in3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;123abc&quot;</span>);</span><br><span class="line">System.out.println(in3);<span class="comment">//报异常 NumberFormatException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对float和Float</span></span><br><span class="line"><span class="type">Float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">12.3f</span>);</span><br><span class="line"><span class="type">Float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="string">&quot;12.3&quot;</span>);</span><br><span class="line">System.out.println(f1);<span class="comment">//12.3</span></span><br><span class="line">System.out.println(f2);<span class="comment">//12.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对boolean和Boolean</span></span><br><span class="line">① </span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);--&gt;<span class="comment">//Boolean(boolean value)</span></span><br><span class="line">②</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;TrUe&quot;</span>);--&gt;<span class="comment">//Boolean(String s),构造器里面还调用了一个方法可以实现忽略字符串的大小写</span></span><br><span class="line">System.out.println(b2);<span class="comment">//true</span></span><br><span class="line">③ 特别的：下列不会像其他基本数据类型一样报异常，而是返回<span class="literal">false</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;true123&quot;</span>);</span><br><span class="line">System.out.println(b3);<span class="comment">//false</span></span><br><span class="line">④ 特别的：</span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">System.out.println(order.isMale);<span class="comment">//false（isMale还没赋过值，所以默认false）</span></span><br><span class="line">System.out.println(order.isFemale);<span class="comment">//null（isMale还没实例化对象，所以默认null）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">	<span class="type">boolean</span> isMale;</span><br><span class="line">	Boolean isFemale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② JDK5.0之后的新特性：自动装箱（常用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对int和Integer（其他类型用法类似）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> num;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">in2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(in1);<span class="comment">//10</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(in.toString());<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//体现：可以直接把一个基本类型当作对象传给Object obj形参，说明存在自动装箱，自动的将int num转成了Integer num然后再传进去</span></span><br><span class="line">method(num);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">		System.out.println(obj);<span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、包装类—&gt;基本数据类型</p>
<p>① JDK5.0之前：调用包装类Xxx的<code>xxxValue()</code>（较少用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对int和Integer（其他类型用法类似）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);	</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> in.intValue();</span><br><span class="line">System.out.println(i + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>② JDK5.0之后：自动拆箱（常用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对int和Integer（其他类型用法类似）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">20</span>);</span><br><span class="line">System.out.println(in)<span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>自动装箱：包装类的引用，基本数据类型的数据值 —&gt;  Integer in &#x3D; 20;</p>
<p>自动拆箱：基本数据类型的声明，包装类对象的实例  —&gt;  int n &#x3D; new Integer(20);</p>
</blockquote>
<h3 id="8-2-基本类型、包装类-lt-—-gt-String类型"><a href="#8-2-基本类型、包装类-lt-—-gt-String类型" class="headerlink" title="8.2 基本类型、包装类&lt;—&gt;String类型"></a>8.2 基本类型、包装类&lt;—&gt;String类型</h3><p>① 字符串（String类型）—&gt;基本数据类型</p>
<ul>
<li>通过包装类的构造器实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(“<span class="number">12</span>”);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过包装类的<code>parseXxx(String s)</code>静态方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> Float.parseFloat(“<span class="number">12.1</span>”);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱加String类型转换</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//特殊的：boolean和Boolean</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true1&quot;</span>);</span><br><span class="line">System.out.println(b1);<span class="comment">//false（Boolean类中对此做了优化，不会直接像其他数据类型一样抛出异常，具体见Boolean类中的paeseBoolean(String s)方法，它判断不是&quot;true&quot;和null的话就返回false）</span></span><br></pre></td></tr></table></figure>

<p>② 基本数据类型—&gt;字符串（String类型）</p>
<ul>
<li>调用String类重载的<code>valueOf(Xxx xxx)</code>方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(<span class="number">2.34f</span>);<span class="comment">//&quot;2.34&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更直接的方式：连接运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">intStr</span> <span class="operator">=</span> <span class="number">5</span> + <span class="string">&quot;&quot;</span> <span class="comment">//&quot;5&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="拓展：JUnit单元测试"><a href="#拓展：JUnit单元测试" class="headerlink" title="拓展：JUnit单元测试"></a>拓展：JUnit单元测试</h3><p><strong>作用：</strong></p>
<p>可以单独测试一段代码是否能正常运行，不用单独的使用main方法，也不需要通过注释其他代码来使单独一段代码执行。</p>
<hr>
<p><strong>步骤：</strong></p>
<ol>
<li><p>① 选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步</p>
<p>② 或者直接在代码中输入JUnit结构，便可以根据@Test的提示导入相应的包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testxxx</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Java类，进行单元测试。</p>
<p>此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器</p>
</li>
<li><p>此类中声明单元测试方法。</p>
<p>此时的单元测试方法：方法的权限是public,没有返回值，没有形参</p>
</li>
<li><p>此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：<code>import org.junit.Test;</code></p>
</li>
<li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p>
</li>
<li><p>写完代码以后，左键双击选中单元测试方法名，右键：run as - JUnit Test</p>
</li>
</ol>
<hr>
<p><strong>说明：</strong></p>
<p>1.如果执行结果没有任何异常：绿条</p>
<p>2.如果执行结果出现异常：红条</p>
<h1 id="第五章-gt-gt-gt-面向对象高级"><a href="#第五章-gt-gt-gt-面向对象高级" class="headerlink" title="第五章&gt;&gt;&gt;面向对象高级"></a>第五章&gt;&gt;&gt;面向对象高级</h1><h2 id="1-static-关键字"><a href="#1-static-关键字" class="headerlink" title="1. static 关键字"></a>1. static 关键字</h2><p><strong>为什么要使用static关键字？</strong></p>
<p>当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上 的对象，只有通过<strong>new关键字才会产生出对象</strong>，这时系统才会分配内存空间给对象， 其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少 对象的情况下，某些特定的数据<strong>在内存空间里只有一份</strong>。</p>
<hr>
<p><strong>类属性、类方法的设计思想</strong></p>
<ul>
<li>类属性作为该类各个对象之间共享的变量。在设计类时**,**分析哪 些属性不因对象的不同而改变，将这些属性设置为类属性。相应 的方法设置为类方法。</li>
<li>如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。</li>
</ul>
<hr>
<p><strong>使用范围：</strong></p>
<ul>
<li>在Java类中，可用static修饰属性、方法、代码块、内部类</li>
</ul>
<hr>
<p><strong>被修饰后的成员具备以下特点：</strong></p>
<ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰的成员，被所有对象所共享</li>
<li>访问权限允许时，可不创建对象，直接被类调用</li>
</ul>
<h3 id="1-1-类变量-class-Variable"><a href="#1-1-类变量-class-Variable" class="headerlink" title="1.1 类变量(class Variable)"></a>1.1 类变量(class Variable)</h3><p>类变量（类属性）由该类的所有实例共享</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221207133223544.png" alt="image-20221207133223544"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221207133240672.png" alt="image-20221207133240672"></p>
<h3 id="1-2-类方法-class-method"><a href="#1-2-类方法-class-method" class="headerlink" title="1.2 类方法(class method)"></a>1.2 类方法(class method)</h3><ul>
<li>没有对象的实例时，可以用**类名.方法名()**的形式访问由static修饰的类方法。</li>
<li>在<strong>static</strong>方法内部只能访问类的<strong>static</strong>修饰的属性或方法，不能访问类的非<strong>static</strong>的结构。</li>
<li>因为不需要实例就可以访问<strong>static</strong>方法，因此<strong>static</strong>方法内部不能有<strong>this</strong>和<strong>super</strong>（有生命周期来看，static修饰的结构是随着类加载而加载的，先于对象的实例，创建对象之后才能用this和super来修饰）</li>
<li><strong>static</strong>修饰的方法不能被重写</li>
</ul>
<hr>
<p><strong>static 总结：</strong></p>
<ol>
<li><p>static:静态的</p>
</li>
<li><p>static可以用来修饰：属性、方法、代码块、内部类</p>
</li>
<li><p>使用static<strong>修饰属性</strong>：静态变量（或类变量）</p>
</li>
</ol>
<ul>
<li><p>属性，按是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)</p>
</li>
<li><p>实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</p>
</li>
<li><p>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</p>
</li>
<li><p>static修饰属性的其他说明：</p>
</li>
</ul>
<p>  ① 静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用</p>
<p>  ② 静态变量的加载要早于对象的创建。</p>
<p>  ③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</p>
<p>​		④		类变量	实例变量</p>
<p>​		类			yes		no</p>
<p>​		对象		yes		yes</p>
<ul>
<li>静态属性举例：<code>System.out</code>; <code>Math.PI</code>;</li>
</ul>
<ol start="4">
<li><p>使用static<strong>修饰方法</strong>：静态方法</p>
<p>① 随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</p>
<p>②			静态方法	非静态方法</p>
<p>类		yes		no</p>
<p>对象		yes		yes</p>
<p>③ 静态方法中，只能调用静态的方法或属性非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
</li>
<li><p>static注意点：</p>
</li>
</ol>
<ul>
<li><p>在静态的方法内，不能使用this关键字、super关键字</p>
</li>
<li><p>关于静态属性和静态方法的使用，大家都从<strong>生命周期的角度</strong>去理解。</p>
</li>
</ul>
<ol start="6">
<li>① 开发中，如何确定一个属性是否要声明为static的？</li>
</ol>
<ul>
<li><p>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</p>
</li>
<li><p>类中的常量也常常声明为static</p>
<p>② 开发中，如何确定一个方法是否要声明为static的？</p>
</li>
<li><p>操作静态属性的方法，通常设置为static的</p>
</li>
<li><p>类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</p>
</li>
</ul>
<blockquote>
<p>技巧：根据生命周期来判断如何使用。static修饰的结构是随着类加载而加载的，并且只加载一次；非static修饰的结构是随着对象的创建而加载的。</p>
</blockquote>
<h3 id="1-3-单例-Singleton-设计模式"><a href="#1-3-单例-Singleton-设计模式" class="headerlink" title="1.3 单例(Singleton)设计模式"></a>1.3 单例(Singleton)设计模式</h3><p><strong>定义：</strong></p>
<p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对 某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</p>
<hr>
<p><strong>步骤：</strong></p>
<p>① 将类的构造器访问权限设置为private</p>
<p>② 类的内部提供一个当前类的的实例（也需要静态化）</p>
<p>③ 类的内部提供一个public的静态方法，返回当前类对象</p>
<hr>
<p><strong>单例模式的优点：</strong></p>
<p>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的 产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方 式来解决。</p>
<hr>
<p><strong>应用场景：</strong></p>
<ul>
<li>网站的计数器，一般也是单例模式实现，否则难以同步。</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志 文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库 资源。</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。</li>
<li>Application 也是单例的典型应用</li>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程 中，回收站一直维护着仅有的一个实例。</li>
</ul>
<h4 id="1-3-1-饿汉式"><a href="#1-3-1-饿汉式" class="headerlink" title="1.3.1 饿汉式"></a>1.3.1 饿汉式</h4><ul>
<li><pre><code>坏处：对象加载时间过长。
</code></pre>
</li>
<li><pre><code>好处：饿汉式是线程安全的
</code></pre>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="comment">// 1.私有化构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">	<span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> single;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-3-2-懒汉式"><a href="#1-3-2-懒汉式" class="headerlink" title="1.3.2 懒汉式"></a>1.3.2 懒汉式</h4><ul>
<li>好处：延迟对象的创建。</li>
</ul>
<ul>
<li><pre><code>      目前的写法坏处：线程不安全。---&gt;（到多线程内容时再修改）
</code></pre>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="comment">// 1.私有化构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">	<span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton single;</span><br><span class="line">	<span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">null</span>) &#123;</span><br><span class="line">		single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> single;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-理解main方法的语法"><a href="#2-理解main方法的语法" class="headerlink" title="2. 理解main方法的语法"></a>2. 理解main方法的语法</h2><ul>
<li>由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是 pubic，又因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须 是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令 时传递给所运行的类的参数。</li>
<li>又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。</li>
</ul>
<hr>
<p><strong>命令行参数用法举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pubic cass CommandPara &#123;</span><br><span class="line">	pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; 	i &lt; args.ength; i++) &#123;</span><br><span class="line">			System.out.printn(<span class="string">&quot;args[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221208133444117.png" alt="image-20221208133444117"></p>
<hr>
<p><code>main()</code>方法使用说明：</p>
<ol>
<li><p>main()方法作为程序的入口</p>
</li>
<li><p>main()方法也是一个普通的静态方法</p>
</li>
<li><p>main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner）</p>
</li>
</ol>
<h2 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3. 代码块"></a>3. 代码块</h2><p>代码块(或初始化块)的<strong>作用</strong>：</p>
<ul>
<li>对<strong>Java</strong>类或对象进行初始化</li>
</ul>
<p>代码块(或初始化块)的<strong>分类</strong>：</p>
<ul>
<li>一个类中代码块若有修饰符， 则只能被static修饰，称为静态代码块(static bock)；没有使用static修饰的，为非静态代码块。</li>
</ul>
<p><strong>static</strong>代码块通常用于初始化<strong>static</strong>的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cass Person &#123;</span><br><span class="line">	pubic <span class="keyword">static</span> <span class="type">int</span> tota;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		total = <span class="number">100</span>;<span class="comment">//为total赋初值</span></span><br><span class="line">	&#125;</span><br><span class="line">	…… <span class="comment">//其它属性或方法声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>① <strong>静态代码块：用static 修饰的代码块</strong></p>
<ol>
<li><p>可以有输出语句。</p>
</li>
<li><p>作用：可以对类的属性、类的声明进行初始化操作。</p>
</li>
<li><p>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</p>
</li>
<li><p>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</p>
</li>
<li><p>静态代码块的执行要先于非静态代码块。</p>
</li>
<li><p>静态代码块<strong>随着类的加载而执行</strong>，且<strong>只执行一次。</strong></p>
</li>
</ol>
<p>② <strong>非静态代码块：没有static修饰的代码块</strong></p>
<ol>
<li><p>可以有输出语句。</p>
</li>
<li><p>可以对类的属性、类的声明进行初始化操作。</p>
</li>
<li><p>除了调用非静态的结构外，还可以调用静态的变量或方法。</p>
</li>
<li><p>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</p>
</li>
<li><p>每次<strong>创建对象的时候</strong>，都会执行一次（随着类的创建而执行）。且<strong>先于构造器执行</strong>。</p>
</li>
</ol>
<blockquote>
<p>静态代码块可以调用静态的结构，而不能调用非静态的结构；</p>
<p>非静态代码块既可以调用静态的结构，又可以调用非静态的结构。</p>
</blockquote>
<hr>
<p><strong>程序中成员变量赋值的执行顺序</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221208134314939.png" alt="image-20221208134314939"></p>
<p> <strong>对属性可以赋值的位置</strong>：</p>
<p>执行的先后顺序：① - ② &#x2F; ⑤ - ③ - ④</p>
<p>①默认初始化</p>
<p>②显式初始化&#x2F;⑤在代码块中赋值</p>
<p>③构造器中初始化</p>
<p>④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</p>
<h2 id="4-final-关键字"><a href="#4-final-关键字" class="headerlink" title="4. final 关键字"></a>4. final 关键字</h2><p>在Java中声明类、变量和方法时，可使用关键字final来修饰,表示“最终的”。</p>
<ul>
<li><p><strong>final</strong>标记的类不能被继承。提高安全性，提高程序的可读性。</p>
<p>String类、System类、StringBuffer类</p>
</li>
<li><p><strong>final</strong>标记的方法不能被子类重写。</p>
<p>比如：Object类中的getClass()。</p>
</li>
<li><p><strong>final</strong>标记的变量**(<strong>成员变量或局部变量</strong>)**即称为常量。名称大写，且只能被赋值一次。</p>
<p>final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋 值，然后才能使用。</p>
</li>
</ul>
<hr>
<p>① final修饰类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;<span class="comment">//错误，不能被继承。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② final修饰方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123; <span class="comment">// 错误，不能被重写。</span></span><br><span class="line">	System.out.println(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ final修饰变量——常量</p>
<p>补充：static final：全局常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INFO</span> <span class="operator">=</span> <span class="string">&quot;atguigu&quot;</span>;<span class="comment">//声明常量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//The final field A.INFO cannot be assigned</span></span><br><span class="line">		<span class="comment">//INFO = &quot;尚硅谷&quot;;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>final 总结：</strong></p>
<ol>
<li><p>final可以用来修饰的结构：类、方法、变量</p>
</li>
<li><p>final 用来修饰一个类:此类不能被其他类所继承。</p>
</li>
</ol>
<ul>
<li>比如：String类、System类、StringBuffer类</li>
</ul>
<ol start="3">
<li>final 用来修饰方法：表明此方法不可以被重写</li>
</ol>
<ul>
<li>比如：Object类中getClass();</li>
</ul>
<ol start="4">
<li>final 用来修饰变量：此时的”变量”就称为是一个常量</li>
</ol>
<ul>
<li><p>final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化</p>
</li>
<li><p>final修饰局部变量：</p>
<p>尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</p>
</li>
</ul>
<blockquote>
<p>static final 用来修饰属性：全局常量</p>
<p>由于final修饰的类无子类，因此要保证每一个final修饰的属性都在类内部赋上了值。（若要使用构造器对final修饰的属性进行初始化赋值则不能有多个构造器，不能在方法中对final修饰的属性赋值）</p>
</blockquote>
<h2 id="5-抽象类与抽象方法"><a href="#5-抽象类与抽象方法" class="headerlink" title="5. 抽象类与抽象方法"></a>5. 抽象类与抽象方法</h2><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一 般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它<strong>没有具体的实例，这样的类叫做抽象类</strong>。</p>
<hr>
<ul>
<li><p>用abstract关键字来修饰一个类，这个类叫做<strong>抽象类</strong>。</p>
</li>
<li><p>用abstract来修饰一个方法，该方法叫做<strong>抽象方法</strong>。</p>
<ul>
<li><p>抽象方法：只有方法的声明，没有方法的实现，以分号结束。</p>
<p>比如：<code>public abstract void talk();</code></p>
</li>
</ul>
</li>
<li><p><strong>含有抽象方法的类必须被声明为抽象类。</strong></p>
</li>
<li><p>抽象类不能被实例化。抽象类是用来被继承的，<strong>抽象类的子类必须重写父类的抽象方法，并提供方法体。</strong>若没有重写全部的抽象方法，仍为抽象类。</p>
</li>
<li><p>不能用abstract修饰变量、代码块、构造器；</p>
</li>
<li><p>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</p>
</li>
</ul>
<blockquote>
<p>父类中声明的抽象方法在子类中必须重写，否则会报错。</p>
</blockquote>
<h3 id="5-1-匿名子类"><a href="#5-1-匿名子类" class="headerlink" title="5.1 匿名子类"></a>5.1 匿名子类</h3><p>① <strong>非匿名的类、非匿名的对象</strong></p>
<p>创建有类，对象实例化的时候有显式的取对象名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象 = <span class="keyword">new</span> 类名()</span><br></pre></td></tr></table></figure>

<p>② <strong>非匿名的类、匿名的对象</strong></p>
<p>创建有类，对象实例化的时候没有显式的取对象名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名(new 类名())</span><br></pre></td></tr></table></figure>

<p>③ <strong>匿名的子类、非匿名的对象</strong></p>
<p>没有创建子类，子类对象实例化的时候有显式的取对象名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象名 = <span class="keyword">new</span> 父类名()&#123;</span><br><span class="line">	<span class="comment">//子类重写父类的方法</span></span><br><span class="line">    <span class="comment">//……(或者子类中的新方法)</span></span><br><span class="line">&#125;</span><br><span class="line">方法名(对象名)</span><br></pre></td></tr></table></figure>

<p>④ <strong>匿名的子类、匿名的对象</strong></p>
<p>没有创建子类，对象实例化的时候没有显式的取对象名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法名(<span class="keyword">new</span> 父类名()&#123;</span><br><span class="line">	<span class="comment">//子类重写父类的方法</span></span><br><span class="line">    <span class="comment">//……(或者子类中的新方法)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="keyword">new</span> <span class="title class_">Student</span>());<span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">① <span class="comment">//非匿名的类、非匿名的对象</span></span><br><span class="line"><span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">method(worker);</span><br><span class="line"></span><br><span class="line">② <span class="comment">//非匿名的类、匿名的对象	</span></span><br><span class="line">method(<span class="keyword">new</span> <span class="title class_">Worker</span>());	</span><br><span class="line"></span><br><span class="line">③ <span class="comment">//创建了一匿名子类的对象：p</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breath</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;好好呼吸&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;	</span><br><span class="line">method(p);</span><br><span class="line"></span><br><span class="line">④ <span class="comment">//创建匿名子类的匿名对象</span></span><br><span class="line">method(<span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃好吃东西&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breath</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;好好呼吸新鲜空气&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>abstract 总结：</strong></p>
<ol>
<li><p>abstract:抽象的</p>
</li>
<li><p>abstract可以用来修饰的结构：<strong>类、方法</strong></p>
</li>
<li><p>abstract不能用来修饰：<strong>属性</strong>、<strong>构造器</strong>等结构；</p>
<p>abstract不能用来修饰<strong>私有方法</strong>（私有方法在子类中无法被访问，则无法重写父类声明的抽象方法）、<strong>静态方法</strong>（① 静态方法不能被重写 ② 静态方法可以直接通过类去调用，而abstract修饰的抽象方法是不能调用的）、<strong>final的方法</strong>、<strong>final的类</strong>（final修饰的类或者方法不能在子类中修改）</p>
</li>
<li><p>abstract修饰类：抽象类</p>
</li>
</ol>
<ul>
<li><p>此类不能实例化</p>
</li>
<li><p>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</p>
</li>
<li><p>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</p>
</li>
</ul>
<ol start="5">
<li>abstract修饰方法：抽象方法</li>
</ol>
<ul>
<li><p>抽象方法只有方法的声明，没有方法体</p>
</li>
<li><p>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</p>
</li>
<li><p>（*）若子类<strong>重写了父类中的所有的抽象方法</strong>后，此子类方可实例化；若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</p>
</li>
</ul>
<blockquote>
<p>如果类中含有抽象方法，那么此类一定是抽象类，因为抽象类不能实例化对象，所以不能同过实例化抽象类来调用此抽象方法，因此必须将类也声明为抽象类，让子类实例化对象来调用此抽象方法。</p>
</blockquote>
<h3 id="5-1-模板方法设计模式-TempateMethod"><a href="#5-1-模板方法设计模式-TempateMethod" class="headerlink" title="5.1 模板方法设计模式(TempateMethod)"></a>5.1 模板方法设计模式(TempateMethod)</h3><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<p><strong>解决的问题：</strong></p>
<ul>
<li>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li>
<li>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用， 这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</li>
</ul>
<hr>
<p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>JavaWeb的Servet中关于doGet&#x2F;doPost方法调用</li>
<li>Hibernate中模板程序</li>
<li>Spring中JDBCTemate、HibernateTempate等</li>
</ul>
<h2 id="6-接口-interface"><a href="#6-接口-interface" class="headerlink" title="6. 接口(interface)"></a>6. 接口(interface)</h2><ul>
<li>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</li>
<li>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是&#x2F;要…则 必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能” 的关系。</li>
<li>接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。</li>
</ul>
<hr>
<p>接口(interface)是抽象方法和常量值定义的集合。</p>
<p><strong>接口的特点：</strong></p>
<ul>
<li>用interface来定义。</li>
<li>接口中的所有成员变量都默认是由public static final修饰的。</li>
<li>接口中的所有抽象方法都默认是由public abstract修饰的。</li>
<li>接口中没有构造器。</li>
<li>接口采用多继承机制。</li>
</ul>
<p><strong>接口定义举例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runner</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>定义Java类的<strong>语法格式</strong>：先写extends，后写implements</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个类可以实现多个接口，接口也可以继承其它接口。</li>
<li>实现接口的类中必须<strong>提供接口中所有方法的具体实现内容</strong>，方可实例化。否则，仍为抽象类。</li>
<li>接口的主要用途就是被实现类实现。（面向接口编程）</li>
<li>与继承关系类似，接口与实现类之间存在多态性</li>
<li>接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，  接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义 (JDK7.0及之前)，而没有变量和方法的实现。</li>
</ul>
<hr>
<h3 id="6-1-匿名接口实现类"><a href="#6-1-匿名接口实现类" class="headerlink" title="6.1 匿名接口实现类"></a>6.1 匿名接口实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Flash类--u盘</span></span><br><span class="line"><span class="comment">Printer类--打印机</span></span><br><span class="line"><span class="comment">Flash类和Printer类都是USB接口的实现类</span></span><br><span class="line"><span class="comment">start()--USB接口的抽象方法</span></span><br><span class="line"><span class="comment">stop()--USB接口的抽象方法</span></span><br><span class="line"><span class="comment">transferData(USB usb)--Computer类中的方法，形参是USB接口的实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">Computer</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line"><span class="comment">//1.创建了接口的非匿名实现类的非匿名对象</span></span><br><span class="line"><span class="type">Flash</span> <span class="variable">flash</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Flash</span>();</span><br><span class="line">com.transferData(flash);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//2. 创建了接口的非匿名实现类的匿名对象</span></span><br><span class="line">com.transferData(<span class="keyword">new</span> <span class="title class_">Printer</span>());</span><br><span class="line">		</span><br><span class="line"><span class="comment">//3. 创建了接口的匿名实现类的非匿名对象</span></span><br><span class="line"><span class="type">USB</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;手机开始工作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;手机结束工作&quot;</span>);</span><br><span class="line">	&#125;			</span><br><span class="line">&#125;;</span><br><span class="line">com.transferData(phone);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"><span class="comment">//4. 创建了接口的匿名实现类的匿名对象		</span></span><br><span class="line">com.transferData(<span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;mp3开始工作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;mp3结束工作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>接口 总结：</strong></p>
<ol>
<li><p>接口使用interface来定义</p>
</li>
<li><p>Java中，接口和类是并列的两个结构</p>
</li>
<li><p>如何定义接口：定义接口中的成员</p>
</li>
</ol>
<ul>
<li><p>JDK7及以前：只能定义全局常量和抽象方法</p>
<ul>
<li><p>全局常量：public static final的</p>
</li>
<li><p>抽象方法：public abstract的</p>
<p>（上述的修饰符都可以省略不写，因为接口会默认使用这些修饰符）</p>
</li>
</ul>
</li>
<li><p>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）</p>
</li>
</ul>
<ol start="4">
<li><p>接口中不能定义构造器的！意味着接口不可以实例化</p>
</li>
<li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p>
</li>
</ol>
<ul>
<li><p><strong>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</strong></p>
</li>
<li><p><strong>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</strong></p>
</li>
</ul>
<ol start="6">
<li>Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性</li>
</ol>
<ul>
<li>格式：class AA extends BB implements CC,DD,EE</li>
</ul>
<ol start="7">
<li>接口与接口之间可以继承，而且可以多继承</li>
</ol>
<blockquote>
<p>接口的具体使用，体现多态性</p>
<p>接口，实际上可以看做是一种规范</p>
</blockquote>
<blockquote>
<p>类实现了接口之后，要想实例化一个类，则必须将接口中的所有抽象方法都实现才行，否则应当仍然是一个抽象类，不能实例化对象</p>
</blockquote>
<h3 id="6-2-代理模式（Proxy）"><a href="#6-2-代理模式（Proxy）" class="headerlink" title="6.2 代理模式（Proxy）"></a>6.2 代理模式（Proxy）</h3><p><strong>概述：</strong></p>
<p>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其 他对象提供一种代理以控制对这个对象的访问。</p>
<hr>
<p><strong>应用场景：</strong></p>
<ul>
<li><p>安全代理：屏蔽对真实角色的直接访问。</p>
</li>
<li><p>远程代理：通过代理类处理远程方法调用（RMI）</p>
</li>
<li><p>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</p>
<p>（比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有 100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理 模式，当需要查看图片时，用proxy来进行大图片的打开。)</p>
</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>静态代理（静态定义代理类）</li>
<li>动态代理（动态生成代理类）：JDK自带的动态代理，需要反射等知识</li>
</ul>
<h3 id="6-3-接口和抽象类之间的对比"><a href="#6-3-接口和抽象类之间的对比" class="headerlink" title="6.3 接口和抽象类之间的对比"></a>6.3 接口和抽象类之间的对比</h3><table>
<thead>
<tr>
<th align="center">No.</th>
<th align="center">区别点</th>
<th align="left">抽象类</th>
<th align="left">接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">定义</td>
<td align="left">包含抽象方法的类</td>
<td align="left">主要是抽象方法和全局常量的集合</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">组成</td>
<td align="left">构造方法、抽象方法、普通方法、  常量、变量</td>
<td align="left">常量、抽象方法、(jdk8.0:默认方法、静态方法)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">使用</td>
<td align="left">子类继承抽象类(extends)</td>
<td align="left">子类实现接口(implements)</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">关系</td>
<td align="left">抽象类可以实现多个接口</td>
<td align="left">接口不能继承抽象类，但允许继承多个接口</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">常见设计模式</td>
<td align="left">模板方法</td>
<td align="left">简单工厂、工厂方法、代理模式</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">对象</td>
<td align="left">都通过对象的多态性产生实例化对象</td>
<td align="left">（同左）</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">局限</td>
<td align="left">抽象类有单继承的局限</td>
<td align="left">接口没有此局限</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">实际</td>
<td align="left">作为一个模板</td>
<td align="left">是作为一个标准或是表示一种能力</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">选择</td>
<td align="left">如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限</td>
<td align="left">（同左）</td>
</tr>
</tbody></table>
<p>在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。</p>
<h3 id="6-4-Java8中针对接口的改进"><a href="#6-4-Java8中针对接口的改进" class="headerlink" title="6.4 Java8中针对接口的改进"></a>6.4 Java8中针对接口的改进</h3><p>Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</p>
<hr>
<p><strong>静态方法：</strong>使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行 其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中 找到像Collection&#x2F;Collections或者Path&#x2F;Paths这样成对的接口和类。</p>
<p><strong>默认方法</strong>：默认方法使用 default 关键字修饰。可以通过实现类对象来调用。 我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。 比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认 方法。</p>
<hr>
<p><strong>接口中的默认方法</strong></p>
<ul>
<li>若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同 参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接 口时，会出现：<strong>接口冲突</strong>。<ul>
<li>解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。</li>
</ul>
</li>
<li>若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非 抽象方法，则不会出现冲突问题。因为此时遵守：<strong>类优先原则</strong>。接口中具有 相同名称和参数的默认方法会被忽略。</li>
</ul>
<hr>
<p><strong>java8 新特性总结：</strong></p>
<ul>
<li><strong>接口中定义的静态方法，只能通过接口来调用。</strong></li>
<li>通过实现类的对象，可以调用接口中的默认方法。如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</li>
<li>如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则</li>
<li>如果实现类实现了多个接口，而这多个接口中定义了<strong>同名同参数的默认方法</strong>，那么在实现类没有重写此方法的情况下，报错–&gt;接口冲突。这就需要我们<strong>必须在实现类中重写此方法</strong></li>
<li>如何在子类(或实现类)的方法中调用父类、接口中被重写的方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">method();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用的是父类中声明的</span></span><br><span class="line"><span class="built_in">super</span>.method();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用接口中的默认方法</span></span><br><span class="line"><span class="comment">//如下情景是两个接口中都定义了method()默认方法，</span></span><br><span class="line"><span class="comment">//则可以通过“接口.super.默认方法”的形式来调用</span></span><br><span class="line">Interface1.<span class="built_in">super</span>.method();</span><br><span class="line">Interface2.<span class="built_in">super</span>.method();</span><br><span class="line"></span><br><span class="line"><span class="comment">//补充：直接通过“接口.全局变量”的方式访问接口中的全局变量</span></span><br></pre></td></tr></table></figure>



<h2 id="7-内部类"><a href="#7-内部类" class="headerlink" title="7. 内部类"></a>7. 内部类</h2><ul>
<li><p>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内 部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使 用内部类。</p>
</li>
<li><p>在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者 称为外部类。</p>
</li>
<li><p>Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完 整的名称。</p>
<ul>
<li>Inner class的名字不能与包含它的外部类类名相同；</li>
</ul>
</li>
<li><p>分类： </p>
<ul>
<li><p>成员内部类（static成员内部类和非static成员内部类）</p>
</li>
<li><p>局部内部类（不谈修饰符）、匿名内部类</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>成员内部类作为类的成员的角色：</p>
<ul>
<li><p>和外部类不同，Inner class还可以声明为<strong>private</strong>或<strong>protected</strong>；</p>
</li>
<li><p>可以调用外部类的结构</p>
</li>
<li><p>Inner class 可以声明为<strong>static</strong>的，但此时就不能再使用外层类的非<strong>static</strong>的成员变量；</p>
</li>
</ul>
</li>
<li><p>成员内部类作为类的角色：</p>
<ul>
<li><p>可以在内部定义属性、方法、构造器等结构</p>
</li>
<li><p>可以声明为<strong>abstract</strong>类 ，因此可以被其它的内部类继承</p>
</li>
<li><p>可以声明为<strong>final</strong>的</p>
</li>
<li><p>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>【注意】</p>
<ol>
<li><p>非<strong>static</strong>的成员内部类中的成员不能声明为<strong>static</strong>的，只有在外部类或<strong>static</strong>的成员内部类中才可声明<strong>static</strong>成员。</p>
</li>
<li><p>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</p>
</li>
<li><p>成员内部类可以直接使用外部类的所有成员，包括私有的数据</p>
</li>
<li><p>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</p>
</li>
</ol>
<h3 id="7-1-局部内部类"><a href="#7-1-局部内部类" class="headerlink" title="7.1 局部内部类"></a>7.1 局部内部类</h3><p><strong>如何声明局部内部类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class 外部类&#123;  </span><br><span class="line">    方法()&#123;</span><br><span class="line">		class 局部内部类&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		class 局部内部类&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>如何使用局部内部类</strong></p>
<p>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类</p>
<p>但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类 的父类或父接口类型</p>
<hr>
<p><strong>局部内部类的特点</strong></p>
<ul>
<li>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但 是前面冠以外部类的类名和$符号，以及数字编号。</li>
<li>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方 都不能使用该类。</li>
<li>局部内部类可以使用外部类的成员，包括私有的。</li>
<li>局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局 部变量的声明周期不同所致。</li>
<li>局部内部类和局部变量地位类似，不能使用public,protected,缺省,private</li>
<li>局部内部类不能使用static修饰，因此也不能包含静态成员</li>
</ul>
<h3 id="7-2-匿名内部类"><a href="#7-2-匿名内部类" class="headerlink" title="7.2 匿名内部类"></a>7.2 匿名内部类</h3><p>匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一 个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。</p>
<hr>
<p><strong>格式：</strong></p>
<p>new 父类构造器（实参列表）|实现接口(){</p>
<p>​		&#x2F;&#x2F;匿名内部类的类体部分</p>
<p>}</p>
<hr>
<p>匿名内部类的<strong>特点</strong></p>
<p>匿名内部类必须继承父类或实现接口</p>
<p>匿名内部类只能有一个对象</p>
<p>匿名内部类对象只能使用多态形式引用</p>
<hr>
<p><strong>内部类 总结：</strong></p>
<ol>
<li><p>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</p>
</li>
<li><p>内部类的分类：成员内部类（静态、非静态）  vs 局部内部类(方法内、代码块内、构造器内)</p>
</li>
<li><p>成员内部类：</p>
</li>
</ol>
<ul>
<li><p>一方面，作为外部类的成员：</p>
<ul>
<li><p>调用外部类的结构</p>
</li>
<li><p>可以被static修饰</p>
</li>
<li><p>可以被4种不同的权限修饰</p>
</li>
</ul>
</li>
<li><p>另一方面，作为一个类：</p>
<ul>
<li><p>类内可以定义属性、方法、构造器等</p>
</li>
<li><p>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</p>
</li>
<li><p>可以被abstract修饰</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>如何实例化成员内部类的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person类内部有Dog和Bird内部类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Dog实例(静态的成员内部类):</span></span><br><span class="line">Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line">dog.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建非静态Bird实例(非静态的成员内部类):</span></span><br><span class="line">Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Bird();<span class="comment">//错误的</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">bird.sing();	</span><br><span class="line">bird.display(<span class="string">&quot;黄鹂&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>如何在成员内部类中区分调用外部类的结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String name)</span>&#123;</span><br><span class="line">			System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">			System.out.println(<span class="built_in">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">			System.out.println(Person.<span class="built_in">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>面向对象 总结：</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221212173306975.png" alt="image-20221212173306975"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221212173445677.png" alt="image-20221212173445677"></p>
<h1 id="第六章-gt-gt-gt-异常处理"><a href="#第六章-gt-gt-gt-异常处理" class="headerlink" title="第六章&gt;&gt;&gt;异常处理"></a>第六章&gt;&gt;&gt;异常处理</h1><h2 id="1-异常处理概述与异常体系结构"><a href="#1-异常处理概述与异常体系结构" class="headerlink" title="1. 异常处理概述与异常体系结构"></a>1. 异常处理概述与异常体系结构</h2><p>异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。</p>
<p>(开发过程中的语法错误和逻辑错误不是异常)</p>
<hr>
<p>Java程序在执行过程中所发生的异常事件可分为两类：</p>
<ol>
<li><p><strong>Error</strong>：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源 耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性 的代码进行处理。</p>
</li>
<li><p><strong>Exception:</strong> 其它因编程错误或偶然的外在因素导致的一般性问题，可以使 用针对性的代码进行处理。例如：</p>
<ul>
<li><p>空指针访问</p>
</li>
<li><p>试图读取不存在的文件</p>
</li>
<li><p>网络连接中断</p>
</li>
<li><p>数组角标越界</p>
</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li><p>对于这些错误，一般有两种解决方法：.</p>
<p>一是遇到错误就终止程序 的运行。另一种方法是由程序员在编写程序时，就考虑到错误的 检测、错误消息的提示，以及错误的处理。</p>
</li>
<li><p>捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。</p>
<p>比如：除数为0，数组下标越界等</p>
<p>分类：编译时异常和运行时异常</p>
</li>
</ol>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221212174116060.png" alt="image-20221212174116060"></p>
<ul>
<li>蓝色：非受检(unchecked)异常 </li>
<li>红色：受检(checked)异常</li>
</ul>
<hr>
<p>① 运行时异常</p>
<ul>
<li><p>是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序 员应该积极避免其出现的异常。<strong>java.lang.RuntimeException</strong>类及它的子 类都是运行时异常。</p>
</li>
<li><p>对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对 程序的可读性和运行效率产生影响。</p>
</li>
</ul>
<p>② 编译时异常</p>
<ul>
<li><p>是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一 般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。</p>
</li>
<li><p>对于这类异常，如果程序不处理，可能会带来意想不到的结果。</p>
</li>
</ul>
<h2 id="2-常见异常"><a href="#2-常见异常" class="headerlink" title="2. 常见异常"></a>2. 常见异常</h2><ul>
<li><p><code>java.lang.RuntimeException</code></p>
<ul>
<li><p><code>CassCastException</code></p>
</li>
<li><p><code>ArrayIndexOutOfBoundsException（数组角标越界）</code></p>
</li>
<li><p><code>NullPointerException（空指针）</code></p>
</li>
<li><p><code>ArithmeticException</code></p>
</li>
<li><p><code>NumberFormatException</code></p>
</li>
<li><p><code>InputMismatchException</code></p>
</li>
<li><p><code>......</code></p>
</li>
</ul>
</li>
<li><p><code>java.io.IOExeption</code></p>
<ul>
<li><p><code>FieNotFoundException</code></p>
</li>
<li><p><code>EOFException</code></p>
</li>
</ul>
</li>
<li><p><code>java.lang.ClassNotFoundException</code></p>
</li>
<li><p><code>java.lang.InterruptedException</code></p>
</li>
<li><p><code>java.io.FileNotFoundException</code></p>
</li>
<li><p><code>java.sql.SQException</code></p>
</li>
</ul>
<h2 id="3-try-catch-finally"><a href="#3-try-catch-finally" class="headerlink" title="3. try-catch-finally"></a>3. try-catch-finally</h2><ul>
<li><p>Java提供的是异常处理的<strong>抓抛模型</strong>。</p>
</li>
<li><p>Java程序的执行过程中如出现异常，会生成一个<strong>异常类对象</strong>， 该异常对象将被提交给Java运行时系统，这个过程称为<strong>抛出 (throw)异常</strong>。</p>
</li>
<li><p>异常对象的生成</p>
<ul>
<li>由虚拟机<strong>自动生成</strong>：程序运行过程中，虚拟机检测到程序发生了问题，如果在当 前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例 对象并抛出——自动抛出</li>
<li>由开发人员<strong>手动创建</strong>：Exception exception &#x3D; new ClassCastException();——创 建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样</li>
</ul>
</li>
</ul>
<hr>
<p><strong>异常的抛出机制</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221212175408649.png" alt="image-20221212175408649"></p>
<ul>
<li>如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。 这一过程称为捕获(catch)异常。</li>
<li>如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。</li>
<li>程序员通常只能处理Exception，而对Error无能为力。</li>
</ul>
<hr>
<p>异常处理是通过try-catch-finally语句实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	...... <span class="comment">//可能产生异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName1 e )&#123;</span><br><span class="line">	...... <span class="comment">//当产生ExceptionName1型异常时的处置措施</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName2 e )&#123;</span><br><span class="line">	...... <span class="comment">//当产生ExceptionName2型异常时的处置措施</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">	...... <span class="comment">//无论是否发生异常，都无条件执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>① <strong>try</strong></p>
<p>捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。</p>
<p>② <strong>catch</strong> (Exceptiontype e)</p>
<p>在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随 一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p>
<p>如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。</p>
<p>③ <strong>finally</strong></p>
<p>捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。</p>
<p>不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，  finally块中的语句都会被执行。</p>
<p>finally语句和catch语句是任选的</p>
<hr>
<p><strong>捕获异常的有关信息：</strong></p>
<p>与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。</p>
<ul>
<li>getMessage() 获取异常信息，返回字符串</li>
<li>printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221212175902373.png" alt="image-20221212175902373"></p>
<hr>
<p><strong>try-catch-finally 总结：</strong></p>
<ol>
<li><p>finally是可选的。</p>
</li>
<li><p>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</p>
</li>
<li><p>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况）。继续执行其后的代码</p>
</li>
<li><p>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</p>
</li>
<li><p>常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()</p>
</li>
<li><p>在try结构中声明的变量，再出了try结构以后，就不能再被调用</p>
</li>
<li><p>try-catch-finally结构可以嵌套</p>
</li>
</ol>
<p>体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally<strong>将一个编译时可能出现的异常，延迟到运行时出现</strong>。</p>
<p>体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。</p>
<h2 id="4-throws"><a href="#4-throws" class="headerlink" title="4. throws"></a>4. throws</h2><p>声明抛出异常是Java中处理异常的第二种方式</p>
<ul>
<li><p>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这 种异常，则此方法应<strong>显示地</strong>声明抛出异常，表明该方法将不对这些异常进行处理， 而由该方法的<strong>调用者</strong>负责处理。</p>
</li>
<li><p>在方法声明中用<strong>throws</strong>语句可以声明抛出异常的列表，throws后面的异常类型可 以是方法中产生的异常类型，也可以是它的父类。</p>
</li>
</ul>
<hr>
<p><strong>声明抛出异常举例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String file)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="comment">// 读文件的操作可能产生FileNotFoundException类型的异常</span></span><br><span class="line">	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221212180630845.png" alt="image-20221212180630845"></p>
<hr>
<p><strong>重写方法声明抛出异常的原则</strong></p>
<p>重写方法不能抛出比被重写方法范围更大的异常类型。在多态的情况下， 对methodA()方法的调用-异常的捕获按父类声明的异常处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		……</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B1</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">		……</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B2</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">//报错</span></span><br><span class="line">	……</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>throws 总结：</strong></p>
<ol>
<li><p>“<strong>throws + 异常类型</strong>“写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。<strong>异常代码后续的代码，就不再执行！</strong></p>
</li>
<li><p>体会：</p>
</li>
</ol>
<ul>
<li><p>try-catch-finally：真正的将异常给处理掉了</p>
</li>
<li><p>throws的方式只是将异常抛给了方法的调用者。  并没有真正将异常处理掉。</p>
</li>
</ul>
<ol start="3">
<li>开发中如何选择使用try-catch-finally 还是使用throws？</li>
</ol>
<ul>
<li><strong>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws</strong>，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。</li>
<li>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。</li>
</ul>
<ol start="4">
<li><p>方法重写的规则之一：</p>
<p><strong>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</strong></p>
</li>
</ol>
<h2 id="5-手动抛出异常"><a href="#5-手动抛出异常" class="headerlink" title="5. 手动抛出异常"></a>5. 手动抛出异常</h2><p>Java异常类对象除在程序执行过程中出现异常时由系统自动生成并 抛出，也可根据需要使用人工创建并抛出。</p>
<ul>
<li>首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运 行环境)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IOException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();  </span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将 会产生语法错误：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;want to throw&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="6-用户自定义异常类"><a href="#6-用户自定义异常类" class="headerlink" title="6. 用户自定义异常类"></a>6. 用户自定义异常类</h2><ul>
<li>一般地，用户自定义异常类都是<strong>RuntimeException</strong>的子类。</li>
<li>自定义异常类通常需要编写几个<strong>重载的构造器</strong>。</li>
<li>自定义异常需要提供<strong>serialVersionUID</strong></li>
<li>自定义的异常通过<strong>throw抛出</strong>。</li>
<li>自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。</li>
</ul>
<hr>
<p>用户自定义异常类MyException，用于描述数据取值范围错误信息。用户 自己的异常类必须继承现有的异常类。</p>
<hr>
<p><strong>异常处理 总结：</strong></p>
<p><strong>异常处理5个关键字</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221212181415208.png" alt="image-20221212181415208"></p>
<hr>
<p><strong>throw和throws的区别：</strong></p>
<ul>
<li>throw表示<strong>抛出</strong>一个异常类的对象，<strong>生成</strong>异常对象的过程，声明在方法体内</li>
<li>throws表示抓住属于异常<strong>处理</strong>的一种方式，声明在方法的声明处</li>
<li>throw是抛出异常，接着throws处理异常</li>
</ul>
<h1 id="第七章-gt-gt-gt-多线程"><a href="#第七章-gt-gt-gt-多线程" class="headerlink" title="第七章&gt;&gt;&gt;多线程"></a>第七章&gt;&gt;&gt;多线程</h1><h2 id="1-基本概念：程序、进程、线程"><a href="#1-基本概念：程序、进程、线程" class="headerlink" title="1. 基本概念：程序、进程、线程"></a>1. 基本概念：程序、进程、线程</h2><p><strong>程序(program)<strong>是为完成特定任务、用某种语言编写的一组指令的集合。即</strong>指一 段静态的代码</strong>，静态对象。</p>
<p><strong>进程(process)<strong>是程序的一次执行过程，或是</strong>正在运行的一个程序</strong>。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期</p>
<ul>
<li>如：运行中的QQ，运行中的MP3播放器</li>
<li>程序是静态的，进程是动态的</li>
<li><strong>进程作为资源分配的单位</strong>，系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
<p>**线程(thread)**，进程可进一步细化为线程，是一个程序内部的一条执行路径。</p>
<ul>
<li>若一个进程同一时间并行执行多个线程，就是支持多线程的</li>
<li>**线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)**，线程切换的开销小</li>
<li>一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间。它们从同一堆中分配对象，可以 访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资 源可能就会带来安全的隐患。</li>
</ul>
<hr>
<p><strong>单核CPU和多核CPU的理解</strong></p>
<ul>
<li><strong>单核CPU</strong>，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。但是因为CPU时间单元特别短，因此感觉不出来。</li>
<li>如果是<strong>多核CPU</strong>的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li>
<li>一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc() 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</li>
</ul>
<p><strong>并行与并发</strong></p>
<ul>
<li><strong>并行</strong>：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</li>
<li><strong>并发</strong>：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</li>
</ul>
<hr>
<p><strong>多线程程序</strong>的优点：</p>
<ol>
<li><p>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</p>
</li>
<li><p>提高计算机系统CPU的利用率</p>
</li>
<li><p>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解修改</p>
</li>
</ol>
<p><strong>何时需要用到多线程？</strong></p>
<ul>
<li>程序需要同时执行两个或多个任务。</li>
<li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</li>
<li>需要一些后台运行的程序时。</li>
</ul>
<hr>
<p><strong>基本概念 注意点：</strong></p>
<ul>
<li>进程可以细化为多个线程</li>
<li>每个线程，用于自己独立的：栈、程序计数器</li>
<li>多个线程共享同一个进程中的结构：方法区、堆</li>
</ul>
<h2 id="2-线程的创建和使用"><a href="#2-线程的创建和使用" class="headerlink" title="2. 线程的创建和使用"></a>2. 线程的创建和使用</h2><blockquote>
<p>下面的程序可以用一条线串起来，所以属于是单线程。</p>
</blockquote>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221216085944458.png" alt="image-20221216085944458"></p>
<hr>
<p><strong>线程的创建和启动</strong></p>
<p>Thread类的特性</p>
<ul>
<li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把<strong>run()方法的主体称为线程体</strong></li>
<li>通过该Thread对象的<strong>start()方法来启动这个线程</strong>，而非直接调用run()</li>
</ul>
<hr>
<p><strong>Thread类构造器</strong></p>
<ul>
<li>**Thread()**：创建新的Thread对象</li>
<li><strong>Thread(String</strong> **threadname)**：创建线程并指定线程实例名</li>
<li>**Thread(Runnable target)**：指定创建线程的目标对象，它实现了Runnable接口中的run方法</li>
<li><strong>Thread(Runnable</strong> <strong>target,</strong> <strong>String</strong> **name)**：创建新的Thread对象</li>
</ul>
<h3 id="2-1-API中创建线程的两种方式"><a href="#2-1-API中创建线程的两种方式" class="headerlink" title="2.1 API中创建线程的两种方式"></a>2.1 API中创建线程的两种方式</h3><p>JDK1.5之前创建新执行线程有两种方法：</p>
<ul>
<li>继承Thread类的方式</li>
<li>实现Runnable接口的方式</li>
</ul>
<h4 id="2-1-1-继承Thread类"><a href="#2-1-1-继承Thread类" class="headerlink" title="2.1.1 继承Thread类"></a>2.1.1 继承Thread类</h4><ol>
<li>定义子类继承Thread类。</li>
<li>子类中重写Thread类中的run方法。</li>
<li>创建Thread子类对象，即创建了线程对象。</li>
<li>调用线程对象start方法：启动线程，调用run方法。</li>
</ol>
<hr>
<p><strong>mt</strong>子线程的创建和启动过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    pubic <span class="title function_">MyThread</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	pubic <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System,out.printIn(<span class="string">&quot;子线程:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">pubic <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//2.启动线程，并调用当前线程的run()方法。</span></span><br><span class="line">        mt.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意点：</strong></p>
<ol>
<li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。</li>
<li>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</li>
<li>想要启动多线程，必须调用start()方法。</li>
<li>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常<code>IegaThreadStateException</code>。</li>
<li>要想调用start()方法启动新的线程，则需要创建新的线程对象</li>
</ol>
<h4 id="2-1-2-实现Runnable接口"><a href="#2-1-2-实现Runnable接口" class="headerlink" title="2.1.2 实现Runnable接口"></a>2.1.2 实现Runnable接口</h4><ul>
<li>定义子类，实现Runnable接口。</li>
<li>子类中重写Runnable接口中的run方法。</li>
<li>通过Thread类<strong>含参构造器（Thread(Runnable target)）</strong>创建线程对象。</li>
<li>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</li>
<li>调用Thread类的start()方法：开启线程，调用Runnable子类接口的run()方法。</li>
</ul>
<hr>
<p><strong>继承方式和实现方式的联系与区别</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pubic <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<ul>
<li>继承Thread：线程代码存放在Thread子类run方法中。</li>
<li>实现Runnable：线程代码存在接口的实现类的run方法。</li>
</ul>
<p><strong>实现方式的好处</strong></p>
<ul>
<li>避免了单继承的局限性</li>
<li>多个线程可以共享同一个接口实现类的对象，非常适合<strong>多个相同线程来处理同一份资源</strong>。</li>
</ul>
<h3 id="2-2-Thread类的有关方法"><a href="#2-2-Thread类的有关方法" class="headerlink" title="2.2 Thread类的有关方法"></a>2.2 Thread类的有关方法</h3><p><code>void start()</code>: 启动线程，并执行对象的run()方法</p>
<p><code>run()</code>: 线程在被调度时执行的操作</p>
<p><code>String getName():</code> 返回线程的名称</p>
<p><code>void setName(String name)</code>:设置该线程名称</p>
<p><code>static Thread currentThread()</code>: 返回当前线程对象。</p>
<ul>
<li>在Thread子类中就是this，通常用于<strong>主线程</strong>和<strong>Runnable实现类</strong></li>
</ul>
<p><code>static void yield()</code>：线程让步</p>
<ul>
<li>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</li>
<li>若队列中没有同优先级的线程，忽略此方法</li>
</ul>
<p><code>join()</code> ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止</p>
<ul>
<li>低优先级的线程也可以获得执行</li>
</ul>
<p><code>static void sleep(long millis)</code>：(指定时间:毫秒)</p>
<ul>
<li>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后 重排队。</li>
<li>抛出InterruptedException异常</li>
</ul>
<p><code>stop():</code> 强制线程生命期结束，不推荐使用</p>
<p><code>boolean isAlive()</code>：返回boolean，判断线程是否还活着</p>
<hr>
<p><strong>线程的调度</strong></p>
<p>① 调度策略</p>
<ul>
<li>时间片</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221216092044474.png" alt="image-20221216092044474"></p>
<ul>
<li>抢占式：高优先级的线程抢占CPU</li>
</ul>
<p>② <strong>Java</strong>的调度方法</p>
<ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
<hr>
<p><strong>线程的优先级</strong></p>
<p>① 线程的优先级等级</p>
<ul>
<li><strong>MAX_PRIORITY</strong>：<strong>10</strong></li>
<li><strong>MIN</strong> <strong>_PRIORITY</strong>：<strong>1</strong></li>
<li><strong>NORM_PRIORITY</strong>：<strong>5</strong> –&gt; 默认优先级</li>
</ul>
<p>② 涉及的方法</p>
<ul>
<li><strong>getPriority()</strong> ：返回线程优先值</li>
<li><strong>setPriority(int</strong> <strong>newPriority)</strong> ：改变线程的优先级</li>
</ul>
<p>③ 说明</p>
<ul>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</li>
</ul>
<p>（高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程<strong>高概率的情况下</strong>被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。）</p>
<hr>
<p><strong>补充：线程的分类</strong></p>
<p>Java中的线程分为两类：一种是守护线程，一种是用户线程。</p>
<ul>
<li>它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。</li>
<li>守护线程是用来服务用户线程的，通过在start()方法前调用<strong>thread.setDaemon(true</strong>)可以把一个用户线程变成一个守护线程。</li>
<li>Java垃圾回收就是一个典型的守护线程。</li>
<li>若JVM中都是守护线程，当前JVM将退出。</li>
<li>形象理解：兔死狗烹，鸟尽弓藏</li>
</ul>
<hr>
<p><strong>线程的创建 总结：</strong></p>
<p>一、<strong>注意点：</strong></p>
<ul>
<li>我们不能通过直接调用run()的方式启动线程。</li>
<li>如需再启用一个线程，我们需要重新创建一个线程的对象</li>
</ul>
<p>二、<strong>多线程的创建</strong></p>
<p>① 方式一：<strong>继承于Thread类</strong></p>
<ol>
<li><p>创建一个继承于Thread类的子类</p>
</li>
<li><p>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</p>
</li>
<li><p>创建Thread类的子类的对象</p>
</li>
<li><p>通过此对象调用start()</p>
<ul>
<li><p>启动当前线程</p>
</li>
<li><p>调用当前线程的run()方法</p>
</li>
</ul>
</li>
</ol>
<p>② 方式二：<strong>实现Runnable接口</strong></p>
<ol>
<li><p>创建一个实现了Runnable接口的类</p>
</li>
<li><p>实现类去实现Runnable中的抽象方法：run()</p>
</li>
<li><p>创建实现类的对象</p>
</li>
<li><p>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</p>
</li>
<li><p>通过Thread类的对象调用start()</p>
<ul>
<li><p>启动线程</p>
</li>
<li><p>调用当前线程的run()–&gt;调用了Runnable类的target的run()（参考Thread类的源码）</p>
</li>
</ul>
</li>
</ol>
<p>③ <strong>比较创建线程的两种方式。</strong></p>
<ol>
<li><p>开发中优先选择：实现Runnable接口的方式</p>
</li>
<li><p>原因：</p>
<ul>
<li><p><strong>实现的方式没有类的单继承性的局限性</strong>，即继承的方式只能继承Thread类则不能继承其他类，而实现的方式还能实现其他接口</p>
</li>
<li><p>实现的方式更适合来处理多个线程有<strong>共享数据</strong>的情况</p>
</li>
</ul>
</li>
<li><p>联系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>相同点：</p>
<ul>
<li><p>两种方式都需要重写run()，将线程要执行的逻辑声明在run()中</p>
</li>
<li><p>目前两种方式，要想启动线程，都要调用Thread类中的start()方法</p>
</li>
</ul>
</li>
</ol>
<h2 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3. 线程的生命周期"></a>3. 线程的生命周期</h2><p><strong>JDK</strong>中用<strong>Thread.State</strong>类定义了线程的几种状态</p>
<p>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类 及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五 种状态：</p>
<ul>
<li><strong>新建</strong>： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li><strong>就绪</strong>：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</li>
<li><strong>运行</strong>：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线 程的操作和功能</li>
<li><strong>阻塞</strong>：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</li>
<li><strong>死亡</strong>：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221216093143482.png" alt="image-20221216093143482"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221216093208830.png" alt="image-20221216093208830"></p>
<h2 id="4-线程的同步"><a href="#4-线程的同步" class="headerlink" title="4. 线程的同步"></a>4. 线程的同步</h2><p><strong>问题的提出</strong></p>
<ul>
<li>多个线程执行的不确定性引起执行结果的不稳定</li>
<li>多个线程对数据的<strong>共享</strong>，会造成操作的不完整性，会破坏数据。</li>
</ul>
<blockquote>
<p>前提：多个线程有需要共享的数据</p>
</blockquote>
<hr>
<ol>
<li><p>多线程出现了安全问题</p>
</li>
<li><p>问题的原因：</p>
<p>当<strong>多条语句在操作同一个线程共享数据</strong>时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行，导致共享数据的错误。</p>
</li>
<li><p>解决办法：</p>
<p>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。</p>
</li>
</ol>
<hr>
<h3 id="4-1-Synchronized的使用方法"><a href="#4-1-Synchronized的使用方法" class="headerlink" title="4.1 Synchronized的使用方法"></a>4.1 Synchronized的使用方法</h3><p><strong>Java</strong>对于多线程的安全问题提供了专业的解决方式：<strong>同步机制</strong></p>
<h4 id="4-1-1-同步代码块"><a href="#4-1-1-同步代码块" class="headerlink" title="4.1.1 同步代码块"></a>4.1.1 同步代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象)&#123;</span><br><span class="line">	<span class="comment">// 需要被同步的代码；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-同步方法"><a href="#4-1-2-同步方法" class="headerlink" title="4.1.2 同步方法"></a>4.1.2 同步方法</h4><p><strong>synchronized</strong>还可以放在方法声明中，表示整个方法为同步方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pubic <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(String name)</span>&#123;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>同步机制中的锁</strong></p>
<ul>
<li>同步锁机制</li>
</ul>
<p>在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防 止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法 就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须 锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁 之时，另一个任务就可以锁定并使用它了。</p>
<ul>
<li><strong>synchronized</strong>的锁是什么？</li>
</ul>
<p>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（同步监视器）。</p>
<p>同步方法的锁：静态方法（类名.class）、非静态方法（this）</p>
<p>同步代码块：自己指定，很多时候也是指定为this或类名.class</p>
<ul>
<li><strong>注意</strong>：</li>
</ul>
<p>必须<strong>确保使用同一个资源的多个线程共用一把锁</strong>，这个非常重要，否则就无法保证共享资源的安全</p>
<p>一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方 法共用同一把锁（this），同步代码块（指定需谨慎）</p>
<hr>
<p><strong>同步的范围</strong></p>
<ol>
<li><p>如何找问题，即代码是否存在线程安全？（非常重要）</p>
<ul>
<li><p>明确哪些代码是多线程运行的代码</p>
</li>
<li><p>明确多个线程是否有共享数据</p>
</li>
<li><p>明确多线程运行代码中是否有多条语句操作共享数据</p>
</li>
</ul>
</li>
<li><p>如何解决呢？（非常重要）</p>
<ul>
<li><p>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其 他线程不可以参与执行。</p>
</li>
<li><p>即所有操作共享数据的这些语句都要放在同步范围中</p>
</li>
</ul>
</li>
<li><p>切记：</p>
<ul>
<li><p>范围太小：没锁住所有有安全问题的代码</p>
</li>
<li><p>范围太大：没发挥多线程的功能。</p>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>释放锁操作</strong></p>
<ul>
<li>当前线程的同步方法、同步代码块执行结束。</li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、 该方法的继续执行。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线 程暂停，并释放锁。</li>
</ul>
<hr>
<p><strong>不会释放锁的操作</strong></p>
<ul>
<li><p>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行</p>
</li>
<li><p>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。</p>
<ul>
<li>应尽量避免使用suspend()和resume()来控制线程</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-3-线程的死锁问题"><a href="#4-1-3-线程的死锁问题" class="headerlink" title="4.1.3 线程的死锁问题"></a>4.1.3 线程的死锁问题</h4><ul>
<li><p>死锁</p>
<ul>
<li><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</p>
</li>
<li><p>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于 阻塞状态，无法继续</p>
</li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li><p>专门的算法、原则</p>
</li>
<li><p>尽量减少同步资源的定义</p>
</li>
<li><p>尽量避免嵌套同步</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-Lock-锁"><a href="#4-2-Lock-锁" class="headerlink" title="4.2 Lock(锁)"></a>4.2 Lock(锁)</h3><ul>
<li>从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li>
<li><code>java.util.concurrent.locks.Lock</code>接口是控制多个线程对共享资源进行访问的 工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li>
<li><code>ReentrantLock</code> 类实现了 Lock ，它拥有与 synchronized 相同的并发性和 内存语义，在实现线程安全的控制中，比较常用的是<code>ReentrantLock</code>，可以 显式加锁、释放锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenTrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//保证线程安全的代码;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果同步代码有异常，要将unlock()写入finally语句块</p>
</blockquote>
<hr>
<p><strong>synchronized</strong> <strong>与</strong> <strong>Lock</strong> <strong>的对比</strong></p>
<ol>
<li><p>Lock是显式锁（<strong>手动开启和关闭锁</strong>，别忘记关闭锁），synchronized是隐式锁，<strong>出了作用域自动释放</strong></p>
</li>
<li><p>Lock只有代码块锁，synchronized有代码块锁和方法锁</p>
</li>
<li><p>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</p>
</li>
</ol>
<p><strong>优先使用顺序：</strong></p>
<p>Lock –&gt; 同步代码块（已经进入了方法体，分配了相应资源） –&gt; 同步方法（在方法体之外）</p>
<hr>
<p><strong>线程同步 总结</strong></p>
<p><strong>一、在Java中，我们通过同步机制，来解决线程的安全问题。</strong> </p>
<p><strong>① 方式一：同步代码块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">	<span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><p>操作共享数据的代码，即为需要被同步的代码。  –&gt;不能包含代码多了，也不能包含代码少了。</p>
</li>
<li><p>共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。</p>
</li>
<li><p>同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。</p>
<p>要求：多个线程必须要共用同一把锁。</p>
</li>
<li><p>补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</p>
</li>
</ul>
<blockquote>
<p>① 通过<strong>继承Thread的方式</strong>则可以使用当前类对象作为同步监视器，而不能使用this关键字，因为使用继承Thread类的方式要创建多个子类对象。</p>
<p>② 通过<strong>实现Runnable接口</strong>的方式则可以使用this关键字指明当前类对作为同步监视器，因为使用实现Runnable接口的方式只需要创建一个接口实现类对象。</p>
</blockquote>
<p><strong>② 方式二：同步方法</strong></p>
<p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p>
<blockquote>
<p>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</p>
<p>非静态的同步方法，同步监视器是<strong>this</strong>；静态的同步方法，同步监视器是<strong>当前类本身（类名.class）</strong></p>
</blockquote>
<blockquote>
<p>① 通过<strong>继承Thread的方式</strong>，此时方法中默认的同步监视器为 <strong>类名.class</strong>，方法需要声明为静态的，否则默认的同步监视器会变为每个子类线程实例化对象</p>
<p>② 通过<strong>实现Runnable接口</strong>的方式，此时方法中默认的同步监视器为 <strong>this</strong></p>
</blockquote>
<p><strong>二、同步方式的好处与局限性</strong></p>
<p>同步的方式，解决了线程的安全问题。—好处</p>
<p>操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 —局限性</p>
<p><strong>三、死锁问题</strong></p>
<p><strong>情景：嵌套同步锁</strong></p>
<p><strong>线程1</strong> 在拿着 <strong>锁1</strong> 同步监视器的时候，刚好 <strong>线程2</strong> 也握住了 <strong>锁2</strong> 同步监视器，由于后续代码需要使用到 <strong>锁2</strong>；<strong>线程2</strong> 同理；</p>
<p>此时 <strong>线程1</strong> 还得等待 <strong>线程2</strong> 执行中的 <strong>锁2</strong> 解开之后才能执行后续的代码；<strong>线程2</strong> 还得等待 <strong>线程1</strong> 执行中的 <strong>锁1</strong> 解开之后才能执行后续的代码。最终两个线程僵持住，都在等对方的锁解开，因此出现死锁现象。</p>
<p><strong>四、Lock锁</strong></p>
<ol>
<li><p>实例化 ReentrantLock–&gt;Lock接口的实现类</p>
</li>
<li><p>调用锁定方法 lock()</p>
</li>
<li><p>调用解锁方法 unlock()</p>
</li>
</ol>
<h2 id="5-线程的通信"><a href="#5-线程的通信" class="headerlink" title="5. 线程的通信"></a>5. 线程的通信</h2><ul>
<li><p>wait() 与 notify() 和 notifyAll()</p>
<ul>
<li><p>**wait()**：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当 前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有 权后才能继续执行。</p>
</li>
<li><p>**notify()**：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</p>
</li>
<li><p><strong>notifyAll</strong> **()**：唤醒正在排队等待资源的所有线程结束等待.</p>
</li>
</ul>
</li>
<li><p>这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报<code>java.lang.IllegalMonitorStateException</code>异常。</p>
</li>
<li><p>因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁， 因此这三个方法只能在Object类中声明。</p>
</li>
</ul>
<h3 id="5-1-wait"><a href="#5-1-wait" class="headerlink" title="5.1 wait()"></a>5.1 wait()</h3><ul>
<li>在当前线程中调用方法： 对象名.wait()</li>
<li>使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify(或notifyAll) 为止。</li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
<li>调用此方法后，当前线程将释放对象监控权 ，然后进入等待</li>
<li>在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</li>
</ul>
<h3 id="5-2-notify-x2F-notifyAll"><a href="#5-2-notify-x2F-notifyAll" class="headerlink" title="5.2 notify()&#x2F;notifyAll()"></a>5.2 notify()&#x2F;notifyAll()</h3><ul>
<li>在当前线程中调用方法： 对象名.notify()</li>
<li>功能：唤醒等待该对象监控权的一个&#x2F;所有线程。</li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
</ul>
<hr>
<p><strong>线程通信 总结</strong></p>
<p><strong>形象理解流程：以两个线程为例</strong></p>
<p>其中一个线程（此处叫线程1）先进同步代码块或者同步方法，拿着同步监视器锁上，此时线程2进不来。线程1执行完代码之后来到执行wait()方法，并且变成阻塞状态，同时释放同步监视器。此时线程2便可以拿到同步监视器，进入同步代码块或者同步方法中，并且执行notify()&#x2F;notifyAll()，然后唤醒处于阻塞状态的线程1。此时线程1无法进入同步结构中，因为线程2还没有执行完同步结构中的代码，等到线程2执行完代码并且执行到wait()释放了同步监视器之后，线程1按照线程2的流程再走一遍，如此反复，就实现了通信交互。</p>
<blockquote>
<p>wait()和notify()&#x2F;notifyAll()三个方法位于同步结构中</p>
</blockquote>
<p>涉及到的三个方法：</p>
<ul>
<li>wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。</li>
<li>notify()：一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。</li>
<li>notifyAll()：一旦执行此方法，就会唤醒所有被wait的线程。</li>
</ul>
<p><strong>说明：wait()，notify()，notifyAll()三个方法</strong></p>
<ol>
<li><p>必须使用<strong>在同步代码块或同步方法中</strong>，不能用在Lock锁的方式中。</p>
</li>
<li><p>三个方法的<strong>调用者必须是同步代码块或同步方法中的同步监视器</strong>。否则，会出现<code>IllegalMonitorStateException</code>异常。</p>
<blockquote>
<p>调用者可以是this或者当前类对象；this可以省略，而显式的对象就不能省略，要在方法前面加上对象名。</p>
</blockquote>
</li>
<li><p>定义在<code>java.lang.Object</code>类中。</p>
</li>
</ol>
<p><strong>面试题：sleep() 和 wait()的异同？</strong></p>
<p>① 相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</p>
<p>② 不同点：</p>
<ul>
<li>两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</li>
<li>调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</li>
<li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</li>
</ul>
<h2 id="6-JDK5-0新增线程创建方式"><a href="#6-JDK5-0新增线程创建方式" class="headerlink" title="6. JDK5.0新增线程创建方式"></a>6. JDK5.0新增线程创建方式</h2><h3 id="6-1-实现Callable接口"><a href="#6-1-实现Callable接口" class="headerlink" title="6.1 实现Callable接口"></a>6.1 实现Callable接口</h3><p><strong>实现Callable和Runnable接口的方式的对比：</strong></p>
<p>与使用Runnable相比， Callable功能更强大些</p>
<ul>
<li>相比run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助FutureTask类，比如获取返回结果</li>
</ul>
<hr>
<p>Future接口</p>
<ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutrueTask是Futrue接口的唯一的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
<h3 id="6-2-使用线程池"><a href="#6-2-使用线程池" class="headerlink" title="6.2 使用线程池"></a>6.2 使用线程池</h3><p><strong>背景</strong>：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大。</p>
<hr>
<p><strong>思路</strong>：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p>
<hr>
<p><strong>好处</strong>：</p>
<ul>
<li><p>提高响应速度（减少了创建新线程的时间）</p>
</li>
<li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p>
</li>
<li><p>便于线程管理</p>
<ul>
<li><p>corePoolSize：核心池的大小</p>
</li>
<li><p>maximumPoolSize：最大线程数</p>
</li>
<li><p>keepAliveTime：线程没有任务时最多保持多长时间后会终止</p>
</li>
<li><p>…</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>线程池相关API</strong></p>
<ul>
<li><p>JDK 5.0起提供了线程池相关API：<code>ExecutorService</code> 和 <code>Executors</code></p>
</li>
<li><p><code>ExecutorService</code>：真正的线程池接口。常见子类<code>ThreadPoolExecutor</code></p>
<ul>
<li><p><code>void execute(Runnable command)</code> ：执行任务&#x2F;命令，没有返回值，一般用来执行Runnable</p>
</li>
<li><p><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：执行任务，有返回值，一般又来执行Callable</p>
</li>
<li><p><code>void shutdown()</code> ：关闭连接池</p>
</li>
</ul>
</li>
<li><p>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p>
<ul>
<li><p><code>Executors.newCachedThreadPool()</code>：创建一个可根据需要创建新线程的线程池</p>
</li>
<li><p><code>Executors.newFixedThreadPool(n)</code>：创建一个可重用固定线程数的线程池</p>
</li>
<li><p><code>Executors.newSingleThreadExecutor()</code> ：创建一个只有一个线程的线程池</p>
</li>
<li><p><code>Executors.newScheduledThreadPool(n)</code>：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>JDK 5.0新增创建多线程方式 总结</strong></p>
<p><strong>一、实现Callable接口</strong></p>
<ol>
<li><p>创建一个实现Callable的实现类（<strong>创建实现类</strong>）</p>
</li>
<li><p><strong>实现call()方法</strong>，将此线程需要执行的操作声明在call()中（相当于run()方法）</p>
</li>
<li><p>创建Callable接口实现类的对象（<strong>创建实现类对象</strong>）</p>
</li>
<li><p>将此Callable接口实现类的对象作为形参传递到FutureTask构造器中，<strong>创建FutureTask的对象</strong>（FutureTask类实现接口RunnableFuture继承自Runnable接口）</p>
</li>
<li><p>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()。【构造器为：Thread(Runnable target)】</p>
</li>
<li><p>（可根据是否需要返回值来进行步骤选择）获取Callable中call()方法的返回值。get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</p>
</li>
</ol>
<p><strong>二、 使用线程池的方式</strong></p>
<ol>
<li><p>提供指定线程数量的线程池</p>
<p>创建线程池对象：<code>ExecutorService service = Executors.newFixedThreadPool(10);</code></p>
<ul>
<li>设置线程池的属性</li>
</ul>
</li>
<li><p>执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</p>
</li>
</ol>
<ul>
<li>调用execute()和submit()，前者适用于实现Runnable接口的方式，后者均可</li>
</ul>
<ol start="3">
<li><p>关闭连接池</p>
<p><code>线程池对象名.shutdown();</code></p>
</li>
</ol>
<h1 id="第八章-gt-gt-gt-常用类"><a href="#第八章-gt-gt-gt-常用类" class="headerlink" title="第八章&gt;&gt;&gt;常用类"></a>第八章&gt;&gt;&gt;常用类</h1><h2 id="1-字符串相关的类"><a href="#1-字符串相关的类" class="headerlink" title="1. 字符串相关的类"></a>1. 字符串相关的类</h2><h3 id="1-1-String类"><a href="#1-1-String类" class="headerlink" title="1.1 String类"></a>1.1 String类</h3><ul>
<li>String类：代表字符串。Java 程序中的所有字符串<strong>字面值</strong>（如 “abc” ）都作为此类的实例实现。</li>
<li>String是一个final类，代表不可变的字符序列。</li>
<li>字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。</li>
<li>String对象的字符内容是存储在一个**字符数组value[]**中的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>String内存解析</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221222113903094.png" alt="image-20221222113903094"></p>
<hr>
<p><strong>String对象的创建</strong></p>
<p>字符串的<strong>字面量赋值的方式</strong>的字面量位于<strong>方法区中的常量池</strong>中</p>
<p>通过<strong>构造器new对象</strong>的方式的对象位于<strong>堆空间</strong>，其中的<strong>字符串参数</strong>也还是位于<strong>方法区中的常量池</strong></p>
<p>如果用过String对象对原来的处于常量池中的字面量进行操作，则需要在常量池中新造一个新字面量对应的对象，不能对原来的字面量对象进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;hello java&quot;</span>;</span><br><span class="line">s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s3 = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">//&quot;hello&quot;仍然处在常量池中，s1的地址值改变，指向在常量池中新造的一个&quot;hello java”。s2、s3的地址值指向原来就存在于常量池中的&quot;hello&quot;,s2和s3共用一个常量池中的&quot;hello&quot;对象</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line"><span class="type">String</span>	<span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line"><span class="type">String</span>	<span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original);</span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line"><span class="type">String</span>	<span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span>	<span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> startIndex,<span class="type">int</span> count);</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221222114229074.png" alt="image-20221222114229074"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221222114420067.png" alt="image-20221222114420067"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221222114624487.png" alt="image-20221222114624487"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221222114750605.png" alt="image-20221222114750605"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221222114849053.png" alt="image-20221222114849053"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221222114928624.png" alt="image-20221222114928624"></p>
<p><strong>结论：</strong></p>
<ul>
<li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</li>
<li>只要其中有一个是变量，结果就在堆中</li>
<li>如果拼接的结果调用intern()方法，返回值就在常量池中</li>
</ul>
<h4 id="1-1-1-String常用方法"><a href="#1-1-1-String常用方法" class="headerlink" title="1.1.1 String常用方法"></a>1.1.1 String常用方法</h4><p><code>int length()</code>：返回字符串的长度： return value.length</p>
<p><code>char charAt(int index)</code>： 返回某索引处的字符return value[index]</p>
<p><code>boolean isEmpty()</code>：判断是否是空字符串：return value.length &#x3D;&#x3D; 0</p>
<p><code>String toLowerCase()</code>：使用默认语言环境，将 String 中的所有字符转换为小写</p>
<p><code>String toUpperCase()</code>：使用默认语言环境，将 String 中的所有字符转换为大写</p>
<p><code>String trim()</code>：返回字符串的副本，忽略前导空白和尾部空白</p>
<p><code>boolean equals(Object obj)</code>：比较字符串的内容是否相同</p>
<p><code>boolean equalsIgnoreCase(String anotherString)</code>：与equals方法类似，忽略大小写</p>
<p><code>String concat(String str)</code>：将指定字符串连接到此字符串的结尾。 等价于用“+”</p>
<p><code>int compareTo(String anotherString)</code>：比较两个字符串的大小</p>
<p><code>String substring(int beginIndex)</code> ： 返回一个新的字符串， 它是此字符串的从beginIndex开始截取到最后的一个子字符串。</p>
<p><code>String substring(int beginIndex, int endIndex)</code> ：返回一个新字符串，它是此字 符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</p>
<hr>
<p><code>boolean endsWith(String suffix)</code>：测试此字符串是否以指定的后缀结束</p>
<p><code>boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开始</p>
<p><code>boolean startsWith(String prefix, int toffset)</code>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</p>
<hr>
<p><code>boolean contains(CharSequence s)</code>：当且仅当此字符串包含指定的 char 值序列时，返回 true</p>
<p><code>int indexOf(String str)</code>：返回指定子字符串在此字符串中第一次出现处的索引</p>
<p><code>int indexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中第一次出 现处的索引，从指定的索引开始</p>
<p><code>int lastIndexOf(String str)</code>：返回指定子字符串在此字符串中最右边出现处的索引</p>
<p><code>int lastIndexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中最后 一次出现处的索引，从指定的索引开始反向搜索</p>
<blockquote>
<p>indexOf和lastIndexOf方法如果未找到都是返回-1</p>
</blockquote>
<hr>
<p>① 替换：</p>
<p><code>String replace(char oldChar, char newChar)</code>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</p>
<p><code>String replace(CharSequence target, CharSequence replacement)</code>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</p>
<p><code>String replaceAll(String regex, String replacement)</code> ： 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</p>
<p><code>String replaceFirst(String regex, String replacement)</code> ： 使用给定的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</p>
<p>② 匹配：</p>
<p><code>boolean matches(String regex)</code>：告知此字符串是否匹配给定的正则表达式。</p>
<p>③ 切片：</p>
<p><code>String[] split(String regex)</code>：根据给定正则表达式的匹配拆分此字符串。</p>
<p><code>String[] split(String regex, int limit)</code>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p>
<h4 id="1-1-2-Stirng与其他数据类型之间的转换"><a href="#1-1-2-Stirng与其他数据类型之间的转换" class="headerlink" title="1.1.2 Stirng与其他数据类型之间的转换"></a>1.1.2 Stirng与其他数据类型之间的转换</h4><p>① <strong>String与字符数组转换</strong></p>
<ul>
<li><p><strong>字符数组 –&gt; 字符串</strong></p>
<ul>
<li>String 类的构造器：<code>String(char[])</code> 和 <strong><code>String(char[]，int offset，int  length)</code></strong> 分别用字符数组中的全部字符和部分字符创建字符串对象。</li>
</ul>
</li>
<li><p><strong>字符串 –&gt; 字符数组</strong></p>
<ul>
<li><p><code>public char[] toCharArray()</code>：将字符串中的全部字符存放在一个字符数组中的方法。</p>
</li>
<li><p><code>public void getChars(int srcBegin, int srcEnd, char[] dst,int dstBegin)</code>：提供了将指定索引范围内的字符串存放到数组中的方法。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>② <strong>String与字节数组转换</strong></p>
<ul>
<li><p><strong>字节数组 –&gt; 字符串</strong></p>
<ul>
<li><p><code>String(byte[])</code>：通过使用平台的默认字符集解码指定的 byte 数组，构 造一个新的 String。</p>
</li>
<li><p><code>String(byte[]，int offset，int length)</code> ：用指定的字节数组的一部分， 即从数组起始位置offset开始取length个字节构造一个字符串对象。</p>
</li>
</ul>
</li>
<li><p><strong>字符串 –&gt; 字节数组</strong></p>
<ul>
<li><p><code>public byte[] getBytes()</code> ：使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。</p>
</li>
<li><p><code>public byte[] getBytes(String charsetName)</code> ：使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>③ <strong>String与基本数据类型转换</strong></p>
<ul>
<li><p><strong>字符串 –&gt; 基本数据类型、包装类</strong></p>
<ul>
<li><p>Integer包装类的<code>public static int parseInt(String s)</code>：可以将由“数字”字 符组成的字符串转换为整型。</p>
</li>
<li><p>类似地,使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。</p>
</li>
</ul>
</li>
<li><p><strong>基本数据类型、包装类 –&gt; 字符串</strong></p>
<ul>
<li><p>调用String类的<code>public String valueOf(int n)</code>可将int型转换为字符串</p>
</li>
<li><p>相应的<code>valueOf(byte b)、valueOf(long )、valueOf(float f)、valueOf(doubled)、valueOf(boolean b)</code>可由参数的相应类型到字符串的转换</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-StringBuffer类"><a href="#1-2-StringBuffer类" class="headerlink" title="1.2 StringBuffer类"></a>1.2 StringBuffer类</h3><ul>
<li>java.lang.StringBuffer代表<strong>可变的字符序列</strong>，JDK1.0中声明，可以对字符 串内容进行增删，此时不会产生新的对象。</li>
<li>很多方法与String相同。</li>
<li>作为参数传递时，方法内部可以改变值。</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221222134619008.png" alt="image-20221222134619008"></p>
<hr>
<p><code>StringBuffer</code>类不同于<strong>String</strong>，其对象必须使用构造器生成。有三个构造器：</p>
<p><code>StringBuffer()</code>：初始容量为<strong>16</strong>的字符串缓冲区</p>
<p><code>StringBuffer(int size)</code>：构造指定容量的字符串缓冲区</p>
<p><code>StringBuffer(String str)</code>：将内容初始化为指定字符串内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学习&quot;</span>);</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢学习&quot;</span>);</span><br><span class="line">buffer.append(<span class="string">&quot;数学&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221222134721034.png" alt="image-20221222134721034"></p>
<h4 id="1-2-1-StringBuffer类的常用方法"><a href="#1-2-1-StringBuffer类的常用方法" class="headerlink" title="1.2.1 StringBuffer类的常用方法"></a>1.2.1 StringBuffer类的常用方法</h4><p><code>StringBuffer append(xxx)</code>：提供了很多重载的append()方法，用于进行字符串拼接</p>
<p><code>StringBuffer delete(int start,int end)</code>：删除指定位置的内容</p>
<p><code>StringBuffer replace(int start, int end, String str)</code>：把[start,end)位置替换为str（左闭右开）</p>
<p><code>StringBuffer insert(int offset, xxx)</code>：在指定位置插入xxx </p>
<p><code>StringBuffer reverse()</code> ：把当前字符序列逆转</p>
<hr>
<p><code>public int indexOf(String str)</code>：返回指定子字符串在此字符串中第一次出现处的索引</p>
<p><code>public String substring(int start,int end)</code>：返回一个从start开始到end索引结束的左闭右开区间的子字符串</p>
<p><code>public int length()</code>：返回字符串的长度</p>
<p><code>public char charAt(int n )</code>：返回某索引处的字符return value[index]</p>
<p><code>public void setCharAt(int n ,char ch)</code>：改变某个索引位置的字符</p>
<h3 id="1-3-StringBuilder类"><a href="#1-3-StringBuilder类" class="headerlink" title="1.3 StringBuilder类"></a>1.3 StringBuilder类</h3><p>StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样</p>
<hr>
<p><strong>String、StringBuffer、StringBuilder类 总结</strong></p>
<p><strong>一、面试题：对比 String、StringBuffer、StringBuilder</strong> </p>
<p>不同点：</p>
<ul>
<li>String(JDK1.0)：不可变字符序列</li>
<li>StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全</li>
<li>StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全</li>
</ul>
<p>相同点：底层使用char[]存储</p>
<p>注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer 和 StringBuilder 会改变其值。</p>
<p>问题：</p>
<ul>
<li>扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</li>
<li>指导意义：开发中建议大家使用：StringBuffer(int capacity) 或StringBuilder(int capacity)</li>
</ul>
<p><strong>二、String:字符串，使用一对””引起来表示。</strong></p>
<ol>
<li><p>String声明为final的，不可被继承</p>
</li>
<li><p>String实现了Serializable接口：表示字符串是支持序列化的。<br>实现了Comparable接口：表示String可以比较大小</p>
</li>
<li><p>String内部定义了final char[] value用于存储字符串数据</p>
</li>
<li><p>String:代表不可变的字符序列。简称：不可变性。<br>体现：</p>
<ul>
<li><p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p>
</li>
<li><p>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p>
</li>
<li><p>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p>
</li>
</ul>
</li>
<li><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>
</li>
<li><p>字符串常量池中是不会存储<strong>相同内容</strong>（String类重写的equals()方法，返回true）的字符串的。</p>
</li>
</ol>
<p><strong>三、String的实例化方式：</strong></p>
<ul>
<li>方式一：通过字面量定义的方式</li>
<li>方式二：通过new + 构造器的方式</li>
</ul>
<p>面试题：<code>String s = new String(&quot;abc&quot;);</code>方式创建对象，在内存中创建了几个对象？</p>
<p>两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p>
<p><strong>四、String和其他类型之间的转换</strong></p>
<p>① String 与基本数据类型、包装类之间的转换。</p>
<ul>
<li>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：<code>parseXxx(str)</code></li>
<li>基本数据类型、包装类 –&gt; String:调用String重载的<code>valueOf(xxx)</code></li>
</ul>
<p>②String 与 char[]之间的转换</p>
<ul>
<li>String –&gt; char[]:调用String的<code>toCharArray()</code></li>
<li>char[] –&gt; String:调用String的构造器</li>
</ul>
<p>③ String 与 byte[]之间的转换</p>
<ul>
<li>编码：String –&gt; byte[]:调用String的getBytes()</li>
<li>解码：byte[] –&gt; String:调用String的构造器</li>
</ul>
<p>补充：</p>
<ul>
<li>编码：字符串 –&gt;字节  (看得懂 —&gt;看不懂的二进制数据)</li>
<li>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）</li>
<li>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</li>
</ul>
<p><strong>五、StringBuffer和StringBulider类的常用方法总结</strong></p>
<ul>
<li>增：append(xxx)</li>
<li>删：delete(int start,int end)</li>
<li>改：setCharAt(int n ,char ch) &#x2F; replace(int start, int end, String str)</li>
<li>查：charAt(int n )</li>
<li>插：insert(int offset, xxx)</li>
<li>长度：length();</li>
<li>遍历：for() + charAt() &#x2F; toString()</li>
</ul>
<h2 id="2-JDK8之前日期时间API"><a href="#2-JDK8之前日期时间API" class="headerlink" title="2. JDK8之前日期时间API"></a>2. JDK8之前日期时间API</h2><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221222141402932.png" alt="image-20221222141402932"></p>
<h3 id="2-1-java-lang-System类"><a href="#2-1-java-lang-System类" class="headerlink" title="2.1 java.lang.System类"></a>2.1 java.lang.System类</h3><p>System类提供的<code>public static long currentTimeMillis()</code>用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差（时间戳）。</p>
<blockquote>
<p>此方法适于计算时间差。</p>
</blockquote>
<hr>
<p>计算世界时间的主要标准有：</p>
<ul>
<li>UTC(Coordinated Universal Time)</li>
<li>GMT(Greenwich Mean Time)</li>
<li>CST(Central Standard Time)</li>
</ul>
<h3 id="2-2-java-util-Date类"><a href="#2-2-java-util-Date类" class="headerlink" title="2.2 java.util.Date类"></a>2.2 java.util.Date类</h3><p>表示特定的瞬间，精确到毫秒</p>
<hr>
<p>构造器：</p>
<ul>
<li><p>Date()：使用无参构造器创建的对象可以获取<strong>本地当前时间</strong>。</p>
</li>
<li><p>Date(long date)：创建指定毫秒数的Date对象</p>
</li>
</ul>
<hr>
<p>常用方法</p>
<ul>
<li><code>getTime()</code>:返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</li>
<li><code>toString()</code>:把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。</li>
<li>其它很多方法都过时了。</li>
</ul>
<hr>
<p><strong>Date类 小结</strong></p>
<ul>
<li>通过构造器的方式创建Date类实例化对象</li>
<li>可以通过对象.getTime()的方法获得实例化的Date类对象的毫秒数</li>
<li>可以通过对象.toString()的方法将Date类对象转换成特定格式的String</li>
</ul>
<h3 id="2-3-java-text-SimpleDateFormat类"><a href="#2-3-java-text-SimpleDateFormat类" class="headerlink" title="2.3 java.text.SimpleDateFormat类"></a>2.3 java.text.SimpleDateFormat类</h3><p>Date类的API不易于国际化，大部分被废弃了，<code>java.text.SimpleDateFormat</code>类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</p>
<p>它允许进行格式化：日期–&gt;文本、解析：文本–&gt;日期</p>
<hr>
<p>格式化：</p>
<p><code>SimpleDateFormat()</code> ：默认的模式和语言环境创建对象</p>
<p><code>public SimpleDateFormat(String pattern)</code>：该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用：</p>
<p><code>public String format(Date date)</code>：方法格式化时间对象date</p>
<hr>
<p>解析：</p>
<p><code>public Date parse(String source)</code>：从给定字符串的开始解析文本，以生成一个日期。</p>
<hr>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221225150845702.png" alt="image-20221225150845702"></p>
<hr>
<p><strong>SimpleDateformat类 小结</strong></p>
<ul>
<li>实例化：创建SimpleDateFormat类的对象（可以使用默认的空参构造器，也可以使用带参的构造器传入指定格式的字符串）</li>
<li>格式化：（日期–&gt;字符串）通过SimpleDateFormat类的对象调用<code>format(Data date)</code>方法，传入一个Date对象</li>
<li>解析：（字符串–&gt;日期）通过SimpleDateFormat类的对象调用<code>parse(Data date)</code>方法，传入一个String对象</li>
</ul>
<blockquote>
<p>需要先实例化SimpleDateFormat类</p>
<p>如果是按照<strong>指定格式</strong>的构造器创建对象的话，那么格式化和解析的时候也要严格按照此<strong>指定格式</strong>。</p>
</blockquote>
<h3 id="2-4-java-util-Calendar-日历-类"><a href="#2-4-java-util-Calendar-日历-类" class="headerlink" title="2.4 java.util.Calendar(日历)类"></a>2.4 java.util.Calendar(日历)类</h3><p>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</p>
<p>获取Calendar实例的方法</p>
<ul>
<li>使用<code>Calendar.getInstance()</code>方法：实际上返回的也是子类<code>GregorianCalendar</code>的实例化对象</li>
<li>调用它的子类<code>GregorianCalendar</code>的构造器。</li>
</ul>
<hr>
<p>一个Calendar的实例是系统时间的抽象表示，通过方法操作时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、 MINUTE、SECOND（都是Calendar类中的全局常量[static final修饰的属性]）</p>
<ul>
<li><p><code>public int get(int field)</code> 获取想要的对象的时间信息</p>
</li>
<li><p><code>public void set(int field,int value)</code> 修改对象的指定的时间信息</p>
</li>
<li><p><code>public void add(int field,int amount)</code> 给对象的指定的时间信息</p>
</li>
<li><p><code>public final Date getTime()</code>[日历类—&gt; Date] 将日历对象转成Date对象，返回一个Date对象</p>
</li>
<li><p><code>public final void setTime(Date date)</code>[Date —&gt; 日历类]，将指定的Date对象转成日历类对象，可以使用日历类的方法对其操作</p>
</li>
</ul>
<hr>
<p>注意**:**</p>
<ul>
<li>获取月份时：一月是0，二月是1，以此类推，12月是11</li>
<li>获取星期时：周日是1，周二是2 ， 。。。。周六是7</li>
</ul>
<hr>
<p><strong>Calendar类 小结</strong></p>
<ul>
<li><p>实例化：</p>
<ul>
<li><p>调用它的子类<code>GregorianCalendar</code>的构造器</p>
</li>
<li><p>使用<code>Calendar.getInstance()</code>方法</p>
</li>
</ul>
</li>
<li><p>通过对象调用方法：</p>
<ul>
<li><p><code>get()</code>、<code>set()</code>、<code>add()</code>方法，来获取想要的时间信息，传入的参数为Calendar中定义的全局常量</p>
</li>
<li><p>(日历类—&gt; Date)getTime()方法，将日历对象转成Date对象，返回一个Date对象</p>
</li>
<li><p>(Date —&gt; 日历类)setTime()方法，将指定的Date对象转成日历类对象，可以使用日历类的方法对其操作</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-JDK8中新日期时间API"><a href="#3-JDK8中新日期时间API" class="headerlink" title="3. JDK8中新日期时间API"></a>3. JDK8中新日期时间API</h2><p><strong>新日期时间API出现的背景</strong></p>
<p>如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不 过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了 一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。</p>
<p>而Calendar并不比Date好多少。它们面临的问题是：</p>
<ul>
<li>可变性：像日期和时间这样的类应该是不可变的。</li>
<li>偏移性：Date中的年份是从1900开始的，而月份都从0开始。 </li>
<li>格式化：格式化只对Date有用，Calendar则不行。</li>
<li>此外，它们也不是线程安全的；不能处理闰秒等。</li>
</ul>
<hr>
<p>第三次引入的API是成功的，并且Java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。</p>
<p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。 新的 <strong>java.time</strong> 中包含了所有关于<strong>本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）</strong>的类。历史悠久的 Date 类新增了 toInstant() 方法， 用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简 化了日期时间和本地化的管理。</p>
<hr>
<ul>
<li>java.time – 包含值对象的基础包</li>
<li>java.time.chrono – 提供对不同的日历系统的访问 </li>
<li>java.time.format – 格式化和解析时间和日期 </li>
<li>java.time.temporal – 包括底层框架和扩展特性 </li>
<li>java.time.zone – 包含时区支持的类</li>
</ul>
<p>说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一。</p>
<h3 id="3-1-LocalDate-Time"><a href="#3-1-LocalDate-Time" class="headerlink" title="3.1 LocalDate(Time)"></a>3.1 LocalDate(Time)</h3><p>LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是<strong>不可变的对象</strong>，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p>
<ul>
<li>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。</li>
<li>LocalTime表示一个时间，而不是日期。</li>
<li>LocalDateTime是用来表示日期和时间的，<strong>这是一个最常用的类之一</strong>。</li>
</ul>
<blockquote>
<p>ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示 法，也就是公历。</p>
</blockquote>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221225164538162.png" alt="image-20221225164538162"></p>
<hr>
<p><strong>LocalDateTime类 小结</strong></p>
<blockquote>
<p>类似于Calendar类</p>
</blockquote>
<ul>
<li>LocalDate：表示一个日期</li>
<li>LocalTime：表示一个时间</li>
<li>LocalDateTime：表示日期和时间</li>
</ul>
<ol>
<li><p>实例化：创建LocalDate、LocalTime、LocalDateTime类的对象，</p>
<ul>
<li><p>now()：返回一个对象</p>
</li>
<li><p>of()：设置指定的年、月、日、时、分、秒，返回一个上面创建的类对应的实例化对象。没有偏移量。</p>
</li>
</ul>
</li>
<li><p>通过对象调用方法</p>
<ul>
<li>getXxx()：获取相关的属性（比如：DayOfMonth、DayOfYear、DayOfWeek、Month、MonthValue、Year、Hour、Minute、Second）</li>
<li>withXxx()：设置相关属性（比如：DayOfMonth、DayOfYear、Month、Year），将值传入方法的形参进行设置或者修改原来的值【不会改变原来的对象的属性，体现了不可变性】</li>
<li>plus()：向当前对象添加某属性数值，传入整数型作为形参</li>
<li>minus()：从当前对象减去某属性的数值，传入整数型作为形参</li>
</ul>
</li>
</ol>
<h3 id="3-2-瞬时：Instant"><a href="#3-2-瞬时：Instant" class="headerlink" title="3.2 瞬时：Instant"></a>3.2 瞬时：Instant</h3><p>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。</p>
<p>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是 时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连 续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机 处理。<strong>在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中， 也是从1970年开始，但以毫秒为单位。</strong></p>
<p><strong>java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间 单位。</strong>Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。 概念上讲，<strong>它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒 数。</strong>因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</p>
<p>(1 ns &#x3D; 10-9  s) 1秒 &#x3D; 1000毫秒 &#x3D;10^6微秒&#x3D;10^9纳秒</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221225164930680.png" alt="image-20221225164930680"></p>
<p><strong>时间戳</strong>是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</p>
<hr>
<p><strong>Instant 小结</strong></p>
<blockquote>
<p>类似于java.util.Date类</p>
</blockquote>
<ol>
<li>创建Instant对象：</li>
</ol>
<ul>
<li><code>now()</code>：返回一个Instant对象，获取本初子午线对应的标准时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ofEpochMilli()</code>：通过给定的毫秒数传入形参，获取一个Instant对象  （类似于：<code>Date(long millis)</code>）</li>
</ul>
<ol start="2">
<li>一些相关方法：</li>
</ol>
<ul>
<li><code>atOffset()</code>：添加时间偏移量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>toEpochMilli()</code>：获取时间戳  （类似于：Date类的<code>getTime()</code>）</li>
</ul>
<h3 id="3-3-格式化与解析日期或时间"><a href="#3-3-格式化与解析日期或时间" class="headerlink" title="3.3 格式化与解析日期或时间"></a>3.3 格式化与解析日期或时间</h3><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p>
<ul>
<li><p>预定义的标准格式。如：</p>
<ul>
<li><p><strong>ISO_LOCAL_DATE_TIME</strong></p>
</li>
<li><p><strong>ISO_LOCAL_DATE</strong></p>
</li>
<li><p><strong>ISO_LOCAL_TIME</strong></p>
</li>
</ul>
</li>
<li><p>本地化相关的格式。如：<code>ofLocalizedDateTime(FormatStyle.LONG)</code></p>
</li>
<li><p>自定义的格式。如：<code>ofPattern(“yyyy-MM-dd hh:mm:ss”)</code></p>
</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221225165437209.png" alt="image-20221225165437209"></p>
<hr>
<p><strong>DateTimeFormatter类 小结</strong></p>
<blockquote>
<p>类似于SimpleDateFormat类</p>
</blockquote>
<p>实例化：通过DateTimeFormatter类调用静态属性或方法</p>
<ul>
<li><p>① 预定义的标准格式</p>
<p>通过DateTimeFormatter.(标准格式) 的形式返回一个DateTimeFormatter类的对象</p>
</li>
<li><p>② 本地化相关的格式</p>
<p>通过<code>DateTimeFormatter.ofLocalizedDateTime(FormatStyle dateTimeStyle)</code>的方式返回一个对象</p>
<p>通过<code>DateTimeFormatter.ofLocalizedDate(FormatStyle dateTimeStyle)</code>的方式返回一个对象</p>
<blockquote>
<p>FormatStyle类包含：FULL、LONG、MEDIUM、SHORT，通过FoematStyle.XXX的方式就可以调用</p>
</blockquote>
</li>
<li><p>③ 自定义格式（重点）</p>
<p>通过<code>DateTimeFormatter.ofPattern()</code>的方式返回一个对象</p>
</li>
</ul>
<p>通过DateTimeFormatter类的对象调用方法：</p>
<ul>
<li><p>格式化：日期–&gt;字符串</p>
<p><code>format(TemporalAccessor t)</code>，传入一个LocalDate(Time)对象</p>
</li>
<li><p>解析：字符串–&gt;日期</p>
<p><code>parse(CharSequence text)</code>，传入一个特定格式的字符串对象</p>
</li>
</ul>
<h3 id="3-4-其他日期API"><a href="#3-4-其他日期API" class="headerlink" title="3.4 其他日期API"></a>3.4 其他日期API</h3><ul>
<li><strong>ZoneId</strong>：该类中包含了所有的时区信息，一个时区的ID，如 Europe&#x2F;Paris</li>
<li><strong>ZonedDateTime</strong>：一个在ISO-8601日历系统时区的日期时间，如 2007-12-  03T10:15:30+01:00 Europe&#x2F;Paris。</li>
<li>其中每个时区都对应着ID，地区ID都为“{区域}&#x2F;{城市}”的格式，例如：Asia&#x2F;Shanghai等</li>
<li><strong>Clock</strong>：使用时区提供对当前即时、日期和时间的访问的时钟。</li>
<li>持续时间：<strong>Duration</strong>，用于计算两个“时间”间隔</li>
<li>日期间隔：<strong>Period</strong>，用于计算两个“日期”间隔</li>
<li><strong>TemporalAdjuster</strong> <strong>:</strong> 时间校正器。有时我们可能需要获取例如：将日期调整 到“下一个工作日”等操作。</li>
<li><strong>TemporalAdjusters</strong> <strong>:</strong> 该类通过静态方法 (firstDayOfXxx()&#x2F;lastDayOfXxx()&#x2F;nextXxx()）提供了大量的常用 TemporalAdjuster 的实现。</li>
</ul>
<h3 id="3-5-与传统日期处理的转换"><a href="#3-5-与传统日期处理的转换" class="headerlink" title="3.5 与传统日期处理的转换"></a>3.5 与传统日期处理的转换</h3><p><img src="/images%5Cimage-20221225223516902.png" alt="image-20221225223516902"></p>
<h2 id="4-Java比较器"><a href="#4-Java比较器" class="headerlink" title="4. Java比较器"></a>4. Java比较器</h2><p>在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。</p>
<p>Java实现对象排序的方式有两种：</p>
<ul>
<li>自然排序：java.lang.Comparable</li>
<li>定制排序：java.util.Comparator</li>
</ul>
<h3 id="4-1-自然排序：Comparable"><a href="#4-1-自然排序：Comparable" class="headerlink" title="4.1 自然排序：Comparable"></a>4.1 自然排序：Comparable</h3><ul>
<li><p>Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称 为类的自然排序。</p>
</li>
<li><p>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即 通过 compareTo(Object obj) 方法的返回值来比较大小。<strong>如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。</strong></p>
</li>
<li><p>实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或 Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有 序集合中的元素，无需指定比较器。</p>
</li>
<li><p>对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) &#x3D;&#x3D; 0 与 e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。建议（虽然不是必需的）<strong>最好使自然排序与 equals 一致。</strong></p>
</li>
<li><p>Comparable 的典型实现：(默认都是从小到大排列的)</p>
<ul>
<li><p>String：按照字符串中字符的Unicode值进行比较</p>
</li>
<li><p>Character：按照字符的Unicode值来进行比较</p>
</li>
<li><p>数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较</p>
</li>
<li><p>Boolean：true 对应的包装类实例大于 false 对应的包装类实例</p>
</li>
<li><p>Date、Time等：后面的日期时间比前面的日期时间大</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-定制排序：Comparator"><a href="#4-2-定制排序：Comparator" class="headerlink" title="4.2 定制排序：Comparator"></a>4.2 定制排序：Comparator</h3><p><strong>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码， 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序</strong>，强行对多个对象进行整体排序的比较。</p>
<p>重写compare(Object o1, Object o2)方法，比较o1和o2的大小：<strong>如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示 o1小于o2。</strong></p>
<p>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort）， 从而允许在排序顺序上实现精确控制。</p>
<p>还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</p>
<hr>
<p><strong>Java比较器 总结</strong></p>
<p><strong>一、说明：</strong></p>
<p>Java中的对象，正常情况下，只能进行比较：&#x3D;&#x3D;  或  !&#x3D; 。不能使用 &gt; 或 &lt; 的。但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</p>
<p>如何实现？使用两个接口中的任何一个：Comparable 或 Comparator</p>
<p><strong>二、Comparable接口与Comparator的使用的对比：</strong></p>
<ul>
<li>Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</li>
<li>Comparator接口属于临时性的比较。</li>
</ul>
<p>① <strong>Comparable接口的使用举例：  自然排序</strong></p>
<ol>
<li><p>像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。</p>
</li>
<li><p>像String、包装类重写compareTo()方法以后，进行了从小到大的排列 </p>
<ol start="3">
<li><p>重写compareTo(obj)的规则：</p>
<pre><code>- 如果当前对象this大于形参对象obj，则返回正整数，
- 如果当前对象this小于形参对象obj，则返回负整数，
- 如果当前对象this等于形参对象obj，则返回零。
</code></pre>
</li>
</ol>
</li>
<li><p>对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序</p>
</li>
</ol>
<p>② <strong>Comparator接口的使用：定制排序</strong></p>
<ol>
<li>背景：<br>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，<br>或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，<br>那么可以考虑使用 Comparator 的对象来排序</li>
<li>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：<ul>
<li>如果方法返回正整数，则表示o1大于o2；</li>
<li>如果返回0，表示相等；</li>
<li>返回负整数，表示o1小于o2。</li>
</ul>
</li>
</ol>
<h2 id="5-System类"><a href="#5-System类" class="headerlink" title="5. System类"></a>5. System类</h2><p>① System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。 该类位于java.lang包。</p>
<p>② 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实 例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便 的进行调用。</p>
<p>③ 成员变量</p>
<ul>
<li>System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</li>
</ul>
<p>④ 成员方法</p>
<ul>
<li><p><strong>native</strong> <strong>long</strong> **currentTimeMillis()**：</p>
<p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
</li>
<li><p><strong>void</strong> **exit(int status)**：</p>
<p>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
</li>
<li><p><strong>void</strong> **gc()**：</p>
<p>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则 取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p>
</li>
<li><p><strong>String</strong> <strong>getProperty(String</strong> **key)**：</p>
<p>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p>
</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221226180044951.png" alt="image-20221226180044951"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">javaVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>); System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.home&quot;</span>); System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">osVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.version&quot;</span>); System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">userHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>); System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line"><span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>); System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br></pre></td></tr></table></figure>



<h2 id="6-Math类"><a href="#6-Math类" class="headerlink" title="6. Math类"></a>6. Math类</h2><p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p>
<table>
<thead>
<tr>
<th>abs</th>
<th>绝对值</th>
</tr>
</thead>
<tbody><tr>
<td>acos,asin,atan,cos,sin,tan</td>
<td>三角函数</td>
</tr>
<tr>
<td>sqrt</td>
<td>平方根</td>
</tr>
<tr>
<td>pow(double a,doble b)</td>
<td>a的b次幂</td>
</tr>
<tr>
<td>log</td>
<td>自然对数</td>
</tr>
<tr>
<td>exp</td>
<td>e为底指数</td>
</tr>
<tr>
<td>max(double a,double b)</td>
<td>返回两者之中的较大者</td>
</tr>
<tr>
<td>min(double a,double b)</td>
<td>返回两者之中的较小者</td>
</tr>
<tr>
<td>random()</td>
<td>返回0.0到1.0的随机数</td>
</tr>
<tr>
<td>long round(double a)</td>
<td>double型数据a转换为long型（四舍五入）</td>
</tr>
<tr>
<td>toDegrees(double angrad)</td>
<td>弧度—&gt;角度</td>
</tr>
<tr>
<td>toRadians(double angdeg)</td>
<td>角度—&gt;弧度</td>
</tr>
</tbody></table>
<h2 id="7-BigInteger与BigDecimal"><a href="#7-BigInteger与BigDecimal" class="headerlink" title="7. BigInteger与BigDecimal"></a>7. BigInteger与BigDecimal</h2><h3 id="7-1-BigInteger类"><a href="#7-1-BigInteger类" class="headerlink" title="7.1 BigInteger类"></a>7.1 BigInteger类</h3><ul>
<li>Integer类作为int的包装类，能存储的最大整型值为231-1，Long类也是有限的， 最大为263-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类 都无能为力，更不用说进行运算了。</li>
<li>java.math包的<strong>BigInteger可以表示不可变的任意精度的整数</strong>。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。 另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、 位操作以及一些其他操作。</li>
<li>构造器<ul>
<li><strong>BigInteger</strong>(String val)：根据字符串构建BigInteger对象</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221226181202431.png" alt="image-20221226181202431"></p>
<h3 id="7-2-BigDecimal类"><a href="#7-2-BigDecimal类" class="headerlink" title="7.2 BigDecimal类"></a>7.2 BigDecimal类</h3><ul>
<li><p>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中， <strong>要求数字精度比较高</strong>，故用到<strong>java.math.BigDecimal</strong>类。</p>
</li>
<li><p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p>
</li>
<li><p>构造器</p>
<ul>
<li><p>public BigDecimal(double val)</p>
</li>
<li><p>public BigDecimal(String val)</p>
</li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li><p>public BigDecimal <code>add</code>(BigDecimal augend)</p>
</li>
<li><p>public BigDecimal <code>subtract</code>(BigDecimal subtrahend)</p>
</li>
<li><p>public BigDecimal <code>multiply</code>(BigDecimal multiplicand)</p>
</li>
<li><p>public BigDecimal <code>divide</code>(BigDecimal divisor, int scale, int roundingMode)</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBigInteger</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12433241123&quot;</span>);  </span><br><span class="line">	<span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);  </span><br><span class="line">	<span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);  					System.out.println(bi);</span><br><span class="line">	<span class="comment">// System.out.println(bd.divide(bd2));  					System.out.println(bd.divide(bd2, 				BigDecimal.ROUND_HALF_UP)); </span></span><br><span class="line">    System.out.println(bd.divide(bd2, <span class="number">15</span>, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第九章-gt-gt-gt-枚举类与注解"><a href="#第九章-gt-gt-gt-枚举类与注解" class="headerlink" title="第九章&gt;&gt;&gt;枚举类与注解"></a>第九章&gt;&gt;&gt;枚举类与注解</h1><h2 id="1-枚举类的使用"><a href="#1-枚举类的使用" class="headerlink" title="1. 枚举类的使用"></a>1. 枚举类的使用</h2><ul>
<li><p>主要内容**:**</p>
<ul>
<li><p>如何自定义枚举类</p>
</li>
<li><p>如何使用关键字enum定义枚举类</p>
</li>
<li><p>Enum类的主要方法</p>
</li>
<li><p>实现接口的枚举类</p>
</li>
</ul>
</li>
<li><p>类的对象只有有限个，确定的。</p>
</li>
<li><p>当需要定义一组常量时，强烈建议使用枚举类</p>
</li>
</ul>
<hr>
<ul>
<li><p>枚举类的实现</p>
<ul>
<li><p>JDK1.5之前需要自定义枚举类</p>
</li>
<li><p>JDK 1.5 新增的 <strong>enum</strong> 关键字用于定义枚举类</p>
</li>
</ul>
</li>
<li><p>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。</p>
</li>
<li><p>枚举类的属性</p>
<ul>
<li><p>枚举类对象的属性不应允许被改动**,** 所以应该使用 <strong>private final</strong> 修饰</p>
</li>
<li><p>枚举类的使用 <strong>private final</strong> 修饰的属性应该在构造器中为其赋值</p>
</li>
<li><p>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-自定义枚举类"><a href="#2-自定义枚举类" class="headerlink" title="2. 自定义枚举类"></a>2. 自定义枚举类</h2><ol>
<li><p>私有化类的构造器，保证不能在类的外部创建其对象</p>
</li>
<li><p>在类的内部创建枚举类的实例。声明为：<strong>public static final</strong></p>
</li>
<li><p>对象如果有实例变量，应该声明为<strong>private final</strong>，并在构造器中初始化</p>
</li>
</ol>
<h2 id="3-使用enum定义枚举类"><a href="#3-使用enum定义枚举类" class="headerlink" title="3. 使用enum定义枚举类"></a>3. 使用enum定义枚举类</h2><ul>
<li><p>使用说明</p>
<ul>
<li><p>使用 enum 定义的枚举类<strong>默认继承</strong>了 java.lang.Enum类，因此不能再继承其他类</p>
</li>
<li><p>枚举类的构造器只能使用 private 权限修饰符</p>
</li>
<li><p>枚举类的所有实例必须在枚举类中显式列出(“,” 分隔，”;”结尾）。列出的实例系统会<strong>自动添加 public static final</strong> 修饰</p>
</li>
<li><p><strong>必须在枚举类的第一行声明枚举类对象</strong></p>
</li>
</ul>
</li>
<li><p><strong>JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象 作为表达式</strong>, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;  		</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">    	<span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;  </span><br><span class="line">    	<span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>使用enum关键字定义的枚举类实现接口的情况</p>
<ul>
<li>情况一：实现接口，在enum类中实现抽象方法</li>
<li>情况二：让枚举类的对象分别实现接口中的抽象方法</li>
</ul>
<h2 id="4-Enum类的主要方法"><a href="#4-Enum类的主要方法" class="headerlink" title="4. Enum类的主要方法"></a>4. Enum类的主要方法</h2><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221227100702809.png" alt="image-20221227100702809"></p>
<ul>
<li>**values()**方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</li>
<li><strong>valueOf(String</strong> **str)**：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如果不是，会有运行时异常： IllegalArgumentException。</li>
<li>**toString()**：返回当前枚举类对象常量的名称</li>
</ul>
<hr>
<p><strong>说明：</strong></p>
<ul>
<li>和普通 Java 类一样，枚举类可以实现一个或多个接口</li>
<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li>
<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式,则可以让每个枚举值分别来实现该方法</li>
</ul>
<h2 id="1-注解-Annotation"><a href="#1-注解-Annotation" class="headerlink" title="1. 注解(Annotation)"></a>1. 注解(Annotation)</h2><p><strong>主要内容：</strong></p>
<ul>
<li>注解(Annotation)概述</li>
<li>常见的Annotation示例</li>
<li>自定义Annotation</li>
<li>JDK中的元注解</li>
<li>利用反射获取注解信息（在反射部分涉及）</li>
<li>JDK 8中注解的新特性</li>
</ul>
<hr>
<ul>
<li><p>从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)</p>
</li>
<li><p>Annotation 其实就是代码里的<strong>特殊标记</strong>, 这些标记可以在编译, 类加 载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员 可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代 码分析工具、开发工具和部署工具可以通过这些补充信息进行验证 或者进行部署。</p>
</li>
<li><p>Annotation 可以像修饰符一样被使用, 可用于<strong>修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明</strong>, 这些信息被保存在 Annotation 的 “name&#x3D;value” 对中。</p>
</li>
<li><p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，  忽略警告等。在JavaEE&#x2F;Android中注解占据了更重要的角色，例如 用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</p>
</li>
<li><p>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以 上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势。</p>
<p>一定程度上可以说：<strong>框架 &#x3D; 注解 + 反射 + 设计模式。</strong></p>
</li>
</ul>
<h2 id="2-常见的Annotation示例"><a href="#2-常见的Annotation示例" class="headerlink" title="2. 常见的Annotation示例"></a>2. 常见的Annotation示例</h2><p>使用 Annotation 时要在其前面增加 @ 符号, 并<strong>把该 Annotation 当成一个修饰符使用。</strong>用于修饰它支持的程序元素</p>
<h3 id="2-1-生成文档相关的注解"><a href="#2-1-生成文档相关的注解" class="headerlink" title="2.1 生成文档相关的注解"></a>2.1 生成文档相关的注解</h3><ol>
<li>@author 标明开发该类模块的作者，多个作者之间使用,分割</li>
<li>@version 标明该类模块的版本 </li>
<li>@see 参考转向，也就是相关主题 </li>
<li>@since 从哪个版本开始增加的</li>
<li>@param 对方法中某参数的说明，如果没有参数就不能写</li>
<li>@return 对方法返回值的说明，如果方法的返回值类型是void就不能写</li>
<li>@exception 对方法可能抛出的异常进行说明，如果方法没有用throws显式抛出的异常就不能写</li>
</ol>
<p>其中</p>
<ul>
<li>@param @return 和 @exception 这三个标记都是只用于方法的。 </li>
<li>@param的格式要求：@param 形参名形参类型 形参说明 </li>
<li>@return 的格式要求：@return 返回值类型返回值说明 </li>
<li>@exception的格式要求：@exception 异常类型 异常说明 </li>
<li>@param和@exception可以并列多个</li>
</ul>
<h3 id="2-2-在编译时进行格式化检查"><a href="#2-2-在编译时进行格式化检查" class="headerlink" title="2.2 在编译时进行格式化检查"></a>2.2 在编译时进行格式化检查</h3><p>JDK内置的三个基本注解</p>
<ul>
<li><strong>@Override:</strong> 限定重写父类方法, 该注解只能用于方法</li>
<li><strong>@Deprecated:</strong> 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</li>
<li><strong>@SuppressWarnings:</strong> 抑制编译器警告</li>
</ul>
<h3 id="2-3-跟踪代码依赖性，实现替代配置文件功能"><a href="#2-3-跟踪代码依赖性，实现替代配置文件功能" class="headerlink" title="2.3 跟踪代码依赖性，实现替代配置文件功能"></a>2.3 跟踪代码依赖性，实现替代配置文件功能</h3><p>Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署。</p>
<p>spring框架中关于“事务”的管理</p>
<h2 id="3-自定义Annotation"><a href="#3-自定义Annotation" class="headerlink" title="3. 自定义Annotation"></a>3. 自定义Annotation</h2><ul>
<li>定义新的Annotation 类型使用 <strong>@interface 关键字</strong></li>
<li>自定义注解自动继承了<strong>java.lang.annotation.Annotation</strong>接口</li>
<li>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能  是<strong>八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、 以上所有类型的数组。</strong></li>
<li>可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始 值可使用 <strong>default 关键字</strong></li>
<li>如果只有一个参数成员，建议使用<strong>参数名为value</strong></li>
<li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认 值。格式是“参数名 &#x3D;  参数值”，如果只有一个参数成员，且名称为value， 可以省略“value&#x3D;”</li>
<li>没有成员定义的 Annotation  称为标记;  包含成员变量的 Annotation  称为元数据Annotation</li>
</ul>
<blockquote>
<p>自定义注解必须配上注解的信息处理流程才有意义。</p>
</blockquote>
<h2 id="4-JDK中的元注解"><a href="#4-JDK中的元注解" class="headerlink" title="4. JDK中的元注解"></a>4. JDK中的元注解</h2><p>JDK 的元Annotation <strong>用于修饰其他Annotation 定义</strong></p>
<p>JDK5.0提供了4个标准的meta-annotation类型，分别是：</p>
<ul>
<li><strong>Retention</strong></li>
<li><strong>Target</strong></li>
<li><strong>Documented</strong></li>
<li><strong>Inherited</strong></li>
</ul>
<p><strong>元数据的理解：</strong></p>
<p><code>String name = “atguigu”;</code></p>
<p>String和name是对实际数据“atguigu”的修饰，指明其数据的类型和名称</p>
<h3 id="4-1-Retention"><a href="#4-1-Retention" class="headerlink" title="4.1 @Retention"></a>4.1 @Retention</h3><p><strong>@Retention</strong>: 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命 周期, @Rentention 包含一个 <strong>RetentionPolicy</strong> 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值:</p>
<ul>
<li><strong>RetentionPolicy.SOURCE</strong>：在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释</li>
<li><strong>RetentionPolicy.CLASS</strong>：在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM不会保留注解。 这是默认值</li>
<li><strong>RetentionPolicy.RUNTIME</strong>：在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221227102958513.png" alt="image-20221227102958513"></p>
<h3 id="4-2-Target"><a href="#4-2-Target" class="headerlink" title="4.2 @Target"></a>4.2 @Target</h3><p><strong>@Target</strong>: 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于 修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221227103106430.png" alt="image-20221227103106430"></p>
<h3 id="4-3-Documented"><a href="#4-3-Documented" class="headerlink" title="4.3 @Documented"></a>4.3 @Documented</h3><ul>
<li>@Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。<ul>
<li><strong>定义为Documented的注解必须设置Retention值为RUNTIME。</strong></li>
</ul>
</li>
</ul>
<h3 id="4-4-Inherited"><a href="#4-4-Inherited" class="headerlink" title="4.4 @Inherited"></a>4.4 @Inherited</h3><p><strong>@Inherited</strong>: 被它修饰的 Annotation 将具有继承性。如果某个类使用了被</p>
<p><strong>@Inherited</strong> 修饰的 Annotation, 则其子类将自动具有该注解。</p>
<ul>
<li>比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解</li>
</ul>
<h2 id="5-利用反射获取注解信息"><a href="#5-利用反射获取注解信息" class="headerlink" title="5. 利用反射获取注解信息"></a>5. 利用反射获取注解信息</h2><ul>
<li>JDK 5.0 在 java.lang.reflect 包下新增了 <strong>AnnotatedElement 接口</strong>, 该接口<strong>代 表程序中可以接受注解的程序元素</strong></li>
<li><strong>当一个 Annotation 类型被定义为运行时 Annotation 后</strong>, 该注解才是运行时 可见, 当 class 文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取</li>
<li>程序可以调用 AnnotatedElement对象的如下方法来访问 Annotation 信息</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221227103856578.png" alt="image-20221227103856578"></p>
<h2 id="6-JDK8中注解的新特性"><a href="#6-JDK8中注解的新特性" class="headerlink" title="6. JDK8中注解的新特性"></a>6. JDK8中注解的新特性</h2><h3 id="6-1-可重复注解"><a href="#6-1-可重复注解" class="headerlink" title="6.1 可重复注解"></a>6.1 可重复注解</h3><p>Java 8对注解处理提供了两点改进：<strong>可重复的注解</strong>及<strong>可用于类型的注解</strong>。此外，  反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法 参数上的注解。</p>
<h3 id="6-2-类型注解"><a href="#6-2-类型注解" class="headerlink" title="6.2 类型注解"></a>6.2 类型注解</h3><p>JDK1.8之后，关于<strong>元注解@Target</strong>的参数类型ElementType枚举值多了两个：<strong>TYPE_PARAMETER,TYPE_USE</strong>。</p>
<p>在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用 在任何地方。</p>
<p>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。</p>
<p>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221227104203903.png" alt="image-20221227104203903"></p>
<hr>
<p><strong>注解 总结</strong></p>
<p>一、<strong>如何自定义注解：参照@SuppressWarnings定义</strong></p>
<p>① 注解声明为：@interface</p>
<p>② 内部定义成员，通常使用value表示</p>
<p>③ 可以指定成员的默认值，使用default定义</p>
<p>④ 如果自定义注解没有成员，表明是一个标识作用。</p>
<p> 如果注解有成员，在使用注解时，需要指明成员的值。<br> 自定义注解必须配上注解的信息处理流程(使用反射)才有意义。<br> 自定义注解通过都会指明两个元注解：Retention、Target</p>
<p><strong>二、JDK提供的4中元注解</strong></p>
<p>元注解：对现有的注解进行解释说明的注解</p>
<ul>
<li><p>Retention：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为）\RUNTIME</p>
<blockquote>
<p>只有声明为RUNTIME生命周期的注解，才能通过反射获取。</p>
</blockquote>
</li>
<li><p>Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素</p>
</li>
<li><p>Documented:表示所修饰的注解在被javadoc解析时，保留下来。</p>
</li>
<li><p>Inherited:被它修饰的 Annotation 将具有继承性。</p>
</li>
</ul>
<p><strong>三、JKD8中注解的新特性</strong></p>
<ul>
<li><p>可重复注解</p>
<ul>
<li><p>① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</p>
</li>
<li><p>② MyAnnotation的**@Target和@Retention等元注解**与MyAnnotations相同。</p>
</li>
</ul>
</li>
<li><p>类型注解（关于<strong>元注解@Target</strong>的参数类型ElementType）</p>
<ul>
<li><p>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。</p>
</li>
<li><p>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用某个注解的时候</p>
<ul>
<li>如果注解的属性名为value，则value可以省略；</li>
<li>如果注解的属性值为数组，并且数组中只有一个元素，那么大括号也可以省略。</li>
</ul>
</blockquote>
<h1 id="第十章-gt-gt-gt-集合"><a href="#第十章-gt-gt-gt-集合" class="headerlink" title="第十章&gt;&gt;&gt;集合"></a>第十章&gt;&gt;&gt;集合</h1><h2 id="1-Java集合框架概述"><a href="#1-Java集合框架概述" class="headerlink" title="1. Java集合框架概述"></a>1. Java集合框架概述</h2><p>一方面， 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象 的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊 端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。</p>
<ul>
<li><p>数组在内存存储方面的<strong>特点</strong>：</p>
<ul>
<li>数组初始化以后，长度就确定了。</li>
<li>数组声明的类型，就决定了进行元素初始化时的类型</li>
</ul>
</li>
<li><p>数组在存储数据方面的<strong>弊端</strong>：</p>
<ul>
<li>数组初始化以后，<strong>长度就不可变了</strong>，不便于扩展</li>
<li>数组中<strong>提供的属性和方法少</strong>，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数</li>
<li>数组存储的数据是有序的、可以重复的。—-&gt; 存储数据的特点单一</li>
</ul>
</li>
</ul>
<p>Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。</p>
<hr>
<p><strong>集合的使用场景</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221229205054626.png" alt="image-20221229205054626"></p>
<hr>
<p><strong>Java 集合可分为 Collection 和 Map 两种体系</strong></p>
<ul>
<li><p><strong>Collection</strong>接口：单列数据，定义了存取一组对象的方法的集合</p>
<ul>
<li><p><strong>List</strong>：元素有序、可重复的集合</p>
</li>
<li><p><strong>Set</strong>：元素无序、不可重复的集合</p>
</li>
</ul>
</li>
<li><p><strong>Map</strong>接口：双列数据，保存具有映射关系“key-value对”的集合</p>
</li>
</ul>
<hr>
<p><strong>Collection接口继承树</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221229205226327.png" alt="image-20221229205226327"></p>
<hr>
<p><strong>Map接口继承树</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221229205503904.png" alt="image-20221229205503904"></p>
<h2 id="2-Collection接口"><a href="#2-Collection接口" class="headerlink" title="2. Collection接口"></a>2. Collection接口</h2><ul>
<li>Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。</li>
<li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。</li>
<li>在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都 当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。</li>
</ul>
<blockquote>
<p>向Collection接口的实现类的对象中添加数据obj时，要求obj所属类要重写equals()，因为此接口中的很多方法都需要调用equals()。</p>
</blockquote>
<hr>
<p><strong>Collection接口方法</strong></p>
<p>① 添加</p>
<ul>
<li><code>add(Object obj)</code></li>
<li><code>addAll(Collection coll)</code></li>
</ul>
<p>② 获取有效元素的个数</p>
<ul>
<li><code>int size()</code></li>
</ul>
<p>③ 清空集合</p>
<ul>
<li><code>void clear()</code></li>
</ul>
<p>④ 是否是空集合（集合的size是否为0）</p>
<ul>
<li><code>boolean isEmpty()</code></li>
</ul>
<p>⑤ 是否包含某个元素</p>
<ul>
<li><code>boolean contains(Object obj)</code>：是通过元素的equals方法来判断是否是同一个对象（我们在判断时会调用obj对象所属类的equals()。传入的obj对象与集合中的每一个元素作比较，一旦匹配到了相同元素，就终止比较）</li>
<li><code>boolean containsAll(Collection c)</code>：也是调用元素的equals方法来比 较的。拿两个集合的元素逐个比较。</li>
</ul>
<p>⑥ 删除</p>
<ul>
<li><code>boolean remove(Object obj)</code> ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</li>
<li><code>boolean removeAll(Collection coll)</code>：取当前集合的差集（从当前集合中移除 coll 中与当前集合重复的所有元素。）</li>
</ul>
<p>⑦ 取两个集合的交集</p>
<ul>
<li><code>boolean retainAll(Collection c)</code>：把交集的结果存在当前集合中，不影响c（直接对调用此方法的集合进行修改）</li>
</ul>
<p>⑧ 集合是否相等</p>
<ul>
<li><code>boolean equals(Object obj)</code></li>
</ul>
<p>⑨ 转成对象数组</p>
<ul>
<li><code>Object[] toArray()</code></li>
</ul>
<p>⑩ 获取集合对象的哈希值</p>
<ul>
<li><code>hashCode()</code></li>
</ul>
<p>①① 遍历</p>
<ul>
<li><code>iterator()</code>：返回迭代器对象，用于集合遍历</li>
</ul>
<hr>
<p><strong>Collection接口 总结</strong></p>
<p>一、Collection接口的子接口及其实现类<strong>通过什么方法来进行对象的比较</strong></p>
<ul>
<li>List接口通过重写 <strong>equals()方法</strong> 来比较对象</li>
<li>HashSet类通过重写 <strong>equals()</strong> 和 <strong>hashCode()</strong> 来比较对象</li>
<li>TreeSet类通过 自然排序(Comparable)的<strong>compareTo()</strong> 和 定制排序(Comparator)的**compare()**来比较对象</li>
</ul>
<h2 id="3-Iterator迭代器接口"><a href="#3-Iterator迭代器接口" class="headerlink" title="3. Iterator迭代器接口"></a>3. Iterator迭代器接口</h2><p>使用 <strong>Iterator</strong> 接口遍历集合元素</p>
<p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</p>
<p><strong>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</strong></p>
<p>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么<strong>所有实现了Collection接口的集合类都有一个iterator()方法</strong>，用以<strong>返回一个实现了 Iterator接口的对象</strong>。</p>
<p><strong>Iterator 仅用于遍历集合</strong>，Iterator <strong>本身并不提供承装对象的能力</strong>。如果需要创建Iterator 对象，则必须有一个被迭代的集合。</p>
<p><strong>集合对象每次调用iterator()方法都得到一个全新的迭代器对象</strong>，默认游标都在集合的第一个元素之前。</p>
<hr>
<p><strong>Iterator接口方法</strong></p>
<p>**hasNext()**： 用于检测当前游标指向的下一个位置有没有元素</p>
<p>**next()**： 将游标往下移一个位置，然后返回此位置的元素对象</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221229212204441.png" alt="image-20221229212204441"></p>
<hr>
<p><strong>迭代器的执行原理</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221229212315330.png" alt="image-20221229212315330"></p>
<blockquote>
<p>Iterator对象调用next()方法，指针下移，如果判断到有元素，则返回该位置的元素。</p>
</blockquote>
<hr>
<p><strong>Iterator接口remove()方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> coll.iterator();<span class="comment">//回到起点</span></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    <span class="comment">//iter.remover() --&gt; 错误位置</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    <span class="comment">//判断当前位置的元素是否为某元素</span></span><br><span class="line">	<span class="keyword">if</span>(obj.equals(<span class="string">&quot;Tom&quot;</span>))&#123;</span><br><span class="line">		iter.remove();</span><br><span class="line">         <span class="comment">//iter.remover() --&gt; 错误位置</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。</p>
<p>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报<code>IllegalStateException</code>。</p>
</blockquote>
<hr>
<p><strong>Iterator 总结</strong></p>
<ul>
<li>集合元素的遍历操作，使用迭代器Iterator接口</li>
<li>内部的方法：hasNext() 和  next()</li>
<li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</li>
<li>内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</li>
</ul>
<h3 id="3-1-foreach循环"><a href="#3-1-foreach循环" class="headerlink" title="3.1 foreach循环"></a>3.1 foreach循环</h3><p><strong>使用foreach循环遍历集合元素</strong></p>
<ul>
<li><p>foreach循环 又称 <strong>增强for循环</strong></p>
</li>
<li><p>Java 5.0 提供了 foreach 循环迭代访问 **Collection **和 <strong>数组</strong>。</p>
</li>
<li><p>遍历操作不需获取 Collection 或 数组 的长度，<strong>无需使用索引访问元素</strong>。</p>
</li>
<li><p>遍历集合的底层调用Iterator完成操作。</p>
</li>
<li><p>foreach还可以用来遍历数组。</p>
</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221229214141336.png" alt="image-20221229214141336"></p>
<blockquote>
<p>for(集合元素的类型 局部变量 : 集合对象)<br>内部仍然调用了迭代器。每次循环都将集合中的每一个元素赋给局部变量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习：判断输出结果如何</span></span><br><span class="line"><span class="comment">//由于是将数组str中的每一个元素赋给myStr，相当于创建了局部变量myStr，因此不会改变原来数组的元素对应的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">for</span> (String myStr : str) &#123;  </span><br><span class="line">			myStr = <span class="string">&quot;atguigu&quot;</span>;  	</span><br><span class="line">			System.out.println(myStr);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">			System.out.println(str[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-List接口"><a href="#4-List接口" class="headerlink" title="4. List接口"></a>4. List接口</h2><p><strong>List接口概述</strong></p>
<ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用<strong>List替代数组</strong></li>
<li>List集合类中<strong>元素有序、且可重复</strong>，集合中的每个元素都有其对应的顺序索引。</li>
<li>List容器中的<strong>元素都对应一个整数型的序号记载其在容器中的位置</strong>，可以根据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类常用的有：<strong>ArrayList</strong>、**LinkedList **和 <strong>Vector</strong>。</li>
</ul>
<hr>
<p><strong>List</strong>接口方法</p>
<p>List除了从Collection集合继承的方法外，List 集合里添加了一些<strong>根据索引来操作集合元素</strong>的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void add(int index, Object ele)</code></td>
<td>在<strong>index</strong>位置插入<strong>ele</strong>元素</td>
</tr>
<tr>
<td><code>boolean addAll(int index, Collection eles)</code></td>
<td>从<strong>index</strong>位置开始将<strong>eles</strong>中的所有元素添加进来</td>
</tr>
<tr>
<td><code>Object get(int index)</code></td>
<td>获取指定<strong>index</strong>位置的元素</td>
</tr>
<tr>
<td><code>int indexOf(Object obj)</code></td>
<td>返回<strong>obj</strong>在集合中首次出现的位置</td>
</tr>
<tr>
<td><code>int lastIndexOf(Object obj)</code></td>
<td>返回<strong>obj</strong>在当前集合中末次出现的位置</td>
</tr>
<tr>
<td><code>Object remove(int index)</code></td>
<td>移除指定<strong>index</strong>位置的元素，并返回此元素</td>
</tr>
<tr>
<td><code>Object set(int index, Object ele)</code></td>
<td>设置指定<strong>index</strong>位置的元素为<strong>ele</strong></td>
</tr>
<tr>
<td><code>List subList(int fromIndex, int toIndex)</code></td>
<td>返回从<strong>fromIndex</strong>到<strong>toIndex</strong></td>
</tr>
</tbody></table>
<h3 id="4-1-ArrayList"><a href="#4-1-ArrayList" class="headerlink" title="4.1 ArrayList"></a>4.1 ArrayList</h3><ul>
<li><p>ArrayList 是 List 接口的<strong>典型实现类、主要实现类</strong></p>
</li>
<li><p>本质上，ArrayList是对象引用的一个”变长”数组</p>
</li>
<li><p><strong>ArrayList</strong>的<strong>JDK1.8</strong>之前与之后的实现区别？</p>
<ul>
<li><p>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组</p>
</li>
<li><p>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</p>
</li>
</ul>
</li>
<li><p><code>Arrays.asList(…)</code> 方法返回的 List 集合，既不是 ArrayList 实例，也不是Vector 实例。 <code>Arrays.asList(…)</code> 返回值是一个固定长度的 List 集合</p>
</li>
</ul>
<h3 id="4-2-LinkedList"><a href="#4-2-LinkedList" class="headerlink" title="4.2 LinkedList"></a>4.2 LinkedList</h3><p>对于<strong>频繁的插入或删除元素</strong>的操作，建议使用LinkedList类，效率较高</p>
<p><strong>新增方法：</strong></p>
<ul>
<li><code>void addFirst(Object obj)</code></li>
<li><code>void addLast(Object obj)</code></li>
<li><code>Object getFirst()</code></li>
<li><code>Object getLast()</code></li>
<li><code>Object removeFirst()</code></li>
<li><code>Object removeLast()</code></li>
</ul>
<hr>
<p>LinkedList：<strong>双向链表</strong>，内部没有声明数组，而是定义了<strong>Node类型的 first 和 last</strong>， 用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量（用于存放其前后位置的引用地址）：</p>
<ul>
<li>prev变量记录前一个元素的位置</li>
<li>next变量记录下一个元素的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;  </span><br><span class="line">    E item;</span><br><span class="line">	Node&lt;E&gt; next;</span><br><span class="line">	Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">	Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">		<span class="built_in">this</span>.item = element;  </span><br><span class="line">        <span class="built_in">this</span>.next = next;  <span class="built_in">this</span>.prev = prev;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221229221424448.png" alt="image-20221229221424448"></p>
<h3 id="4-3-Vector"><a href="#4-3-Vector" class="headerlink" title="4.3 Vector"></a>4.3 Vector</h3><p>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</p>
<p>在各种list中，最好把ArrayList作为默认选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。</p>
<p><strong>新增方法：</strong></p>
<p><code>void addElement(Object obj)</code></p>
<p><code>void insertElementAt(Object obj,int index)</code></p>
<p><code>void setElementAt(Object obj,int index)</code></p>
<p><code>void removeElement(Object obj)</code></p>
<p><code>void removeAllElements()</code></p>
<hr>
<p><strong>List 总结</strong></p>
<blockquote>
<p>动态数组</p>
<p>ArrayList是List接口最典型的、使用最多的实现类，查找元素效率更高</p>
<p>LinkedList是在频繁插入或删除元素的操作，效率更高</p>
<p>Vector是线程安全的</p>
</blockquote>
<p><strong>一、面试题：</strong></p>
<p>① 请问ArrayList&#x2F;LinkedList&#x2F;Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?</p>
<p>② <strong>ArrayList和LinkedList的异同</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二者都线程不安全，相对线程安全的Vector，执行效率高。</span><br><span class="line"></span><br><span class="line">此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</span><br><span class="line">对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。</span><br><span class="line">对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据，而LinkedList只需要通过双向链表的两个变量就可是实现这些操作，无需对很多个元素进行处理</span><br></pre></td></tr></table></figure>

<p>③ <strong>ArrayList和Vector的区别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。</span><br><span class="line">（Collection中有一个方法可以将ArrayList转变成线程安全的）</span><br></pre></td></tr></table></figure>

<p><strong>二、List接口框架</strong></p>
<ul>
<li>List接口：存储有序的、可重复的数据。  –&gt;<strong>“动态”数组</strong>,替换原有的数组<ul>
<li>ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用<strong>Object[] elementData</strong>存储</li>
<li>LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用<strong>双向链表</strong>存储</li>
<li>Vector：作为List接口的古老实现类；<strong>线程安全的</strong>，效率低；底层使用<strong>Object[] elementData</strong>存储</li>
</ul>
</li>
</ul>
<p><strong>三、ArrayList源码分析</strong></p>
<p>① jdk 7情况下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//elementData[0] = new Integer(123);</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">11</span>);<span class="comment">//如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br><span class="line"><span class="comment">//默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</span></span><br></pre></td></tr></table></figure>

<p>结论：建议开发中使用带参的构造器：ArrayList list &#x3D; new ArrayList(int capacity)，指定要创建的数组初始长度</p>
<p>② jdk 8中ArrayList的变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层Object[] elementData初始化为&#123;&#125;.并没有创建长度为10的数组</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//后续的添加和扩容操作与jdk 7 无异。</span></span><br></pre></td></tr></table></figure>

<p>③ 小结：</p>
<ul>
<li>jdk7中的ArrayList的对象的创建类似于单例的饿汉式</li>
<li>jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存</li>
</ul>
<p><strong>四、LinkedList源码分析</strong></p>
<p>LinkedList list &#x3D; new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</p>
<p>list.add(123);&#x2F;&#x2F;将123封装到Node中，创建了Node对象。</p>
<p>其中，Node定义为：体现了LinkedList的双向链表的说法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">     E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">     <span class="built_in">this</span>.item = element;</span><br><span class="line">     <span class="built_in">this</span>.next = next;</span><br><span class="line">     <span class="built_in">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>五、Vector的源码分析</strong></p>
<p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来的数组长度的2倍。</p>
<p><strong>六、List接口的常用方法</strong></p>
<p>List接口在继承了接口的一些方法的同时，还新增了一些关于操作索引等的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">增：add(Object obj)</span><br><span class="line">删：remove(int index) / remove(Object obj)</span><br><span class="line">改：set(int index, Object ele)</span><br><span class="line">查：get(int index)</span><br><span class="line">插：add(int index, Object ele)</span><br><span class="line">长度：size()</span><br><span class="line">遍历：① Iterator迭代器方式</span><br><span class="line">     ② 增强for循环</span><br><span class="line">     ③ 普通的循环</span><br></pre></td></tr></table></figure>



<h2 id="5-Set接口"><a href="#5-Set接口" class="headerlink" title="5. Set接口"></a>5. Set接口</h2><p><strong>Set接口概述</strong></p>
<ul>
<li>Set接口是Collection的子接口，Set接口没有提供额外的方法</li>
<li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。</li>
<li>Set 判断两个对象是否相同不是使用 &#x3D;&#x3D; 运算符，而是根据 equals() 方法</li>
</ul>
<h3 id="5-1-HashSet"><a href="#5-1-HashSet" class="headerlink" title="5.1 HashSet"></a>5.1 HashSet</h3><ul>
<li><p>HashSet 是 Set 接口的典型实现，<strong>大多数时候使用 Set 集合时都使用这个实现类</strong>。</p>
</li>
<li><p>HashSet 按 <strong>Hash 算法</strong> 来存储集合中的元素，因此具有很好的存取、查找、删除性能。</p>
<blockquote>
<p>Hash 算法：通过算法计算其哈希值得出对应存放在集合中的位置，根据当前位置是否有元素，进行下一步判断分析</p>
</blockquote>
</li>
<li><p><strong>HashSet</strong> 具有以下特点：</p>
<ul>
<li><p>不能保证元素的排列顺序</p>
</li>
<li><p>HashSet 不是线程安全的</p>
</li>
<li><p>集合元素可以是 null</p>
</li>
</ul>
</li>
<li><p><strong>HashSet 集合判断两个元素相等的标准</strong>：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。</p>
</li>
<li><p>对于存放在Set容器中的对象，<strong>对应的类一定要重写equals()和hashCode(Object  obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。</strong></p>
</li>
</ul>
<hr>
<p><strong>向HashSet中添加元素的过程：</strong></p>
<p>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法 来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象 在 HashSet <strong>底层数组</strong>中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）</p>
<p>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了， 那么会通过<strong>链表的方式</strong>继续链接。</p>
<p>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。【当没有重写 hashCode() 时，调用父类Object中的hashCode()，此时随机分配一个hash值，大概率上不想等，而equals()却返回的是true】</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221229222914879.png" alt="image-20221229222914879"></p>
<hr>
<p><strong>重写 hashCode() 方法的基本原则</strong></p>
<ul>
<li>在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。</li>
<li>当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode()方法的返回值也应相等。</li>
<li>对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</li>
</ul>
<hr>
<p><strong>重写 equals() 方法的基本原则</strong></p>
<p>（以自定义的Customer类为例，何时需要重写equals()？）</p>
<ul>
<li>当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法， 它们仅仅是两个对象。</li>
<li>因此，违反了“<strong>相等的对象必须具有相等的散列码</strong>”。</li>
<li>结论：<strong>复写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算</strong></li>
</ul>
<hr>
<p><strong>拓展：Eclipse&#x2F;IDEA工具里hashCode()的重写</strong></p>
<p>以Eclipse&#x2F;IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。问题：<strong>为什么用Eclipse&#x2F;IDEA复写hashCode方法，有31这个数字？</strong></p>
<ul>
<li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</li>
<li>并且31只占用5bits,相乘造成数据溢出的概率较小。</li>
<li>31可以 由i*31&#x3D;&#x3D; (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）</li>
<li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结 果只能被素数本身和被乘数还有1来整除！(减少冲突)</li>
</ul>
<h3 id="5-2-LinkedHashSet"><a href="#5-2-LinkedHashSet" class="headerlink" title="5.2 LinkedHashSet"></a>5.2 LinkedHashSet</h3><ul>
<li>LinkedHashSet 是 HashSet 的子类</li>
<li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置， 但它同时使用双向链表维护元素的次序，这使得元素看起来是以<strong>插入顺序保存</strong>的。</li>
<li><strong>LinkedHashSet插入性能略低于 HashSet</strong>，但<strong>在迭代访问 Set 里的全部元素时有很好的性能。</strong></li>
<li>LinkedHashSet 不允许集合元素重复。</li>
</ul>
<hr>
<p><strong>LinkedHashSet底层结构</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221229223323023.png" alt="image-20221229223323023"></p>
<h3 id="5-3-TreeSet"><a href="#5-3-TreeSet" class="headerlink" title="5.3 TreeSet"></a>5.3 TreeSet</h3><ul>
<li>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。</li>
<li>TreeSet底层使用红黑树结构存储数据</li>
<li><strong>新增的方法如下： (了解)</strong><ul>
<li><code>Comparator comparator()</code></li>
<li><code>Object first()</code></li>
<li><code>Object last()</code></li>
<li><code>Object lower(Object e)</code></li>
<li><code>Object higher(Object e)</code></li>
<li><code>SortedSet subSet(fromElement, toElement)</code></li>
<li><code>SortedSet headSet(toElement)</code></li>
<li><code>SortedSet tailSet(fromElement)</code></li>
</ul>
</li>
<li>TreeSet 两种排序方法：自然排序和定制排序。<strong>默认情况下，TreeSet 采用自然排序。</strong></li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221229223501921.png" alt="image-20221229223501921"></p>
<h4 id="5-3-1-自然排序"><a href="#5-3-1-自然排序" class="headerlink" title="5.3.1 自然排序"></a>5.3.1 自然排序</h4><ul>
<li><strong>自然排序</strong>：TreeSet 会调用集合元素的 <code>compareTo(Object obj)</code> 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列</li>
<li><strong>如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable接口。</strong><ul>
<li>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。</li>
</ul>
</li>
<li>向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。</li>
<li><strong>因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同 一个类的对象。</strong></li>
<li>对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值。</li>
<li>当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果：<strong>如果两个对象通过 equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0</strong>。 否则，让人难以理解。</li>
</ul>
<h4 id="5-3-2-定制排序"><a href="#5-3-2-定制排序" class="headerlink" title="5.3.2 定制排序"></a>5.3.2 定制排序</h4><ul>
<li>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照 其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来 实现。需要重写compare(T o1, T o2)方法。</li>
<li>利用int compare(T o1, T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li>
<li>要实现定制排序，需要<strong>将实现Comparator接口的实例作为形参传递给TreeSet的构造器</strong>。</li>
<li>此时，<strong>仍然只能向TreeSet中添加类型相同的对象</strong>。否则发生ClassCastException异 常。</li>
<li>使用定制排序<strong>判断两个元素相等的标准</strong>是：通过Comparator比较两个元素返回了0。</li>
</ul>
<hr>
<p><strong>Set接口 总结</strong></p>
<blockquote>
<p>类比于高中学的“集合”</p>
<p>HashSet是Set接口最典型的实现类</p>
<p>LinkedList在迭代方面有更好的性能</p>
<p>TreeSet可以确保集合的元素处于排序状态，结合排序的两个接口实现</p>
</blockquote>
<p>一、<strong>Set：存储无序的、不可重复的数据</strong><br>以HashSet为例说明：</p>
<ol>
<li><p>无序性：不等于随机性。存储的数据在底层数组中<strong>并非按照数组索引的顺序</strong>添加，而是<strong>根据数据的哈希值</strong>决定的。</p>
</li>
<li><p>不可重复性：保证添加的元素按照equals()判断时，不能返回true。即：相同的元素只能添加一个。</p>
</li>
</ol>
<p>二、<strong>添加元素的过程：</strong></p>
<p>以HashSet为例：</p>
<p>我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：<br>        如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1<br>        如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：<br>            如果hash值不相同，则元素a添加成功。—&gt;情况2<br>            如果hash值相同，进而需要调用元素a所在类的equals()方法：<br>                   equals()返回true,元素a添加失败<br>                   equals()返回false,则元素a添加成功。—&gt;情况3</p>
<blockquote>
<p>对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</p>
<p>jdk 7 :元素a放到数组中，指向原来的元素。<br>jdk 8 :原来的元素在数组中，指向元素a<br>总结：七上八下</p>
<p>HashSet底层：数组+链表的结构。</p>
</blockquote>
<p>三、<strong>hashCode()与equals()的联系</strong>（以Set集合为例）：</p>
<ul>
<li>当两个对象的hash值不相等时，元素直接添加到集合；</li>
<li>当hash值相等时，调用对象所在类的equals()</li>
</ul>
<p><strong>四、LinkedHashSet的使用</strong></p>
<ul>
<li>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。</li>
<li>优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</li>
</ul>
<p><strong>五、TreeSet的使用</strong></p>
<ul>
<li>向TreeSet中添加的数据，要求是相同类的对象，此类还需是可比较的。</li>
<li>两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）<ul>
<li>自然排序中，调用一些方法（如：contains()）比较两个对象是否相同的标准为：compareTo()返回0，不再是equals()。</li>
<li>定制排序中，调用一些方法（如：contains()）比较两个对象是否相同的标准为：compare()返回0，不再是equals()。</li>
</ul>
</li>
</ul>
<p><strong>六、Set接口使用场景</strong></p>
<p>例题：在一个集合中已经有一些数据，再拿另外一些数据去跟集合中的数据去对比判断是否在其中。（Set接口和List接口的使用场景）</p>
<p>使用Set接口可以先通过计算哈希值直接定位到某个位置上，结合equals()便能快速比较出来结果；而使用List接口则需要拿每一个元素与集合中的每一个元素进行对比，效率较低</p>
<h2 id="6-Map接口"><a href="#6-Map接口" class="headerlink" title="6. Map接口"></a>6. Map接口</h2><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221230195400865.png" alt="image-20221230195400865"></p>
<p><strong>Map接口概述</strong></p>
<ul>
<li>Map与Collection并列存在。用于保存具有<strong>映射关系</strong>的数据:key-value</li>
<li>Map 中的 key 和 value 都可以是任何引用类型的数据</li>
<li>Map 中的 <strong>key 用Set来存放</strong>，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法常用String类作为Map的“键”</li>
<li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value</li>
<li>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和 Properties。其中，<strong>HashMap是 Map 接口使用频率最高的实现类</strong></li>
</ul>
<hr>
<p><strong>Map接口常用方法</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221230195548756.png" alt="image-20221230195548756"></p>
<h3 id="6-1-HashMap"><a href="#6-1-HashMap" class="headerlink" title="6.1 HashMap"></a>6.1 HashMap</h3><ul>
<li><p><strong>HashMap是 Map 接口使用频率最高的实现类。</strong></p>
</li>
<li><p>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</p>
</li>
<li><p>所有的key构成的集合是Set：无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()</p>
</li>
<li><p>所有的value构成的集合是Collection：无序的、可以重复的。所以，value所在的类要重写equals()</p>
</li>
<li><p>一个key-value构成一个entry</p>
</li>
<li><p>所有的entry构成的集合是Set：无序的、不可重复的</p>
</li>
<li><p>HashMap<strong>判断两个 key 相等的标准</strong>是：两个 key 通过 equals() 方法返回 true， hashCode 值也相等。</p>
</li>
<li><p>HashMap<strong>判断两个 value 相等的标准</strong>是：两个 value 通过 equals() 方法返回 true。</p>
</li>
</ul>
<h4 id="6-1-1-HashMap的存储结构"><a href="#6-1-1-HashMap的存储结构" class="headerlink" title="6.1.1 HashMap的存储结构"></a>6.1.1 HashMap的存储结构</h4><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221230195947299.png" alt="image-20221230195947299"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221230200008187.png" alt="image-20221230200008187"></p>
<hr>
<p><strong>HashMap源码中的重要常量</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221230200208488.png" alt="image-20221230200208488"></p>
<hr>
<p><strong>JDK1.8 之前</strong></p>
<ul>
<li><p>HashMap的内部存储结构其实是<strong>数组和链表</strong>的结合。当实例化一个HashMap时，  系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量 (Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个 bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
</li>
<li><p>每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引  用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。 而且<strong>新添加的元素作为链表的head。</strong></p>
</li>
<li><p><strong>添加元素的过程：</strong></p>
<p>向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据 key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上 已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次 比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果 hash值不同，继续比较二者是否equals。如果返回值为true，则使用entry1的value 去替换equals为true的entry的value。如果遍历一遍以后，发现所有的equals返回都 为false,则entry1仍可添加成功。entry1指向原有的entry元素。</p>
</li>
<li><p><strong>HashMap的扩容</strong></p>
<p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的 长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在 <strong>HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算 其在新数组中的位置，并放进去，这就是resize。</strong></p>
</li>
<li><p><strong>那么HashMap什么时候进行扩容呢？</strong></p>
<p>当HashMap 中的元素个数超过数组大小( 数组总大小length, 不是数组中个数 size)<em>loadFactor 时 ，就会进行数组扩容 ， loadFactor 的 默认值 (DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数 超过16</em>0.75&#x3D;12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把 数组的大小扩展为 2<em>16&#x3D;32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，*<em>所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</em></em></p>
</li>
</ul>
<hr>
<p><strong>JDK1.8之后</strong></p>
<ul>
<li><p>HashMap的内部存储结构其实是<strong>数组+链表+树</strong>的结合。当实例化一个 HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系 时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表 中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为 “桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
</li>
<li><p><strong>每个bucket中存储一个元素，即一个Node对象</strong>，但每一个Node对象可以带 一个引用变量next，用于指向下一个元素，因此，<strong>在一个桶中，就有可能 生成一个Node链。也可能是一个一个TreeNode对象</strong>，每一个TreeNode对象 可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个 TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</p>
</li>
<li><p><strong>那么HashMap什么时候进行扩容和树形化呢？</strong></p>
<ul>
<li><p>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数 size)*loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的 默 认 值 (DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认 情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中  元素个数超过16<em>0.75&#x3D;12（这个值就是代码中的threshold值，也叫做临界值）  的时候，就把数组的大小扩展为 2</em>16&#x3D;32，即扩大一倍，然后重新计算每个元 素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>
</li>
<li><p><strong>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有 达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成 树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后， 下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</strong></p>
</li>
</ul>
</li>
<li><p><strong>关于映射关系的key是否可以修改？answer：不要修改</strong></p>
<p>映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算 每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关 系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上</p>
</li>
</ul>
<hr>
<p><strong>总结：JDK1.8相较于之前的变化：</strong></p>
<ol>
<li><p>HashMap map &#x3D; new HashMap();&#x2F;&#x2F;默认情况下，先不创建长度为16的数组</p>
</li>
<li><p>当首次调用map.put()时，再创建长度为16的数组</p>
</li>
<li><p>数组为Node类型，在jdk7中称为Entry类型</p>
</li>
<li><p>形成链表结构时，新添加的key-value对在链表的尾部（七上八下）</p>
</li>
<li><p>当数组指定索引位置的链表长度&gt;8时，且map中的数组的长度&gt; 64时，此索引位置 上的所有key-value对使用红黑树进行存储。</p>
</li>
</ol>
<hr>
<p><strong>面试题：</strong></p>
<p>一、谈谈你对HashMap中put&#x2F;get方法的认识？如果了解再谈谈 HashMap的扩容机制？默认大小是多少？什么是负载因子( 或填充比)？什么是吞吐临界值(或阈值、threshold)？</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221230201340828.png" alt="image-20221230201340828"></p>
<p>二、为什么不是与List一样，往集合添加元素的时候，当超过了集合的容量，再进行扩容，而是超过了计算得出的扩容临界值就进行扩容？</p>
<p>threshold(扩容临界值) &#x3D; 集合当前的容量 * 负载因子(0.75)</p>
<p>因为当数据超过了集合的容量再来扩容的情况下，一方面可能导致集合中某一个位置上以链表形式存储的数据过多，从而容易超过8个元素转换成使用红黑树来存储，导致结构比较复杂；另一方面会导致集合的容量得不到充分的利用，添加元素操作时，可能由于Hash计算得出的不是空元素的位置，因为从占比概率上来讲比较小，所以容易计算得出是有元素的位置，然后一直以链表的形式在某位置存储。</p>
<h3 id="6-2-LinkedHashMap"><a href="#6-2-LinkedHashMap" class="headerlink" title="6.2 LinkedHashMap"></a>6.2 LinkedHashMap</h3><ul>
<li>LinkedHashMap 是 HashMap 的子类</li>
<li>在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序</li>
<li>与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代 顺序：迭代顺序与 Key-Value 对的插入顺序一致</li>
</ul>
<hr>
<p><strong>HashMap中的内部类：Node</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">	<span class="keyword">final</span> K key;</span><br><span class="line">	V value;  </span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LinkedHashMap中的内部类：Entry</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123; 			</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">	Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">		<span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-TreeMap"><a href="#6-3-TreeMap" class="headerlink" title="6.3 TreeMap"></a>6.3 TreeMap</h3><p>TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。</p>
<p>TreeMap 可以保证所有的 Key-Value 对处于有序状态。</p>
<p>TreeSet底层使用红黑树结构存储数据</p>
<p>TreeMap 的 Key 的排序：</p>
<p><strong>自然排序</strong>：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有 的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException</p>
<p><strong>定制排序</strong>：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口</p>
<p>TreeMap判断<strong>两个key相等的标准</strong>：两个key通过compareTo()方法或者compare()方法返回0。</p>
<h3 id="6-4-Hashtable"><a href="#6-4-Hashtable" class="headerlink" title="6.4 Hashtable"></a>6.4 Hashtable</h3><ul>
<li><p>Hashtable是个古老的 Map 实现类，JDK1.0就提供了。不同于HashMap，</p>
</li>
<li><p>Hashtable是线程安全的。</p>
</li>
<li><p>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</p>
</li>
<li><p>与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value</p>
</li>
<li><p>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序</p>
</li>
<li><p>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</p>
</li>
</ul>
<h3 id="6-5-Properties"><a href="#6-5-Properties" class="headerlink" title="6.5 Properties"></a>6.5 Properties</h3><p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件</p>
<p>由于属性文件里的 key、value 都是字符串类型，所以 <strong>Properties 里的 key和 value 都是字符串类型</strong></p>
<p>存取数据时，建议使用<code>setProperty(String key,String value)</code>方法和<code>getProperty(String key)</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pros.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>));  </span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>); System.out.println(user);</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>Map 总结</strong></p>
<blockquote>
<p>类似于高中的函数：y &#x3D; f(x)</p>
<p>HashMap：Map接口最典型的实现类，使用最多</p>
<p>LinkedHashMap：HashMap的子类，便于迭代遍历Map集合</p>
<p>TreeMap：保证所有的 Key-Value 对处于有序状态。</p>
<p>Properties：处理属性配置文件</p>
</blockquote>
<p><strong>一、Map的实现类的结构：</strong></p>
<ul>
<li><strong>Map</strong>:双列数据，存储key-value对的数据  <ul>
<li><strong>HashMap</strong>:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value<ul>
<li><strong>LinkedHashMap</strong>:保证在遍历map元素时，可以按照添加的顺序实现遍历。原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。</li>
</ul>
</li>
<li><strong>TreeMap</strong>:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序。底层使用红黑树</li>
<li><strong>Hashtable</strong>:作为古老的实现类；线程安全的，效率低；不能存储null的key和value<ul>
<li><strong>Properties</strong>:常用来处理配置文件。key和value都是String类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>HashMap的底层：数组+链表  （jdk7及之前）</p>
<p>数组+链表+红黑树 （jdk 8）</p>
<p><strong>二、Map结构的理解：</strong></p>
<ul>
<li><p>Map中的<strong>key</strong>:无序的、不可重复的，使用Set存储所有的key  —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）</p>
</li>
<li><p>Map中的<strong>value</strong>:无序的、可重复的，使用Collection存储所有的value —&gt;value所在的类要重写equals()</p>
</li>
<li><p>Map中的<strong>entry</strong>:无序的、不可重复的，使用Set存储所有的entry（一个键值对：key-value构成了一个Entry对象。）</p>
<blockquote>
<p>Entry是Map中的一个内部类</p>
</blockquote>
</li>
</ul>
<p><strong>三、HashMap的底层实现原理？</strong></p>
<p> ① 以jdk7为例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>():</span><br><span class="line">在实例化以后，底层创建了长度是<span class="number">16</span>的一维数组Entry[] table。</span><br><span class="line"></span><br><span class="line">...可能已经执行过多次put...</span><br><span class="line">map.put(key1,value1):</span><br></pre></td></tr></table></figure>

<p>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</p>
<ul>
<li><p>如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1</p>
</li>
<li><p>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：</p>
<ul>
<li><p>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。–情况2</p>
</li>
<li><p>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：</p>
<ul>
<li>如果equals()返回false:此时key1-value1添加成功。—-情况3</li>
<li>如果equals()返回true:使用value1替换value2。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</p>
<p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p>
<p><strong>jdk8 相较于jdk7在底层实现方面的不同：</strong></p>
<ul>
<li>new HashMap():底层没有创建一个长度为16的数组</li>
<li>jdk 8底层的数组是：Node[],而非Entry[]</li>
<li>首次调用put()方法时，底层创建长度为16的数组</li>
<li>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。<ul>
<li>形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）	</li>
<li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</li>
</ul>
<ul>
<li><pre><code> DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
</code></pre>
</li>
<li><pre><code> threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12
</code></pre>
</li>
<li><pre><code> TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
</code></pre>
</li>
<li><pre><code> MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64
</code></pre>
</li>
</ul>
<p><strong>四、LinkedHashMap的底层实现原理（了解）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码中：</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">     Entry&lt;K,V&gt; before, after;<span class="comment">//能够记录添加的元素的先后顺序</span></span><br><span class="line">     Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>五、Map中定义的方法：</strong></p>
<p>① 添加、删除、修改操作：</p>
<p>Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</p>
<p>void putAll(Map m)：将m中的所有key-value对存放到当前map中</p>
<p>Object remove(Object key)：移除指定key的key-value对，并返回value，如果key不存在则返回null</p>
<p>void clear()：清空当前map中的所有数据，不等同于map &#x3D; null操作</p>
<p>② 元素查询的操作：</p>
<p>Object get(Object key)：获取指定key对应的value</p>
<p>boolean containsKey(Object key)：是否包含指定的key</p>
<p>boolean containsValue(Object value)：是否包含指定的value</p>
<p>int size()：返回map中key-value对的个数</p>
<p>boolean isEmpty()：判断当前map是否为空</p>
<p>boolean equals(Object obj)：判断当前map和参数对象obj是否相等</p>
<p>③ 元视图操作的方法：</p>
<p>Set keySet()：返回所有key构成的Set集合</p>
<p>Collection values()：返回所有value构成的Collection集合</p>
<p>Set entrySet()：返回所有key-value对构成的Set集合</p>
<p>④ 常用方法归纳：</p>
<ul>
<li>添加：put(Object key,Object value)</li>
<li>删除：remove(Object key)</li>
<li>修改：put(Object key,Object value)</li>
<li>查询：get(Object key)</li>
<li>长度：size()</li>
<li>遍历：keySet() &#x2F; values() &#x2F; entrySet()</li>
</ul>
<h2 id="7-Collections工具类"><a href="#7-Collections工具类" class="headerlink" title="7. Collections工具类"></a>7. Collections工具类</h2><ul>
<li>Collections 是一个操作 Set、List 和 Map 等集合的工具类</li>
<li>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</li>
</ul>
<hr>
<p><strong>排序操作：（均为static方法）</strong></p>
<ul>
<li><code>reverse(List)</code>：反转 List 中元素的顺序</li>
<li><code>shuffle(List)</code>：对 List 集合元素进行随机排序</li>
<li><code>sort(List)</code>：根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li><code>sort(List，Comparator)</code>：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li><code>swap(List，int， int)</code>：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ul>
<hr>
<p><strong>Collections常用方法</strong></p>
<p>① <strong>查找、替换</strong></p>
<ul>
<li><code>Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</li>
<li><code>Object max(Collection，Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li>
<li><code>Object min(Collection)</code></li>
<li><code>Object min(Collection，Comparator)</code></li>
<li><code>int frequency(Collection，Object)</code>：返回指定集合中指定元素的出现次数</li>
<li><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中</li>
<li><code>boolean replaceAll(List list，Object oldVal，Object newVal)</code>：使用新值替换 List 对象的所有旧值</li>
</ul>
<p>② <strong>同步控制</strong></p>
<p>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集 合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全 问题</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221230203952855.png" alt="image-20221230203952855"></p>
<hr>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20221230204251324.png" alt="image-20221230204251324"></p>
<hr>
<p><strong>Collections 总结</strong></p>
<p><code>reverse(List)</code>：反转 List 中元素的顺序</p>
<p><code>shuffle(List)</code>：对 List 集合元素进行随机排序</p>
<p><code>sort(List)</code>：根据元素的自然顺序对指定 List 集合元素按升序排序</p>
<p><code>sort(List，Comparator)</code>：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</p>
<p><code>swap(List，int，int)</code>：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p>
<p><code>Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</p>
<p><code>Object max(Collection，Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</p>
<p><code>Object min(Collection)</code></p>
<p><code>Object min(Collection，Comparator)</code></p>
<p><code>int frequency(Collection，Object)</code>：返回指定集合中指定元素的出现次数</p>
<p><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中</p>
<p><code>boolean replaceAll(List list，Object oldVal，Object newVal)</code>：使用新值替换 List 对象的所有旧值</p>
<hr>
<blockquote>
<p>补充：Collections 类中提供了多个 synchronizedXxx() 方法，<br>该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</p>
</blockquote>
<h1 id="第十一章-gt-gt-gt-泛型"><a href="#第十一章-gt-gt-gt-泛型" class="headerlink" title="第十一章&gt;&gt;&gt;泛型"></a>第十一章&gt;&gt;&gt;泛型</h1><h2 id="1-泛型的概述"><a href="#1-泛型的概述" class="headerlink" title="1. 泛型的概述"></a>1. 泛型的概述</h2><p><strong>泛型：标签</strong></p>
<hr>
<p><strong>举例：</strong></p>
<ul>
<li>中药店，每个抽屉外面贴着标签</li>
<li>超市购物架上很多瓶子，每个瓶子装的是什么，有标签</li>
</ul>
<hr>
<p><strong>泛型的设计背景</strong></p>
<p>集合容器类在设计阶段&#x2F;声明阶段不能确定这个容器到底实际存的是什么类型的 对象，所以在<strong>JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决</strong>。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于 这个元素如何保存，如何管理等是确定的，因此此时<strong>把元素的类型设计成一个 参数，这个类型参数叫做泛型</strong>。Collection<E>，List<E>，ArrayList<E> 这个<E>就 是类型参数，即泛型。</p>
<hr>
<p><strong>泛型的概念</strong></p>
<p><strong>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类 型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如， 继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实 际的类型参数，也称为类型实参）。</strong></p>
<p>从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，  允许我们在创建集合时再指定集合元素的类型，正如：List<String>，这表明 该List只能保存字符串类型的对象。</p>
<p>JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持， 从而可以在声明集合变量、创建集合对象时传入类型实参。</p>
<hr>
<p>那么为什么要有泛型呢，直接<strong>Object</strong>不是也可以存储数据吗？</p>
<ol>
<li><p>解决<strong>元素存储的安全性</strong>问题，好比商品、药品标签，不会弄错。</p>
</li>
<li><p>解决获取数据元素时，需要<strong>类型强制转换</strong>的问题，好比不用每回拿商品、药 品都要辨别。</p>
</li>
</ol>
<blockquote>
<p>如下是在集合中没有泛型的情况</p>
</blockquote>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230104114646968.png" alt="image-20230104114646968"></p>
<blockquote>
<p>如下是在集合中有泛型的情况</p>
</blockquote>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230104120611020.png" alt="image-20230104120611020"></p>
<blockquote>
<p>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。</p>
</blockquote>
<h2 id="2-在集合中使用泛型"><a href="#2-在集合中使用泛型" class="headerlink" title="2. 在集合中使用泛型"></a>2. 在集合中使用泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line">list.add(<span class="number">78</span>);</span><br><span class="line">list.add(<span class="number">88</span>);</span><br><span class="line">list.add(<span class="number">77</span>);</span><br><span class="line">list.add(<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历方式一：</span></span><br><span class="line"><span class="comment">//for(Integer i : list)&#123;</span></span><br><span class="line"><span class="comment">//不需要强转</span></span><br><span class="line">	<span class="comment">//System.out.println(i);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历方式二：</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;Tom1&quot;</span>,<span class="number">34</span>);</span><br><span class="line">map.put(<span class="string">&quot;Tom2&quot;</span>,<span class="number">44</span>);</span><br><span class="line">map.put(<span class="string">&quot;Tom3&quot;</span>,<span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">&quot;Tom4&quot;</span>,<span class="number">32</span>);</span><br><span class="line"><span class="comment">//添加失败</span></span><br><span class="line"><span class="comment">//map.put(33, &quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">Set&lt;Entry&lt;String,Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">Iterator&lt;Entry&lt;String,Integer&gt;&gt; iterator =	entrySet.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">	Entry&lt;String,Integer&gt; entry = iterator.next();</span><br><span class="line">	System.out.println(entry.getKey() + <span class="string">&quot;---&gt;&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-自定义泛型结构"><a href="#3-自定义泛型结构" class="headerlink" title="3. 自定义泛型结构"></a>3. 自定义泛型结构</h2><p><strong>泛型的声明</strong></p>
<p>interface List<T> 和 class GenTest&lt;K,V&gt;</p>
<p>其中，T,K,V不代表值，而是表示类型。这里使用任意字母都可以。常用T表示，是Type的缩写。</p>
<hr>
<p><strong>泛型的实例化</strong>：</p>
<p>一定要在类名后面指定类型参数的值（类型）。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); Iterator&lt;Customer&gt; iterator = customers.iterator();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>T只能是类，不能用基本数据类型填充。但可以使用包装类填充</strong></p>
<p>把一个集合中的内容限制为一个特定的数据类型，这就是<strong>generics</strong>背后的核心思想</p>
</blockquote>
<hr>
<ol>
<li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</p>
</li>
<li><p>泛型类的构造器如下：<code>public GenericClass()&#123;&#125;</code>。</p>
</li>
</ol>
<ul>
<li>而下面是错误的：<code>public GenericClass&lt;E&gt;()&#123;&#125;</code></li>
</ul>
<ol start="3">
<li><p>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</p>
</li>
<li><p>泛型不同的引用不能相互赋值。</p>
</li>
</ol>
<ul>
<li>尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。</li>
</ul>
<ol start="5">
<li>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价 于Object。</li>
</ol>
<ul>
<li>经验：泛型要使用一路都用。要不用，一路都不要用。</li>
</ul>
<ol start="6">
<li><p>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。</p>
</li>
<li><p>jdk1.7，泛型的简化操作：ArrayList<Fruit> flist &#x3D; new ArrayList&lt;&gt;();</p>
</li>
<li><p>泛型的指定中不能使用基本数据类型，可以使用包装类替换。</p>
</li>
<li><p>在类&#x2F;接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态 属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但<strong>在静态方法 中不能使用类的泛型</strong>(因为泛型是类实例化对象的时候指明的)。</p>
</li>
<li><p>异常类不能是泛型的</p>
</li>
<li><p>不能使用new E[]。但是可以：E[] elements &#x3D; (E[])new Object[capacity];</p>
</li>
</ol>
<ul>
<li>参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</li>
</ul>
<ol start="12">
<li><p>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：</p>
<ul>
<li><p>子类不保留父类的泛型：按需实现</p>
<ul>
<li><p>没有类型 擦除</p>
</li>
<li><p>具体类型</p>
</li>
</ul>
</li>
<li><p>子类保留父类的泛型：泛型子类</p>
<ul>
<li><p>全部保留</p>
</li>
<li><p>部分保留</p>
</li>
</ul>
</li>
</ul>
<p>结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;<span class="comment">// 等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;<span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-1-泛型类"><a href="#3-1-泛型类" class="headerlink" title="3.1 泛型类"></a>3.1 泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用T类型定义变量</span></span><br><span class="line">    <span class="keyword">private</span> T info;</span><br><span class="line">    <span class="comment">// 使用T类型定义一般方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(T info)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用T类型定义构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(T info)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// static的方法中不能声明泛型</span></span><br><span class="line">    <span class="comment">//public static void show(T t) &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不能在try-catch中使用泛型定义</span></span><br><span class="line">    <span class="comment">//public void test() &#123;</span></span><br><span class="line">        <span class="comment">//try &#123;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//&#125; catch (MyException&lt;T&gt; ex) &#123;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-泛型方法"><a href="#3-2-泛型方法" class="headerlink" title="3.2 泛型方法"></a>3.2 泛型方法</h3><ul>
<li><p>方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型 方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。</p>
</li>
<li><p>泛型方法的格式：</p>
<p><strong>[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常</strong></p>
</li>
<li><p>泛型方法声明泛型时也可以指定上限(在12.5中讲)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DAO</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> &lt;E&gt; E <span class="title function_">get</span><span class="params">(<span class="type">int</span> id, E e)</span> &#123;</span><br><span class="line">		<span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-泛型在继承上的体现"><a href="#4-泛型在继承上的体现" class="headerlink" title="4. 泛型在继承上的体现"></a>4. 泛型在继承上的体现</h2><p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G<B>并不是G<A>的子类型！</p>
<p>比如：String是Object的子类，但是List<String >并不是List<Object>的子类。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230104171228704.png" alt="image-20230104171228704"></p>
<p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，B<G>是A<G>的子类型！</p>
<p>比如：LinkedHashMap是HashMap的子类，则LinkedHashMap<String>仍然是HashMap<String>的子类</p>
<h2 id="5-通配符的使用"><a href="#5-通配符的使用" class="headerlink" title="5. 通配符的使用"></a>5. 通配符的使用</h2><ol>
<li><p>使用类型<strong>通配符：？</strong></p>
<ul>
<li><p>比如：List<?> ，Map<?,?></p>
</li>
<li><p>List&lt;?&gt;是List<String>、List<Object>等各种泛型List的父类。</p>
</li>
</ul>
</li>
<li><p><strong>读取</strong>List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管list的真实类型 是什么，它包含的都是Object。</p>
</li>
<li><p><strong>写入</strong>list中的元素时，不行。因为我们不知道c的元素类型，我们不能向其中 添加对象。</p>
<ul>
<li>唯一的例外是null，它是所有类型的成员。</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong>将任意元素加入到其中不是类型安全的</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;?&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  </span><br><span class="line"></span><br><span class="line">c.add(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 编译时错误</span></span><br></pre></td></tr></table></figure>

<p>因为我们不知道c的元素类型，我们不能向其中添加对象。add方法有类型参数E作为集 合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去。</p>
<ul>
<li><strong>唯一的例外的是null，它是所有类型的成员。</strong></li>
<li><strong>另一方面，我们可以调用get()方法并使用其返回值。返回值是一个未知的 类型，但是我们知道，它总是一个Object。</strong></li>
</ul>
<hr>
<p><strong>注意点：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;?&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点2：编译错误：不能用在泛型类的声明上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericTypeClass</span>&lt;?&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象  ArrayList&lt;?&gt; list2 = new ArrayList&lt;?&gt;();</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>有限制的通配符</strong></p>
<ul>
<li><p><strong>&lt;?&gt;</strong></p>
<p>允许所有泛型的引用调用</p>
</li>
<li><p>通配符指定上限</p>
<p>上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;&#x3D;</p>
</li>
<li><p>通配符指定下限</p>
<p>下限super：使用时指定的类型不能小于操作的类，即&gt;&#x3D;</p>
</li>
<li><p>举例：</p>
<ul>
<li><p><strong>&lt;? extends Number&gt; (无穷小 , Number]</strong></p>
<p>只允许泛型为Number及Number子类的引用调用</p>
</li>
<li><p><strong>&lt;?** **super** **Number&gt; [Number</strong> <strong>,</strong> 无穷大**)**</p>
<p>只允许泛型为Number及Number父类的引用调用</p>
</li>
<li><p><strong>&lt;?** **extends** **Comparable&gt;</strong></p>
<p>只允许泛型为实现Comparable接口的实现类的引用调用</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>泛型 总结</strong></p>
<blockquote>
<p>用于指明一个容器里面可以存放的元素类型，</p>
<p>泛型类：实例化泛型类的时候指明</p>
<p>泛型方法：泛型参数是在调用方法时确定的。并非在实例化类时确定。</p>
<p>泛型不同的引用不能相互赋值。</p>
</blockquote>
<p><strong>一、在集合中使用泛型</strong></p>
<p>① 集合接口或集合类在jdk5.0时都修改为带泛型的结构。</p>
<p>② 在实例化集合类时，可以指明具体的泛型类型</p>
<p>③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。比如：add(E e)  —&gt;实例化以后：add(Integer e)</p>
<p>④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</p>
<p>⑤ 如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。</p>
<p><strong>二、泛型类与泛型方法</strong></p>
<p>① 泛型类：</p>
<ul>
<li>静态方法中不能使用类的泛型。</li>
<li>如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型</li>
<li>由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。</li>
</ul>
<p>② 泛型方法：</p>
<ul>
<li>在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。</li>
<li>换句话说，泛型方法所属的类是不是泛型类都没有关系。</li>
<li>泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</li>
</ul>
<p><strong>三、泛型在继承方面的体现</strong></p>
<p>虽然类A是类B的父类，但是G<A> 和G<B>二者不具备子父类关系，二者是并列关系。</p>
<blockquote>
<p>补充：类A是类B的父类，A<G> 是 B<G> 的父类</p>
</blockquote>
<p><strong>四、通配符的使用</strong></p>
<p>① 通配符：?</p>
<ul>
<li>类A是类B的父类，G<A>和G<B>是没有关系的，二者共同的父类是：G&lt;?&gt;</li>
<li>添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。（除了添加null之外。）</li>
<li>获取(读取)：允许读取数据，读取的数据类型为Object。</li>
</ul>
<p>② 有限制条件的通配符</p>
<ul>
<li><p><strong>? extends A:</strong><br>G&lt;? extends A&gt; 可以作为G<A>和G<B>的父类，其中B是A的子类</p>
</li>
<li><p><strong>? super A</strong>:<br>G&lt;? super A&gt; 可以作为G<A>和G<B>的父类，其中B是A的父类</p>
</li>
</ul>
<h1 id="第十二章-gt-gt-gt-IO流"><a href="#第十二章-gt-gt-gt-IO流" class="headerlink" title="第十二章&gt;&gt;&gt;IO流"></a>第十二章&gt;&gt;&gt;IO流</h1><h2 id="1-File类的使用"><a href="#1-File类的使用" class="headerlink" title="1. File类的使用"></a>1. File类的使用</h2><ul>
<li>java.io.File类：<strong>文件和文件目录路径</strong>的抽象表示形式，与平台无关</li>
<li>File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。</li>
<li><strong>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对 象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</strong></li>
<li>File对象可以作为参数传递给流的构造器</li>
</ul>
<hr>
<p><strong>常用构造器</strong></p>
<p>① <strong>public</strong> <strong>File(String</strong> <strong>pathname)</strong></p>
<p>以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。</p>
<ul>
<li>绝对路径：是一个固定的路径,从盘符开始</li>
<li>相对路径：是相对于某个位置开始</li>
</ul>
<p>② <strong>public</strong> <strong>File(String</strong> <strong>parent,String</strong> <strong>child)</strong></p>
<p>以parent为父路径，child为子路径创建File对象。</p>
<p>③ <strong>public</strong> <strong>File(File</strong> <strong>parent,String</strong> <strong>child)</strong></p>
<p>根据一个父File对象和子文件路径创建File对象</p>
<hr>
<ul>
<li><p>路径中的每级目录之间用一个路径分隔符隔开。</p>
</li>
<li><p>路径分隔符和系统有关：</p>
<ul>
<li>windows和DOS系统默认使用“\”来表示</li>
<li>UNIX和URL使用“&#x2F;”来表示</li>
</ul>
</li>
<li><p>Java程序支持跨平台运行，因此路径分隔符要慎用。</p>
</li>
<li><p>为了解决这个隐患，File类提供了一个常量：</p>
<ul>
<li><strong>public</strong> <strong>static</strong> <strong>final</strong> <strong>String</strong> <strong>separator</strong>。根据操作系统，动态的提供分隔符。</li>
</ul>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\atguigu\\info.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;atguigu&quot;</span> + File.separator + <span class="string">&quot;info.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/atguigu&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>① <strong>File类的获取功能</strong></p>
<p><code>public String getAbsolutePath()</code>：获取绝对路径</p>
<p><code>public String getPath()</code> ：获取路径</p>
<p><code>public String getName()</code> ：获取名称</p>
<p><code>public String getParent()</code>：获取上层文件目录路径。若无，返回null</p>
<p><code>public long length()</code> ：获取文件长度（即：字节数）。不能获取目录的长度。</p>
<p><code>public long lastModified()</code> ：获取最后一次的修改时间，毫秒值</p>
<p><code>public String[] list()</code> ：获取指定目录下的所有文件或者文件目录的名称数组</p>
<p><code>public File[] listFiles()</code> ：获取指定目录下的所有文件或者文件目录的File数组</p>
<p>② <strong>File类的重命名功能</strong></p>
<p><code>public boolean renameTo(File dest)</code>:把文件重命名为指定的文件路径</p>
<p>③ <strong>File类的判断功能</strong></p>
<p><code>public boolean isDirectory()</code>：判断是否是文件目录</p>
<p><code>public boolean isFile()</code> ：判断是否是文件</p>
<p><code>public boolean exists()</code> ：判断是否存在</p>
<p><code>public boolean canRead()</code> ：判断是否可读</p>
<p><code>public boolean canWrite()</code> ：判断是否可写</p>
<p><code>public boolean isHidden()</code> ：判断是否隐藏</p>
<p>④ <strong>File类的创建功能</strong></p>
<p><code>public boolean createNewFile()</code> ：创建文件。若文件存在，则不创建，返回false</p>
<p><code>public boolean mkdir()</code> ：创建文件目录。如果此文件目录存在，就不创建了。 如果此文件目录的上层目录不存在，也不创建。</p>
<p><code>public boolean mkdirs()</code> ：创建文件目录。如果上层文件目录不存在，一并创建</p>
<blockquote>
<p>注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下。</p>
</blockquote>
<p>⑤ <strong>File类的删除功能</strong></p>
<p><code>public boolean delete()</code>：删除文件或者文件夹</p>
<blockquote>
<p>Java中的删除不走回收站。</p>
<p>要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录</p>
</blockquote>
<h2 id="2-IO流原理及流的分类"><a href="#2-IO流原理及流的分类" class="headerlink" title="2. IO流原理及流的分类"></a>2. IO流原理及流的分类</h2><p><strong>Java</strong> <strong>IO</strong>原理</p>
<ul>
<li>I&#x2F;O是Input&#x2F;Output的缩写， I&#x2F;O技术是非常实用的技术，用于<strong>处理设备之间的数据传输</strong>。如读&#x2F;写文件，网络通讯等。</li>
<li>Java程序中，对于数据的输入&#x2F;输出操作以“**流(stream)**” 的方式进行。</li>
<li>java.io包下提供了各种“流”类和接口，用以获取不同种类的 数据，并通过<strong>标准的方法</strong>输入或输出数据。</li>
</ul>
<hr>
<p>输入<strong>input</strong>：读取外部数据（磁 盘、光盘等存储设备的数据）到 程序（内存）中。</p>
<p>输出<strong>output</strong>：将程序（内存）  数据输出到磁盘、光盘等存储设 备中。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230105183125631.png" alt="image-20230105183125631"></p>
<hr>
<p><strong>流的分类</strong></p>
<ul>
<li>按操作数据单位不同分为：字节流**(8** <strong>bit)<strong>，字符流</strong>(16</strong> <strong>bit)</strong></li>
<li>按数据流的流向不同分为：输入流，输出流</li>
<li>按流的角色的不同分为：节点流，处理流</li>
</ul>
<blockquote>
<p>Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。</p>
<p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>(<strong>抽象基类</strong>)</strong></th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td><strong>InputStream</strong></td>
<td><strong>Reader</strong></td>
</tr>
<tr>
<td>输出流</td>
<td><strong>OutputStream</strong></td>
<td><strong>Writer</strong></td>
</tr>
</tbody></table>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230105183406158.png" alt="image-20230105183406158"></p>
<hr>
<p><strong>IO流体系</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230105183529177.png" alt="image-20230105183529177"></p>
<hr>
<p><strong>节点流和处理流</strong></p>
<p>① 节点流：直接从数据源或目的地读写数据</p>
<p>② 处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提 供更为强大的读写功能。</p>
<blockquote>
<p>处理流不一定包在节点流上，也可以是包在其他处理流上</p>
</blockquote>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230105183919678.png" alt="image-20230105183919678"></p>
<h3 id="2-1-InputStream-amp-Reader"><a href="#2-1-InputStream-amp-Reader" class="headerlink" title="2.1 InputStream &amp; Reader"></a>2.1 InputStream &amp; Reader</h3><ul>
<li><p>InputStream 和 Reader 是所有输入流的基类。</p>
</li>
<li><p>InputStream（典型实现：<strong>FileInputStream</strong>）</p>
<ul>
<li>int read()</li>
<li><strong>int</strong> <strong>read(byte[]</strong> <strong>b)</strong></li>
<li>int read(byte[] b, int off, int len)</li>
</ul>
</li>
<li><p>Reader（典型实现：<strong>FileReader</strong>）</p>
<ul>
<li>int read()</li>
<li><strong>int</strong> <strong>read(char</strong> <strong>[]</strong> <strong>c)</strong></li>
<li>int read(char [] c, int off, int len)</li>
</ul>
</li>
<li><p>程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该<strong>显式关闭文件 IO 资源。</strong></p>
</li>
<li><p>FileInputStream 从文件系统中的某个文件中获得输入字节。</p>
<p>FileInputStream用于读取非文本数据之类的原始字节流。</p>
<p>要读取字符流，需要使用 FileReader</p>
</li>
</ul>
<h4 id="2-1-1-InputStream"><a href="#2-1-1-InputStream" class="headerlink" title="2.1.1 InputStream"></a>2.1.1 InputStream</h4><ul>
<li><p><strong>int</strong> <strong>read()</strong></p>
<p>从输入流中读取数据的下一个字节。返回 0 到 255 范围内的int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。</p>
</li>
<li><p><strong>int</strong> <strong>read(byte[]</strong> <strong>b)</strong></p>
<p>从此输入流中将最多 b.length 个字节的数据读入一个 byte  数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则<strong>以整数形式返回实际读取的字节数。</strong></p>
</li>
<li><p><strong>int</strong> <strong>read(byte[]</strong> <strong>b,</strong> <strong>int</strong> <strong>off,int</strong> <strong>len)</strong></p>
<p>将输入流中最多 len 个数据字节读入 byte  数组。尝试读取 len  个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值-1。</p>
</li>
<li><p><strong>public</strong> <strong>void</strong> <strong>close()</strong> <strong>throws</strong> <strong>IOException</strong></p>
<p>关闭此输入流并释放与该流关联的所有系统资源。</p>
</li>
</ul>
<h4 id="2-1-2-Reader"><a href="#2-1-2-Reader" class="headerlink" title="2.1.2 Reader"></a>2.1.2 Reader</h4><ul>
<li><p><strong>int</strong> <strong>read()</strong></p>
<p>读取单个字符。作为整数读取的字符，范围在 0  到 65535  之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1</p>
</li>
<li><p><strong>int</strong> <strong>read(char[]</strong> <strong>cbuf)</strong></p>
<p>将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</p>
</li>
<li><p><strong>int</strong> <strong>read(char[]</strong> <strong>cbuf,int</strong> <strong>off,int</strong> <strong>len)</strong></p>
<p>将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字 符。如果已到达流的末尾，则返回-1。否则返回本次读取的字符数。</p>
</li>
<li><p><strong>public</strong> <strong>void</strong> <strong>close()</strong> <strong>throws</strong> <strong>IOException</strong></p>
<p>关闭此输入流并释放与该流关联的所有系统资源。</p>
</li>
</ul>
<h3 id="2-2-OutputStream-amp-Writer"><a href="#2-2-OutputStream-amp-Writer" class="headerlink" title="2.2 OutputStream &amp; Writer"></a>2.2 OutputStream &amp; Writer</h3><ul>
<li><p>OutputStream 和 Writer 也非常相似：</p>
<ul>
<li><strong>void write(int b&#x2F;int c);</strong></li>
<li><strong>void write(byte[] b&#x2F;char[] cbuf);</strong></li>
<li><strong>void write(byte[] b&#x2F;char[] buff, int off, int len);</strong></li>
<li><strong>void</strong> <strong>flush();</strong></li>
<li><strong>void</strong> <strong>close();</strong> 需要先刷新，再关闭此流</li>
</ul>
</li>
<li><p>因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，  即以 String 对象作为参数</p>
<ul>
<li><strong>void</strong> <strong>write(String</strong> <strong>str);</strong></li>
<li><strong>void</strong> <strong>write(String</strong> <strong>str,</strong> <strong>int</strong> <strong>off,</strong> <strong>int</strong> <strong>len);</strong></li>
</ul>
</li>
<li><p>FileOutputStream 从文件系统中的某个文件中获得输出字节。</p>
<p>FileOutputStream 用于写出非文本数据之类的原始字节流。</p>
<p>要写出字符流，需要使用 FileWriter</p>
</li>
</ul>
<h4 id="2-2-1-OutputStream"><a href="#2-2-1-OutputStream" class="headerlink" title="2.2.1 OutputStream"></a>2.2.1 OutputStream</h4><ul>
<li><p><strong>void</strong> <strong>write(int</strong> <strong>b)</strong></p>
<p>将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写 入的字节是参数b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。</p>
</li>
<li><p><strong>void</strong> <strong>write(byte[]</strong> <strong>b)</strong></p>
<p>将b.length 个字节从指定的byte 数组写入此输出流。write(b) 的常规协定是：应该 与调用write(b, 0, b.length) 的效果完全相同。</p>
</li>
<li><p><strong>void</strong> <strong>write(byte[]</strong> <strong>b,int</strong> <strong>off,int</strong> <strong>len)</strong></p>
<p>将指定byte 数组中从偏移量 off 开始的len 个字节写入此输出流。</p>
</li>
<li><p><strong>public</strong> <strong>void</strong> <strong>flush()throws</strong> <strong>IOException</strong></p>
<p>刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。</p>
</li>
<li><p><strong>public</strong> <strong>void</strong> <strong>close()</strong> <strong>throws</strong> <strong>IOException</strong></p>
<p>关闭此输出流并释放与该流关联的所有系统资源。</p>
</li>
</ul>
<h4 id="2-2-2-Writer"><a href="#2-2-2-Writer" class="headerlink" title="2.2.2 Writer"></a>2.2.2 Writer</h4><ul>
<li><p><strong>void</strong> <strong>write(int</strong> <strong>c)</strong></p>
<p>写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。</p>
</li>
<li><p><strong>void</strong> <strong>write(char[]</strong> <strong>cbuf)</strong></p>
<p>写入字符数组。</p>
</li>
<li><p><strong>void</strong> <strong>write(char[]</strong> <strong>cbuf,int</strong> <strong>off,int</strong> <strong>len)</strong></p>
<p>写入字符数组的某一部分。从off开始，写入len个字符</p>
</li>
<li><p><strong>void</strong> <strong>write(String</strong> <strong>str)</strong></p>
<p>写入字符串。</p>
</li>
<li><p><strong>void</strong> <strong>write(String</strong> <strong>str,int</strong> <strong>off,int</strong> <strong>len)</strong></p>
<p>写入字符串的某一部分。</p>
</li>
<li><p><strong>void</strong> <strong>flush()</strong></p>
<p>刷新该流的缓冲，则立即将它们写入预期目标。</p>
</li>
<li><p><strong>public</strong> <strong>void</strong> <strong>close()</strong> <strong>throws</strong> <strong>IOException</strong></p>
<p>关闭此输出流并释放与该流关联的所有系统资源。</p>
</li>
</ul>
<h2 id="3-节点流-或文件流"><a href="#3-节点流-或文件流" class="headerlink" title="3. 节点流(或文件流)"></a>3. 节点流(或文件流)</h2><ul>
<li>定义文件路径时，注意：可以用“&#x2F;”或者“\”。</li>
<li>在<strong>写入</strong>一个文件时，如果使用构造器FileOutputStream(file)，则<strong>目录下有同名文件将被覆盖。</strong></li>
<li>如果使用构造器FileOutputStream(file,true)，则目录下的同名文件不会被覆盖， <strong>在文件内容末尾追加内容。</strong></li>
<li>在<strong>读取</strong>文件时，必须保证该文件已存在，否则报异常。</li>
<li>字节流操作字节，比如：.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt</li>
<li>字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc,excel,ppt这些不是文 本文件。</li>
</ul>
<hr>
<p><strong>读取文件</strong>（FileReader（字符）、FileInputStream（字节））</p>
<ol>
<li><p>建立一个流对象，将已存在的一个文件加载进流。</p>
<p><strong>FileReader</strong> <strong>fr</strong> <strong>&#x3D;</strong> <strong>new</strong> <strong>FileReader(new</strong> <strong>File(“Test.txt”));</strong></p>
</li>
<li><p>创建一个临时存放数据的数组。</p>
<p><strong>char[]</strong> <strong>ch</strong> <strong>&#x3D;</strong> <strong>new</strong> <strong>char[1024];</strong></p>
</li>
<li><p>调用流对象的读取方法将流中的数据读入到数组中。</p>
<p><strong>fr.read(ch);</strong></p>
</li>
<li><p>关闭资源。</p>
<p><strong>fr.close();</strong></p>
</li>
</ol>
<hr>
<p><strong>写入文件</strong>（FileWriter（字符）、FileOutputStream（字节））</p>
<ol>
<li><p>创建流对象，建立数据存放文件</p>
<p><strong>FileWriter</strong> <strong>fw</strong> <strong>&#x3D;</strong> <strong>new</strong> <strong>FileWriter(new</strong> <strong>File(“Test.txt”));</strong></p>
</li>
<li><p>调用流对象的写入方法，将数据写入流</p>
<p><strong>fw.write(“atguigu-songhongkang”);</strong></p>
</li>
<li><p>关闭流资源，并将流中的数据清空到文件中。</p>
<p><strong>fw.close();</strong></p>
</li>
</ol>
<h2 id="4-缓冲流"><a href="#4-缓冲流" class="headerlink" title="4. 缓冲流"></a>4. 缓冲流</h2><ul>
<li><strong>为了提高数据读写的速度</strong>，Java API提供了带缓冲功能的流类，在使用这些流类 时，会创建一个内部缓冲区数组，缺省使用<strong>8192个字节(8Kb)的缓冲区。</strong></li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230105191234483.png" alt="image-20230105191234483"></p>
<ul>
<li>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：<ul>
<li><strong>BufferedInputStream 和 BufferedOutputStream</strong></li>
<li><strong>BufferedReader 和 BufferedWriter</strong></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区</li>
<li>当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从 文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中 读取下一个8192个字节数组。</li>
<li>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满， BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法 <strong>flush()可以强制将缓冲区的内容全部写入输出流</strong></li>
<li>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也 会相应关闭内层节点流</li>
<li>flush()方法的使用：手动将buffer中内容写入文件</li>
<li>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷 新缓冲区，关闭后不能再写出</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230105191437486.png" alt="image-20230105191437486"></p>
<h2 id="5-转换流"><a href="#5-转换流" class="headerlink" title="5. 转换流"></a>5. 转换流</h2><ul>
<li><p>转换流提供了在字节流和字符流之间的转换</p>
</li>
<li><p>Java API提供了两个转换流：</p>
<ul>
<li><p><strong>InputStreamReader</strong>：将<strong>InputStream</strong>转换为<strong>Reader</strong></p>
</li>
<li><p><strong>OutputStreamWriter</strong>：将<strong>Writer</strong>转换为<strong>OutputStream</strong></p>
</li>
</ul>
</li>
<li><p>字节流中的数据都是字符时，转成字符流操作更高效。</p>
</li>
<li><p>很多时候我们使用转换流来处理文件乱码问题。实现编码和 解码的功能。</p>
</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230105192356106.png" alt="image-20230105192356106"></p>
<h3 id="5-1-InputStreamReader"><a href="#5-1-InputStreamReader" class="headerlink" title="5.1 InputStreamReader"></a>5.1 InputStreamReader</h3><ul>
<li><p>实现将字节的输入流按指定字符集转换为字符的输入流。</p>
</li>
<li><p>需要和InputStream“套接”。</p>
</li>
<li><p>构造器</p>
<ul>
<li><strong>public</strong> <strong>InputStreamReader(InputStream</strong> <strong>in)</strong></li>
<li><strong>public</strong> <strong>InputSreamReader(InputStream</strong> <strong>in,String</strong> <strong>charsetName)</strong></li>
</ul>
<p>如： <code>Reader isr = new InputStreamReader(System.in,”gbk”);</code></p>
<blockquote>
<p>第二个参数为指定字符集</p>
</blockquote>
</li>
</ul>
<h3 id="5-2-OutputStreamWriter"><a href="#5-2-OutputStreamWriter" class="headerlink" title="5.2 OutputStreamWriter"></a>5.2 OutputStreamWriter</h3><ul>
<li>实现将字符的输出流按指定字符集转换为字节的输出流。</li>
<li>需要和OutputStream“套接”。</li>
<li>构造器<ul>
<li><strong>public</strong> <strong>OutputStreamWriter(OutputStream</strong> <strong>out)</strong></li>
<li><strong>public</strong> <strong>OutputSreamWriter(OutputStream</strong> <strong>out,String</strong> <strong>charsetName)</strong></li>
</ul>
</li>
</ul>
<h3 id="5-3-补充：字符编码"><a href="#5-3-补充：字符编码" class="headerlink" title="5.3 补充：字符编码"></a>5.3 补充：字符编码</h3><p><strong>编码表的由来</strong></p>
<p>计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识 别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。 这就是编码表。</p>
<hr>
<p><strong>常见的编码表</strong></p>
<ul>
<li><strong>ASCII</strong>：美国标准信息交换码。<ul>
<li>用一个字节的7位可以表示。</li>
</ul>
</li>
<li><strong>ISO8859-1</strong>：拉丁码表。欧洲码表<ul>
<li>用一个字节的8位表示。</li>
</ul>
</li>
<li><strong>GB2312</strong>：中国的中文编码表。最多两个字节编码所有字符</li>
<li><strong>GBK</strong>：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</li>
<li><strong>Unicode</strong>：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li>
<li><strong>UTF-8</strong>：变长的编码方式，可用1-4个字节来表示一个字符。</li>
</ul>
<hr>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230105192748104.png" alt="image-20230105192748104"></p>
<ul>
<li>Unicode不完美，这里就有三个问题，一个是，我们已经知道，英文字母只用 一个字节表示就够了，第二个问题是如何才能区别Unicode和ASCII？计算机 怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？第三个，如果 和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节， 就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时 间内无法推广，直到互联网的出现。</li>
<li>面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，<strong>UTF- 8就是每次8个位传输数据，而UTF-16就是每次16个位</strong>。这是为传输而设计的 编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</li>
<li><strong>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯 一确定的编号，具体存储成什么样的字节流，取决于字符编码方案</strong>。推荐的 Unicode编码是UTF-8和UTF-16。</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230105192849408.png" alt="image-20230105192849408"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230105192907405.png" alt="image-20230105192907405"></p>
<hr>
<ul>
<li><p>编码：<strong>字符串–&gt;字节数组</strong></p>
</li>
<li><p>解码：<strong>字节数组–&gt;字符串</strong></p>
</li>
<li><p>转换流的编码应用</p>
<ul>
<li>可以将字符按指定编码格式存储</li>
<li>可以对文本数据按指定编码格式来解读</li>
<li>指定编码表的动作由构造器完成</li>
</ul>
</li>
</ul>
<h2 id="6-标准输入、输出流"><a href="#6-标准输入、输出流" class="headerlink" title="6. 标准输入、输出流"></a>6. 标准输入、输出流</h2><ul>
<li><strong>System.in</strong>和<strong>System.out</strong>分别代表了系统标准的输入和输出设备</li>
<li>默认输入设备是：键盘，输出设备是：显示器</li>
<li>System.in的类型是InputStream</li>
<li>System.out的类型是PrintStream，其是OutputStream的子类 FilterOutputStream 的子类</li>
<li>重定向：通过System类的setIn，setOut方法对默认设备进行改变。<ul>
<li>public static void <strong>setIn</strong>(InputStream in)</li>
<li>public static void <strong>setOut</strong>(PrintStream out)</li>
</ul>
</li>
</ul>
<h2 id="7-打印流"><a href="#7-打印流" class="headerlink" title="7. 打印流"></a>7. 打印流</h2><ul>
<li>实现将<strong>基本数据类型</strong>的数据格式转化为<strong>字符串</strong>输出</li>
<li>打印流：<strong>PrintStream和PrintWriter</strong><ul>
<li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li>
<li>PrintStream和PrintWriter的输出不会抛出IOException异常</li>
<li>PrintStream和PrintWriter有自动flush功能</li>
<li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。</li>
<li>在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
</li>
</ul>
<h2 id="8-数据流"><a href="#8-数据流" class="headerlink" title="8. 数据流"></a>8. 数据流</h2><ul>
<li>为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。</li>
<li>数据流有两个类：(用于读取和写出基本数据类型、String类的数据）<ul>
<li><strong>DataInputStream</strong> 和 <strong>DataOutputStream</strong></li>
<li>分别“套接”在 <strong>InputStream</strong> 和 <strong>OutputStream</strong> 子类的流上</li>
</ul>
</li>
<li><strong>DataInputStream</strong>中的方法</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230105193501018.png" alt="image-20230105193501018"></p>
<ul>
<li><p><strong>DataOutputStream</strong>中的方法</p>
<p>将上述的方法的read改为相应的write即可。</p>
</li>
</ul>
<h2 id="9-对象流"><a href="#9-对象流" class="headerlink" title="9. 对象流"></a>9. 对象流</h2><ul>
<li><strong>ObjectInputStream</strong>和<strong>OjbectOutputSteam</strong><ul>
<li>用于存储和读取<strong>基本数据类型数据</strong>或<strong>对象</strong>的处理流。它的强大之处就是可 以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li>
</ul>
</li>
<li>序列化：用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</li>
<li>反序列化：用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制</li>
<li>ObjectOutputStream和ObjectInputStream不能序列化<strong>static</strong>和<strong>transient</strong>修饰的成员变量</li>
</ul>
<hr>
<p><strong>对象的序列化</strong></p>
<ul>
<li><p><strong>对象序列化机制</strong>允许把内存中的Java对象转换成平台无关的二进制流，从 而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传 输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原 来的Java对象</p>
</li>
<li><p>序列化的好处在于可将任何实现了Serializable接口的对象转化为<strong>字节数据</strong>， 使其在保存和传输时可被还原</p>
</li>
<li><p>序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返 回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础</p>
</li>
<li><p>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可 序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。 否则，会抛出NotSerializableException异常</p>
<ul>
<li><strong>Serializable</strong></li>
<li>Externalizable</li>
</ul>
</li>
<li><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：</p>
<ul>
<li><strong>private</strong> <strong>static</strong> <strong>final</strong> <strong>long</strong> <strong>serialVersionUID;</strong></li>
<li>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象 进行版本控制，有关各版本反序列化时是否兼容。</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自 动生成的。<strong>若类的实例变量做了修改，serialVersionUID 可能发生变化</strong>。故建议， 显式声明。</li>
</ul>
</li>
<li><p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验 证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的 serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)</p>
</li>
</ul>
<hr>
<ul>
<li>若某个类实现了 Serializable 接口，该类的对象就是可序列化的：<ul>
<li><strong>创建一个 ObjectOutputStream</strong></li>
<li><strong>调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象</strong></li>
<li><strong>注意写出一次，操作flush()一次</strong></li>
</ul>
</li>
<li>反序列化<ul>
<li><strong>创建一个 ObjectInputStream</strong></li>
<li><strong>调用 readObject() 方法读取流中的对象</strong></li>
</ul>
</li>
<li>强调：如果某个类的属性不是基本数据类型或 String  类型，而是另一个 引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的 Field 的类也不能序列化</li>
</ul>
<hr>
<ul>
<li><strong>序列化</strong>：将对象写入到磁盘或者进行网络传输。（要求对象必须实现序列化）</li>
<li><strong>反序列化</strong>：将磁盘中的对象数据源读出。</li>
</ul>
<h2 id="10-随机存取文件流"><a href="#10-随机存取文件流" class="headerlink" title="10. 随机存取文件流"></a>10. 随机存取文件流</h2><h3 id="10-1-RandomAccessFile类"><a href="#10-1-RandomAccessFile类" class="headerlink" title="10.1 RandomAccessFile类"></a>10.1 RandomAccessFile类</h3><ul>
<li>RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并 且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也 可以写。</li>
<li>RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul>
</li>
<li>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。</li>
<li>RandomAccessFile 类对象可以自由移动记录指针：<ul>
<li>**long getFilePointer()**：获取文件记录指针的当前位置</li>
<li>**void seek(long pos)**：将文件记录指针定位到 pos 位置</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>构造器</p>
<ul>
<li>public <strong>RandomAccessFile</strong>(File file, String mode)</li>
<li>public <strong>RandomAccessFile</strong>(String name, String mode)</li>
</ul>
</li>
<li><p>创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指 定 RandomAccessFile 的访问模式：</p>
<ul>
<li><strong>r:</strong> 以只读方式打开</li>
<li><strong>rw</strong>：打开以便读取和写入</li>
<li>**rwd:**打开以便读取和写入；同步文件内容的更新</li>
<li>**rws:**打开以便读取和写入；同步文件内容和元数据的更新</li>
</ul>
</li>
<li><p>如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件， 如果读取的文件不存在则会出现异常。 如果模式为rw读写。如果文件不 存在则会去创建文件，如果存在则不会创建。</p>
</li>
</ul>
<hr>
<p><strong>RandomAccessFile类的应用场景</strong></p>
<p>我们可以用RandomAccessFile这个类，来实现一个<strong>多线程断点下载</strong>的功能，用过下载工具的朋友们都知道，下载前都会建立<strong>两个临时文件</strong>，一个是与 被下载文件大小相同的空文件，另一个是记录文件指针的位置文件，每次 暂停的时候，都会保存上一次的指针，然后断点下载的时候，会继续从上 一次的地方下载，从而实现断点下载或上传的功能，有兴趣的朋友们可以 自己实现下。</p>
<h2 id="11-NIO-2中Path、-Paths、Files类的使用"><a href="#11-NIO-2中Path、-Paths、Files类的使用" class="headerlink" title="11. NIO.2中Path、 Paths、Files类的使用"></a>11. NIO.2中Path、 Paths、Files类的使用</h2><p><strong>Java NIO概述</strong></p>
<p>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新 的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目 的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于 通道的IO操作。<strong>NIO将以更加高效的方式进行文件的读写操作。</strong></p>
<p>Java API中提供了两套NIO，<strong>一套是针对标准输入输出NIO，另一套就是网络编程NIO</strong>。</p>
<ul>
<li>|—–java.nio.channels.Channel<ul>
<li>|—–FileChannel:处理本地文件</li>
<li>|—–SocketChannel：TCP网络编程的客户端的Channel</li>
<li>|—–ServerSocketChannel:TCP网络编程的服务器端的Channel</li>
<li>|—–DatagramChannel：UDP网络编程中发送端和接收端的Channel</li>
</ul>
</li>
</ul>
<hr>
<p><strong>NIO.2</strong></p>
<p>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对 文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。 因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要 的部分。</p>
<hr>
<p><strong>Path、Paths和Files核心API</strong></p>
<ul>
<li><p>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所 提供的方法性能也不高。而且，<strong>大多数方法在出错时仅返回失败，并不会提供异 常信息。</strong></p>
</li>
<li><p>NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。<strong>Path可以看成是File类的升级版本，实际引用的资 源也可以不存在。</strong></p>
</li>
<li><p>在以前IO操作都是这样写的:</p>
<ul>
<li>import java.io.File;</li>
<li><strong>File file &#x3D; new File(“index.html”);</strong></li>
</ul>
</li>
<li><p>但在Java7 中，我们可以这样写：</p>
<ul>
<li>import java.nio.file.Path; </li>
<li>import java.nio.file.Paths;</li>
<li><strong>Path path &#x3D; Paths.get(“index.html”);</strong></li>
</ul>
</li>
<li><p>同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含 了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态 工厂方法。</p>
</li>
<li><p>Paths 类提供的静态 get() 方法用来获取 Path 对象：</p>
<ul>
<li><strong>static Path get(String first, String … more)</strong> : 用于将多个字符串串连成路径</li>
<li><strong>static Path get(URI uri)</strong>: 返回指定uri对应的Path路径</li>
</ul>
</li>
</ul>
<hr>
<h3 id="11-1-Path接口"><a href="#11-1-Path接口" class="headerlink" title="11.1 Path接口"></a>11.1 Path接口</h3><p><strong>Path常用方法</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230106210243570.png" alt="image-20230106210243570"></p>
<h3 id="11-2-Files类"><a href="#11-2-Files类" class="headerlink" title="11.2 Files类"></a>11.2 Files类</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230106210317494.png" alt="image-20230106210317494"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230106210346899.png" alt="image-20230106210346899"></p>
<hr>
<p><strong>IO流 总结</strong></p>
<blockquote>
<ul>
<li><p>流是用来处理数据的。</p>
</li>
<li><p>处理数据时，一定要先明确<strong>数据源</strong>，与<strong>数据目的地</strong></p>
</li>
<li><p>数据源可以是文件，可以是键盘。</p>
</li>
<li><p>数据目的地可以是文件、显示器或者其他设备。</p>
</li>
<li><p>而流只是在帮助数据进行传输,并对传输的数据进行处理，比如过滤处理、 转换处理等。</p>
</li>
</ul>
</blockquote>
<p><strong>一、流的分类以及常见流的体系结构</strong></p>
<ol>
<li><p>操作数据单位：字节流、字符流</p>
</li>
<li><p>数据的流向：输入流、输出流</p>
</li>
<li><p>流的角色：节点流、处理流</p>
</li>
</ol>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230106210749149.png" alt="image-20230106210749149"></p>
<p><strong>二、转换流的使用</strong></p>
<ol>
<li><p>转换流：属于字符流</p>
<ul>
<li><p>InputStreamReader：将一个字节的输入流转换为字符的输入流</p>
</li>
<li><p>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</p>
</li>
</ul>
</li>
<li><p>作用：提供字节流与字符流之间的转换</p>
</li>
<li><p><strong>解码</strong>：字节、字节数组  —&gt;字符数组、字符串</p>
<p><strong>编码</strong>：字符数组、字符串 —&gt; 字节、字节数组</p>
</li>
</ol>
<p><strong>三、对象序列化需要满足的条件</strong></p>
<ol>
<li><p>需要实现接口：Serializable</p>
</li>
<li><p>当前类提供一个全局常量：serialVersionUID</p>
</li>
<li><p>除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</p>
</li>
</ol>
<blockquote>
<p>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p>
</blockquote>
<p><strong>四、输入、输出的标准化过程</strong></p>
<p><strong>输入过程</strong></p>
<p>① 创建File类的对象，指明读取的数据的来源（要求此文件一定要存在）</p>
<p>② 创建相应的输入流，将File类对象作为参数，传入流的构造器中</p>
<p>③ 具体的读入过程：创建相应的byte[] 或 char[]</p>
<p>④ 关闭流资源</p>
<blockquote>
<p>程序中出现的异常需要使用try-catch-finally处理</p>
</blockquote>
<p><strong>输出过程</strong></p>
<p>① 创建File类的对象，指明写出的数据的位置（不要求此文件一定要存在）</p>
<p>② 创建相应的输出流，将File类对象作为参数，传入流的构造器中</p>
<p>③ 具体的写出过程：创建相应的byte[] 或 char[]</p>
<p>④ 关闭流资源</p>
<blockquote>
<p>程序中出现的异常需要使用try-catch-finally处理</p>
</blockquote>
<p><strong>五、节点流和处理流</strong></p>
<p>节点流可以直接作用在文件上，对数据进行读写操作；处理流包在节点流或者处理流上，对数据进行读写操作</p>
<h1 id="第十三章-gt-gt-gt-网络编程"><a href="#第十三章-gt-gt-gt-网络编程" class="headerlink" title="第十三章&gt;&gt;&gt;网络编程"></a>第十三章&gt;&gt;&gt;网络编程</h1><h2 id="1-网络编程的概述"><a href="#1-网络编程的概述" class="headerlink" title="1. 网络编程的概述"></a>1. 网络编程的概述</h2><p>Java是 Internet 上的语言，它从语言级上提供了对网络应用程 序的支持，程序员能够很容易开发常见的网络应用程序。</p>
<p>Java提供的网络类库，可以实现无痛的网络连接，联网的底层 细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并 且 Java 实现了一个跨平台的网络库，<strong>程序员面对的是一个统一 的网络编程环境。</strong></p>
<hr>
<p><strong>网络基础</strong></p>
<ul>
<li><p>计算机网络：</p>
<p>把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规 模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、 共享硬件、软件、数据信息等资源。</p>
</li>
<li><p>网络编程的目的：</p>
<p><strong>直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</strong></p>
</li>
<li><p>网络编程中有两个主要的问题：</p>
<ul>
<li><strong>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</strong></li>
<li><strong>找到主机后如何可靠高效地进行数据传输</strong></li>
</ul>
</li>
</ul>
<h2 id="2-网络通信要素"><a href="#2-网络通信要素" class="headerlink" title="2. 网络通信要素"></a>2. 网络通信要素</h2><p><strong>如何实现网络中的主机互相通信</strong></p>
<ul>
<li><strong>通信双方地址</strong><ul>
<li>IP</li>
<li>端口号</li>
</ul>
</li>
<li><strong>一定的规则</strong>（即：网络通信协议。有两套参考模型）<ul>
<li>OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广</li>
<li>TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议)：事实上的国际标准。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>网络通信协议</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230106222338399.png" alt="image-20230106222338399"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230106222349945.png" alt="image-20230106222349945"></p>
<h3 id="2-1-IP和端口号"><a href="#2-1-IP和端口号" class="headerlink" title="2.1 IP和端口号"></a>2.1 IP和端口号</h3><p><strong>IP</strong> 地址：InetAddress</p>
<ul>
<li>唯一的标识 Internet 上的计算机（通信实体）</li>
<li>本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost</li>
<li>IP地址分类方式1：<strong>IPV4</strong> 和 <strong>IPV6</strong><ul>
<li>IPV4：4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。以点分十进制表示，如192.168.0.1</li>
<li>IPV6：128位（16个字节），写成8个无符号整数，每个整数用四个十六进制位表示， 数之间用冒号（：）分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984</li>
</ul>
</li>
<li>IP地址分类方式2：<strong>公网地址(万维网使用)<strong>和</strong>私有地址(局域网使用)。</strong>192.168. 开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用</li>
<li>特点：不易记忆</li>
</ul>
<hr>
<p>端口号标识正在计算机上运行的进程（程序）</p>
<ul>
<li>不同的进程有不同的端口号</li>
<li>被规定为一个 16 位的整数 0~65535。</li>
<li>端口分类：<ul>
<li><strong>公认端口</strong>：0~1023。被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23）</li>
<li><strong>注册端口</strong>：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。</li>
<li><strong>动态&#x2F;私有端口</strong>：49152~65535。</li>
</ul>
</li>
</ul>
<p><strong>端口号与IP地址的组合得出一个网络套接字：Socket。</strong></p>
<hr>
<p><strong>InetAddress类</strong></p>
<ul>
<li><p>Internet上的主机有两种方式表示地址：</p>
<ul>
<li>**域名(hostName)**：<a target="_blank" rel="noopener" href="http://www.atguigu.com/">ww</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">w</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">.</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">a</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">t</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">g</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">ui</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">g</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">u</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">.com</a></li>
<li>**IP 地址(hostAddress)**：202.108.35.210</li>
</ul>
</li>
<li><p>InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address。</p>
</li>
<li><p>InetAddress 类对象含有一个 Internet：主机地址的域名和 IP 地址：<a target="_blank" rel="noopener" href="http://www.atguigu.com/">w</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">w</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">w</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">.</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">at</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">g</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">uig</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">u</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">.</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/">com</a><a target="_blank" rel="noopener" href="http://www.atguigu.com/"> </a>和 202.108.35.210。</p>
</li>
<li><p>域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)</p>
<p>负责将域名转化成IP地址，这样才能和主机建立连接。 <strong>——-域名解析</strong></p>
</li>
</ul>
<hr>
<ul>
<li><strong>InetAddress</strong>类没有提供公共的构造器，而是提供了如下几个静态方法来获取<strong>InetAddress</strong>实例<ul>
<li><code>public static InetAddress getLocalHost()</code></li>
<li><code>public static InetAddress getByName(String host)</code></li>
</ul>
</li>
<li><strong>InetAddress</strong>提供了如下几个常用的方法<ul>
<li><code>public String getHostAddress()</code>：返回 IP 地址字符串（以文本表现形式）。</li>
<li><code>public String getHostName()</code>：获取此 IP 地址的主机名</li>
<li><code>public boolean isReachable(int timeout)</code>：测试是否可以达到该地址</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230106223518111.png" alt="image-20230106223518111"></p>
<h3 id="2-2-网络协议"><a href="#2-2-网络协议" class="headerlink" title="2.2 网络协议"></a>2.2 网络协议</h3><ul>
<li><p>网络通信协议</p>
<p>计算机网络中实现通信必须有一些约定，即通信协议，<strong>对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准。</strong></p>
</li>
<li><p>问题：网络协议太复杂</p>
<p>计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢？</p>
</li>
<li><p>通信协议分层的思想</p>
<p>在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常 用的复合方式是层次方式，<strong>即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。</strong>各层互不影响，利于系统的开发和扩展。</p>
</li>
</ul>
<hr>
<p><strong>TCP&#x2F;IP协议簇</strong></p>
<ul>
<li>传输层协议中有两个非常重要的协议：<ul>
<li>传输控制协议TCP(Transmission Control Protocol)</li>
<li>用户数据报协议UDP(User Datagram Protocol)。</li>
</ul>
</li>
<li>**TCP&#x2F;IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)**而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议。</li>
<li>IP(Internet Protocol)协议是网络层的主要协议，支持网间互连的数据通信。</li>
<li>TCP&#x2F;IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即<strong>物理链路层、IP层、传输层和应用层。</strong></li>
</ul>
<hr>
<p><strong>TCP 和 UDP</strong></p>
<p><strong>TCP</strong>协议：</p>
<ul>
<li>使用TCP协议前，须先建立TCP连接，形成传输数据通道</li>
<li>传输前，采用“三次握手”方式，点对点通信，<strong>是可靠的</strong></li>
<li>TCP协议进行通信的两个应用进程：客户端、服务端。</li>
<li>在连接中<strong>可进行大数据量的传输</strong></li>
<li>传输完毕，<strong>需释放已建立的连接，效率低</strong></li>
</ul>
<p><strong>UDP</strong>协议：</p>
<ul>
<li>将数据、源、目的封装成数据包，<strong>不需要建立连接</strong></li>
<li>每个数据报的大小限制在64K内</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
<li>可以广播发送</li>
<li>发送数据结束时<strong>无需释放资源，开销小，速度快</strong></li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230106224301251.png" alt="image-20230106224301251"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230106224307351.png" alt="image-20230106224307351"></p>
<hr>
<p><strong>Socket</strong></p>
<ul>
<li>利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实 上的标准。</li>
<li><strong>网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标 识符套接字。</strong></li>
<li>通信的两端都要有Socket，是两台机器间通信的端点。</li>
<li>网络通信其实就是Socket间的通信。</li>
<li>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</li>
<li>一般主动发起通信的应用程序属<strong>客户端</strong>，等待通信请求的为<strong>服务端</strong>。</li>
<li>Socket分类：<ul>
<li><strong>流套接字（stream socket）：使用TCP提供可依赖的字节流服务</strong></li>
<li><strong>数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务</strong></li>
</ul>
</li>
</ul>
<img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230106224801032.png" alt="image-20230106224801032"  />



<h2 id="3-TCP网络编程"><a href="#3-TCP网络编程" class="headerlink" title="3. TCP网络编程"></a>3. TCP网络编程</h2><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230107092805376.png" alt="image-20230107092805376"></p>
<p>客户端<strong>Socket</strong>的工作过程包含以下四个基本的步骤：</p>
<ul>
<li>创建 <strong>Socket</strong>：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li>
<li>打开连接到 <strong>Socket</strong> 的输入**&#x2F;**出流： 使用 getInputStream()方法获得输入流，使用 getOutputStream()方法获得输出流，进行数据传输</li>
<li>按照一定的协议对 <strong>Socket</strong> 进行读**&#x2F;**写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程。</li>
<li>关闭 <strong>Socket</strong>：断开客户端到服务器的连接，释放线路</li>
</ul>
<hr>
<p><strong>客户端创建Socket对象</strong></p>
<p>客户端程序可以使用Socket类创建对象，<strong>创建的同时会自动向服务器方发起连接。</strong>Socket的构造器是：</p>
<ul>
<li><code>Socket(String host,int port)throws UnknownHostException,IOException</code>：向服务器(域名是host。端口号为port)发起TCP连接，若成功，则创建Socket对象，否则抛出异常。</li>
<li><code>Socket(InetAddress address,int port)throws IOException：</code>根据InetAddress对象所表示的 IP地址以及端口号port发起连接。</li>
</ul>
<p>客户端建立socketAtClient对象的过程就是向服务器发出套接字连接请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(“<span class="number">192.168</span><span class="number">.40</span><span class="number">.165</span>”,<span class="number">9999</span>);</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> s.getOutputStream();  </span><br><span class="line">out.write(<span class="string">&quot; hello&quot;</span>.getBytes());</span><br><span class="line">s.close();</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>服务器程序的工作过程包含以下四个基本的步骤：</strong></p>
<p>调用 <strong>ServerSocket(int port)</strong> ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</p>
<p>调用 **accept()**：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</p>
<p>调用 该<strong>Socket</strong>类对象的 <strong>getOutputStream()</strong> 和 <strong>getInputStream</strong> **()**：获取输出流和输入流，开始网络数据的发送和接收。</p>
<p>关闭<strong>ServerSocket</strong>和<strong>Socket</strong>对象：客户端访问结束，关闭通信套接字。</p>
<hr>
<p><strong>服务器建立ServerSocket对象</strong></p>
<p>ServerSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口中的业务员。也就是说，<strong>服务器必须事先建立一个等待客户请求建立套接字连接的ServerSocket对象</strong>。</p>
<p>所谓“接收”客户的套接字请求，就是accept()方法会返回一个 Socket 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);  </span><br><span class="line"><span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept ();</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> s.getInputStream(); </span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> in.read(buf);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,num); System.out.println(s.getInetAddress().toString()+”:”+str); s.close();</span><br><span class="line">ss.close();</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>客户端—服务端</strong></p>
<ul>
<li>客户端：<ul>
<li>自定义</li>
<li>浏览器</li>
</ul>
</li>
<li>服务端：<ul>
<li>自定义</li>
<li>Tomcat服务器</li>
</ul>
</li>
</ul>
<h2 id="4-UDP网络编程"><a href="#4-UDP网络编程" class="headerlink" title="4. UDP网络编程"></a>4. UDP网络编程</h2><ul>
<li>类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。</li>
<li>UDP数据报通过数据报套接字 DatagramSocket 发送和接收，<strong>系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</strong></li>
<li><strong>DatagramPacket 对象封装了UDP数据报</strong>，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</li>
<li>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和 接收方的连接。如同发快递包裹一样。</li>
</ul>
<hr>
<p><strong>DatagramSocket类的常用方法</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230107094654705.png" alt="image-20230107094654705"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230107094720128.png" alt="image-20230107094720128"></p>
<hr>
<p><strong>UDP网络通信</strong></p>
<ul>
<li>流 程：<ul>
<li>1.DatagramSocket与DatagramPacket</li>
<li>2.建立发送端，接收端</li>
<li>3.建立数据包</li>
<li>4.调用Socket的发送、接收方法</li>
<li>5.关闭Socket</li>
</ul>
</li>
<li>发送端与接收端是两个独立的运行程序</li>
</ul>
<hr>
<p><strong>发送端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	ds = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">	<span class="type">byte</span>[] by = <span class="string">&quot;hello,atguigu.com&quot;</span>.getBytes();</span><br><span class="line">	<span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(by, <span class="number">0</span>, by.length, InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10000</span>);</span><br><span class="line">	ds.send(dp);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ds != <span class="literal">null</span>)</span><br><span class="line">		ds.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接收端</strong></p>
<p>在接收端，要指定监听的端口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	ds = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10000</span>);  </span><br><span class="line">    <span class="type">byte</span>[] by = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(by, by.length);</span><br><span class="line">	ds.receive(dp);</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(), <span class="number">0</span>, dp.getLength());</span><br><span class="line">	System.out.println(str + <span class="string">&quot;--&quot;</span> + dp.getAddress());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ds != <span class="literal">null</span>)</span><br><span class="line">		ds.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-URL编程"><a href="#5-URL编程" class="headerlink" title="5. URL编程"></a>5. URL编程</h2><p><strong>URL</strong>类</p>
<ul>
<li><p><strong>URL(Uniform</strong> <strong>Resource</strong> **Locator)**：统一资源定位符，它表示 Internet 上某一资源的地址。</p>
</li>
<li><p>它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p>
</li>
<li><p>通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。</p>
</li>
<li><p>URL的基本结构由5部分组成：</p>
<p><strong>&lt;传输协议&gt;:&#x2F;&#x2F;&lt;主机名&gt;:&lt;端口号&gt;&#x2F;&lt;文件名&gt;#片段名?参数列表</strong></p>
<ul>
<li>例如: <a target="_blank" rel="noopener" href="http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&password=123">http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123</a></li>
<li>#片段名：即锚点，例如看小说，直接定位到章节</li>
<li>参数列表格式：参数名&#x3D;参数值&amp;参数名&#x3D;参数值….</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象：</p>
<ul>
<li><p><strong>public</strong> <strong>URL</strong> <strong>(String</strong> **spec)**：通过一个表示URL地址的字符串可以构造一个URL对象。</p>
<p>例 如：URL url &#x3D; new URL (“<a target="_blank" rel="noopener" href="http://www/">http://www.</a><a target="_blank" rel="noopener" href="http://www/"> </a>atguigu.com&#x2F;“);</p>
</li>
<li><p><strong>public URL(URL</strong> <strong>context,</strong> <strong>String</strong> **spec)**：通过基 URL 和相对 URL 构造一个 URL 对象。</p>
<p>例如：URL downloadUrl &#x3D; new URL(url, “download.html”)</p>
</li>
<li><p>public URL(String protocol, String host, String file); </p>
<p>例如：new URL(“http”,  “<a target="_blank" rel="noopener" href="http://www.atguigu.com/">www.atguigu.com</a>“, “download. html”);</p>
</li>
<li><p>public URL(String protocol, String host, int port, String file); </p>
<p>例如: URL gamelan &#x3D; newURL(“http”, “<a target="_blank" rel="noopener" href="http://www.atguigu.com/">www.atguigu.com</a>“, 80, “download.html”);</p>
</li>
</ul>
</li>
<li><p>URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通 常是用 try-catch 语句进行捕获。</p>
</li>
</ul>
<hr>
<p><strong>URL类的常用方法</strong></p>
<p>一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性：</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230107095856063.png" alt="image-20230107095856063"></p>
<hr>
<p><strong>针对HTTP协议的URLConnection类</strong></p>
<ul>
<li><p><strong>URL的方法 openStream()：能从网络上读取数据</strong></p>
</li>
<li><p>若希望输出数据，例如向服务器端的 CGI （公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一 些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用 URLConnection 。</p>
</li>
<li><p>URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时， 首先要在一个 URL 对象上通过方法 <strong>openConnection()</strong> 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException.</p>
</li>
<li><p>URL netchinaren &#x3D; new URL <a target="_blank" rel="noopener" href="http://www.atguigu.com/index.shtml">(“http:&#x2F;</a>&#x2F;w<a target="_blank" rel="noopener" href="http://www.atguigu.com/index.shtml">ww.atguigu.com&#x2F;index.shtml</a>“);</p>
</li>
<li><p>URLConnectonn u &#x3D; netchinaren.openConnection( );</p>
</li>
<li><p>通过URLConnection对象获取输入流和输出流，即可以与现有CGI程序进行交互</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230107100157741.png" alt="image-20230107100157741"></p>
</li>
</ul>
<hr>
<p><strong>URI</strong>、<strong>URL</strong>和<strong>URN</strong>的区别</p>
<p><strong>URI，是uniform resource identifier，统一资源标识符</strong>，用来唯一的标识一个 资源。而<strong>URL是uniform resource locator，统一资源定位符</strong>，它是一种具体 的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 而<strong>URN，uniform resource name，统一资源命名</strong>，是通过名字来标识资源， <a href="mailto:java-net@java.sun.com">比如</a>mailto:<a href="mailto:&#106;&#x61;&#x76;&#97;&#45;&#x6e;&#x65;&#116;&#64;&#x6a;&#97;&#x76;&#97;&#x2e;&#115;&#x75;&#x6e;&#x2e;&#99;&#111;&#109;">&#106;&#x61;&#x76;&#97;&#45;&#x6e;&#x65;&#116;&#64;&#x6a;&#97;&#x76;&#97;&#x2e;&#115;&#x75;&#x6e;&#x2e;&#99;&#111;&#109;</a>。也就是说，URI是以一种抽象的，高层 次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL 和URN都是一种URI。</p>
<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符 合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230107100333875.png" alt="image-20230107100333875"></p>
<hr>
<p><strong>网络编程 总结</strong></p>
<blockquote>
<p>位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。</p>
<p><strong>客户端－服务器</strong>是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定 服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。<strong>端口号</strong> 是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。<strong>套接字</strong>用于连接客户 端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实 现面向连接的会话。</p>
<p>Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 <strong>IP地址</strong>，该对象里有两个字段：主机名(String) 和 IP 地址(int)。</p>
<p>类 Socket 和 ServerSocket 实现了基于TCP协议的客户端－服务器程序。Socket是客户端 和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输 通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络 拥挤等问题，它保证数据可靠的传送。</p>
<p>类 URL 和 URLConnection 提供了最高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之 间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去。</p>
</blockquote>
<p><strong>一、网络编程中的两个主要问题及其解决方法</strong></p>
<ol>
<li><p>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</p>
</li>
<li><p>找到主机后如何可靠高效地进行数据传输</p>
</li>
</ol>
<p>网络编程中的两个要素</p>
<ul>
<li>对应问题一：IP和端口号</li>
<li>对应问题二：提供网络通信协议：TCP&#x2F;IP参考模型（应用层、传输层、网络层、物理+数据链路层）</li>
</ul>
<p><strong>二、IP和端口号</strong></p>
<ol>
<li><p>IP:唯一的标识 Internet 上的计算机（通信实体）</p>
</li>
<li><p>在Java中使用InetAddress类代表IP</p>
</li>
<li><p>IP分类：IPv4 和 IPv6 ; 万维网 和 局域网</p>
</li>
<li><p>域名:   <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>   <a target="_blank" rel="noopener" href="http://www.mi.com/">www.mi.com</a>  <a target="_blank" rel="noopener" href="http://www.sina.com/">www.sina.com</a>  <a target="_blank" rel="noopener" href="http://www.jd.com/">www.jd.com</a></p>
</li>
<li><p>本地回路地址：127.0.0.1 对应着：localhost</p>
</li>
<li><p>如何实例化InetAddress:两个方法：getByName(String host) 、 getLocalHost()</p>
<p>两个常用方法：getHostName() &#x2F; getHostAddress()</p>
</li>
<li><p>端口号：正在计算机上运行的进程。</p>
<p>要求：不同的进程有不同的端口号</p>
<p>范围：被规定为一个 16 位的整数 0~65535。</p>
</li>
<li><p>端口号与IP地址的组合得出一个网络套接字：Socket</p>
</li>
</ol>
<p><strong>三、TCP网络编程</strong></p>
<blockquote>
<p>客户端创建一个Socket类对象，指明IP地址和端口号，通过socket获取一个输入或者输出流，通过输出流将数据传输到服务端，或者通过输入流对服务端传来的数据进行操作；</p>
<p>服务端创建ServerSocket类对象，调用此类的accept()方法，返回一个Socket类对象，建立与客户端的连接，进而通过socket获取一个输入或者输出流，通过输入流对客户端传来的数据进行操作，或者将数据通过输出流传输到客户端。</p>
<p>客户端的socket指明IP地址和端口号，从而定向的传输数据；服务端的socket通过指明端口号，使用socket获取从客户端传来的数据。</p>
<p>客户端和服务端在传输数据时可以配合其他输入输出流对数据进行操作。</p>
</blockquote>
<p><strong>① 客户端</strong></p>
<ol>
<li><p>创建Socket对象，指明服务器端的ip和端口号 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.14.100&quot;</span>);</span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(inet,<span class="number">8899</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取一个输出流，用于输出数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用socket的getOutputStream方法</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br></pre></td></tr></table></figure>
</li>
<li><p>写出数据的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用OutputStream类实例化对象的write()</span></span><br><span class="line">os.write(<span class="string">&quot;你好，我是客户端mm&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>
</li>
<li><p>资源的关闭</p>
</li>
</ol>
<p><strong>② 服务端</strong></p>
<ol>
<li><p>创建服务器端的ServerSocket，指明自己的端口号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用accept()表示接收来自于客户端的socket</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket = ss.accept();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取输入流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取输入流中的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐创建ByteArrayOutputStream类，不容易出现乱码</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭资源</p>
</li>
</ol>
<p><strong>四、UDP协议的网络编程</strong></p>
<blockquote>
<p>发送端先创建一个DatagramSocket类对象socket，无需指明IP地址（可以指明端口号也可以不指明），将要操作的数据通过byte[]的形式传入到DatagramPacket类的构造器中创建packet对象，需要指明端口号及IP地址（如果实例化DataframSocket类的时候没有指明端口号，则需要指明），此时相当于将数据打包成数据报packet的形式，调用socket的<code>send(DatagramPacket packet)</code>将此套接字的数据报传输至接收端；</p>
<p>接收端先创建一个DatagramSocket类对象socket，无需指明IP地址，需要指明端口号，将要操作的数据通过byte[]的形式传入到DatagramPacket类的构造器中创建packet对象，将这些数据打包成数据报packet，通过socket的<code>recieve(DatagramPacket packet)</code>从此套接字中获取数据报，获取了从发送端传来的数据，通过packet的getData()返回一个byte[]类型的数组，可以通过此数组来对数据进行操作。</p>
<p>发送端的socket和packet指明一个IP地址和一个端口号，便能定向发送数据；接收端通过指明的端口号来接收packet，打包好之后通过socket获取</p>
</blockquote>
<p><strong>① 发送端</strong></p>
<ol>
<li><p>创建socket对象（DatagramSocket类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建packet对象，指明端口号以及IP地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前ip地址</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建packet对象</span></span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,<span class="number">0</span>,data.length,inet,<span class="number">9090</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用socket对象的send()，将packet对象作为参数传入方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.send(packet);</span><br></pre></td></tr></table></figure>
</li>
<li><p>断开客户端到服务器的连接，释放线路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.close();</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>② 接收端</strong></p>
<ol>
<li><p>创建socket对象（DatagramSocket类），指明端口号，无需指明IP地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建packet对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用socket对象的receive()，将packet对象作为参数传入方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.receive(packet);</span><br></pre></td></tr></table></figure>
</li>
<li><p>断开客户端到服务器的连接，释放线路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.close()</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第十四章-gt-gt-gt-反射机制"><a href="#第十四章-gt-gt-gt-反射机制" class="headerlink" title="第十四章&gt;&gt;&gt;反射机制"></a>第十四章&gt;&gt;&gt;反射机制</h1><h2 id="1-Java-Reflection"><a href="#1-Java-Reflection" class="headerlink" title="1. Java Reflection"></a>1. Java Reflection</h2><p>Reflection（反射）是被视为<strong>动态语言</strong>的关键，反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内 部属性及方法。</p>
<p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个 类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可 以通过这个对象看到类的结构。<strong>这个对象就像一面镜子，透过这个镜子看 到类的结构，所以，我们形象的称之为：反射。</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109102720239.png" alt="image-20230109102720239"></p>
<hr>
<p><strong>动态语言 VS 静态语言</strong></p>
<p>① 动态语言</p>
<p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以 被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是<strong>在运行时代码可以根据某些条件改变自身结构</strong>。主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。</p>
<p>② 静态语言</p>
<p>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</p>
<blockquote>
<p>Java不是动态语言，但Java可以称之为“<strong>准动态语言</strong>”。即Java有一定的动 态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。</p>
<p>Java的动态性让编程的时候更加灵活！</p>
</blockquote>
<hr>
<p><strong>Java</strong>反射机制提供的功能</p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<hr>
<p><strong>反射相关的主要API</strong></p>
<ul>
<li><strong>java.lang.Class</strong>:代表一个类</li>
<li>**java.lang.reflect.Method:**代表类的方法</li>
<li>**java.lang.reflect.Field:**代表类的成员变量</li>
<li>**java.lang.reflect.Constructor:**代表类的构造器</li>
<li>… …</li>
</ul>
<h2 id="2-Class类及获取实例"><a href="#2-Class类及获取实例" class="headerlink" title="2. Class类及获取实例"></a>2. Class类及获取实例</h2><p><strong>Class类</strong></p>
<p>在Object类中定义了以下的方法，此方法将被所有子类继承：</p>
<ul>
<li><strong>public final Class getClass()</strong></li>
</ul>
<p>以上的方法返回值的类型是一个Class类， 此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109103157977.png" alt="image-20230109103157977"></p>
<hr>
<p>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含 了特定某个结构(class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F;primitive type&#x2F;void&#x2F;[])的有关信息。</p>
<ul>
<li>Class本身也是一个类</li>
<li>Class 对象只能由系统建立对象</li>
<li>一个加载的类在 JVM 中只会有一个Class实例</li>
<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>
<li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li>
<li>通过Class可以完整地得到一个类中的所有被加载的结构</li>
<li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li>
</ul>
<hr>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109103411819.png" alt="image-20230109103411819"></p>
<hr>
<p><strong>获取Class类的实例（四种方法）</strong></p>
<ol>
<li><p>前提：若已知具体的类，通过<strong>类的class属性</strong>获取，该方法最为安全可靠， 程序性能最高</p>
<ul>
<li>实例：<code>Class clazz = String.class;</code></li>
</ul>
</li>
<li><p>前提：已知某个类的实例，调用该实例的<strong>getClass()方法</strong>获取Class对象</p>
<ul>
<li>实例：<code>Class clazz = &quot;www.atguigu.com&quot;.getClass();</code></li>
</ul>
</li>
<li><p>前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方 法**forName()**获取，可能抛出ClassNotFoundException</p>
<ul>
<li>实例：<code>Class clazz = Class.forName(“java.lang.String”);</code></li>
</ul>
</li>
<li><p>其他方式(不做要求)：使用类的加载器</p>
<ul>
<li><p><code>ClassLoader cl = this.getClass().getClassLoader();</code>  </p>
<p><code>Class clazz4 = cl.loadClass(“类的全类名”);</code></p>
</li>
</ul>
</li>
</ol>
<hr>
<p>哪些类型可以作为Class类的实例对象</p>
<ul>
<li><p>class：</p>
<p>外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</p>
</li>
<li><p>interface：接口</p>
</li>
<li><p>[]：数组</p>
</li>
<li><p>enum：枚举</p>
</li>
<li><p>annotation：注解@interface</p>
</li>
<li><p>primitive type：基本数据类型</p>
</li>
<li><p>void</p>
</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109112242441.png" alt="image-20230109112242441"></p>
<h2 id="3-类的加载与ClassLoader"><a href="#3-类的加载与ClassLoader" class="headerlink" title="3. 类的加载与ClassLoader"></a>3. 类的加载与ClassLoader</h2><p><strong>了解：类的加载过程</strong></p>
<p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过 如下三个步骤来对该类进行初始化。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109104028232.png" alt="image-20230109104028232"></p>
<ul>
<li>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问 入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的 过程需要类加载器参与。</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul>
<li>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并<strong>设置类变量默认初始值</strong>的阶段，这些内存 都将在方法区中进行分配。</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
</ul>
</li>
<li>初始化：<ul>
<li>执行<strong>类构造器<clinit>()<strong>方法的过程。</strong>类构造器<clinit>()<strong>方法是</strong>由编译期自动收集类中 所有类变量的赋值动作和静态代码块中的语句合并产生的</strong>。（类构造器是构造类信 息的，不是构造该类对象的构造器）。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>了解：什么时候会发生类初始化？</strong></p>
<ul>
<li>类的主动引用（一定会发生类的初始化）<ul>
<li>当虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了final常量）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li>
</ul>
</li>
<li>类的被动引用（不会发生类的初始化）<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化<ul>
<li>当通过子类引用父类的静态变量，不会导致子类初始化</li>
</ul>
</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化</li>
</ul>
</li>
</ul>
<hr>
<p>类加载器的作用：</p>
<ul>
<li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据<strong>转换成方法区的运行时数据结构</strong>，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。</li>
<li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器  中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109104435182.png" alt="image-20230109104435182"></p>
<hr>
<p><strong>了解：ClassLoader</strong></p>
<p>类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的 类的加载器。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109104520362.png" alt="image-20230109104520362"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取一个系统类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classloader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//2.获取系统类加载器的父类加载器，即扩展类加载器</span></span><br><span class="line">classloader = classloader.getParent();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//3.获取扩展类加载器的父类加载器，即引导类加载器</span></span><br><span class="line">classloader = classloader.getParent();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//4.测试当前类由哪个类加载器进行加载</span></span><br><span class="line">classloader = Class.forName(<span class="string">&quot;exer2.ClassloaderDemo&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//5.测试JDK提供的Object类由哪个类加载器加载</span></span><br><span class="line">classloader =</span><br><span class="line">Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//*6.关于类加载器的一个主要方法：getResourceAsStream(String str):获取类路 径下的指定文件的输入流</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">in = <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;exer2\\test.properties&quot;</span>);</span><br><span class="line">System.out.println(in);</span><br></pre></td></tr></table></figure>



<h2 id="4-创建运行时类的对象"><a href="#4-创建运行时类的对象" class="headerlink" title="4. 创建运行时类的对象"></a>4. 创建运行时类的对象</h2><p><strong>创建类的对象</strong>：调用Class对象的newInstance()方法</p>
<p>要求：</p>
<ul>
<li>类必须有一个无参数的构造器。</li>
<li>类的构造器的访问权限需要足够。</li>
</ul>
<hr>
<p><strong>难道没有无参的构造器就不能创建对象了吗？</strong></p>
<p>不是！只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。</p>
<p>步骤如下：</p>
<ul>
<li>通过Class类的<strong>getDeclaredConstructor(Class</strong> <strong>…</strong> **parameterTypes)**取得本类的指定形参类 型的构造器</li>
<li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li>
<li>通过Constructor实例化对象。</li>
</ul>
<blockquote>
<p>在Constructor类中存在一个方法</p>
<p><code>public T newInstance(Object... initargs)</code></p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.根据全类名获取对应的Class对象 String name = “atguigu.java.Person&quot;;  Class clazz = null;</span></span><br><span class="line">clazz = Class.forName(name);</span><br><span class="line"><span class="comment">//2.调用指定参数结构的构造器，生成Constructor的实例</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getConstructor(String.class,Integer.class);</span><br><span class="line"><span class="comment">//3.通过Constructor的实例创建对应类的对象，并初始化类属性  </span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> (Person) con.newInstance(<span class="string">&quot;Peter&quot;</span>,<span class="number">20</span>); System.out.println(p2);</span><br></pre></td></tr></table></figure>



<h2 id="5-获取运行时类的完整结构"><a href="#5-获取运行时类的完整结构" class="headerlink" title="5. 获取运行时类的完整结构"></a>5. 获取运行时类的完整结构</h2><p>通过反射获取运行时类的完整结构</p>
<p><strong>Field</strong>、<strong>Method</strong>、<strong>Constructor</strong>、<strong>Superclass</strong>、<strong>Interface</strong>、<strong>Annotation</strong></p>
<ul>
<li>实现的全部接口</li>
<li>所继承的父类</li>
<li>全部的构造器</li>
<li>全部的方法</li>
<li>全部的Field</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.实现的全部接口</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getInterfaces()</span><br><span class="line">确定此对象所表示的类或接口实现的接口。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.所继承的父类</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;? Super T&gt; getSuperclass()</span><br><span class="line">返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的Class。</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.全部的构造器</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt;[] getConstructors()</span><br><span class="line">返回此 Class 对象所表示的类的所有<span class="keyword">public</span>构造方法。</span><br><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt;[] getDeclaredConstructors()</span><br><span class="line">返回此 Class 对象表示的类声明的所有构造方法。</span><br><span class="line"></span><br><span class="line">Constructor类中：</span><br><span class="line">取得修饰符: <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span>;</span><br><span class="line">取得方法名称: <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">取得参数的类型：<span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.全部的方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods()</span><br><span class="line">返回此Class对象所表示的类或接口的全部方法</span><br><span class="line"><span class="keyword">public</span> Method[] getMethods()</span><br><span class="line">返回此Class对象所表示的类或接口的<span class="keyword">public</span>的方法</span><br><span class="line"></span><br><span class="line">Method类中：</span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getReturnType()取得全部的返回值</span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes()取得全部的参数</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span>取得修饰符</span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getExceptionTypes()取得异常信息</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.全部的Field</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields()</span><br><span class="line">返回此Class对象所表示的类或接口的<span class="keyword">public</span>的Field。</span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields()</span><br><span class="line">返回此Class对象所表示的类或接口的全部Field。</span><br><span class="line"></span><br><span class="line">Field方法中：</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span>	以整数形式返回此Field的修饰符</span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getType()	得到Field的属性类型</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>	返回Field的名称。</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.Annotation相关</span></span><br><span class="line">get <span class="title function_">Annotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span></span><br><span class="line">getDeclaredAnnotations()</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.泛型相关</span></span><br><span class="line">获取父类泛型类型：Type <span class="title function_">getGenericSuperclass</span><span class="params">()</span></span><br><span class="line">泛型类型：ParameterizedType</span><br><span class="line">获取实际的泛型类型参数数组：getActualTypeArguments()</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.类所在的包	Package getPackage()</span></span><br></pre></td></tr></table></figure>



<h2 id="6-调用运行时类的指定结构"><a href="#6-调用运行时类的指定结构" class="headerlink" title="6. 调用运行时类的指定结构"></a>6. 调用运行时类的指定结构</h2><p>① <strong>调用指定方法</strong></p>
<p>通过反射，调用类中的方法，通过Method类完成。步骤：</p>
<ul>
<li>通过Class类的<code>getMethod(String name,Class…parameterTypes)</code>方法取得 一个Method对象，并设置此方法操作时所需要的参数类型。</li>
<li>之后使用<code>Object invoke(Object obj, Object[] args)</code>进行调用，并向方法中传递要设置的obj对象的参数信息。</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109105458268.png" alt="image-20230109105458268"></p>
<hr>
<p><code>Object invoke(Object obj, Object … args)</code></p>
<ul>
<li>Object 对应原方法的返回值，若原方法无返回值，此时返回null</li>
<li>若原方法若为静态方法，此时形参Object obj可为null</li>
<li>若原方法形参列表为空，则Object[] args为null</li>
<li>若原方法声明为private,则需要在调用此invoke()方法前，显式调用 方法对象的setAccessible(true)方法，将可访问private的方法。</li>
</ul>
<blockquote>
<p>通过反射机制调用方法的四要素：</p>
<ul>
<li>哪个对象</li>
<li>调用的方法名</li>
<li>方法需要传什么参数</li>
<li>方法的返回值类型</li>
</ul>
</blockquote>
<hr>
<p><strong>② 调用指定属性</strong></p>
<p>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。</p>
<ul>
<li><code>public Field getField(String name)</code> 返回此Class对象表示的类或接口的指定的public的Field。</li>
<li><code>public Field getDeclaredField(String name)</code>返回此Class对象表示的类或接口的指定的Field。</li>
</ul>
<p>在<strong>Field</strong>中：</p>
<p><code>public Object get(Object obj)</code> 取得指定对象obj上此Field的属性内容</p>
<p><code>public void set(Object obj,Object value)</code> 设置指定对象obj上此Field的属性内容</p>
<hr>
<p>关于<strong>setAccessible方法</strong>的使用</p>
<ul>
<li>Method和Field、Constructor对象都有setAccessible()方法。</li>
<li>setAccessible启动和禁用访问安全检查的开关。</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。<ul>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被 调用，那么请设置为true。</li>
<li>使得原本无法访问的私有成员也可以访问</li>
</ul>
</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检查。</li>
</ul>
<h2 id="7-动态代理"><a href="#7-动态代理" class="headerlink" title="7. 动态代理"></a>7. 动态代理</h2><p><strong>代理设计模式的原理:</strong></p>
<p>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p>
<ul>
<li><p>之前为大家讲解过代理机制的操作，属于静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。<strong>最好可以通过一个代理类完成全部的代理功能。</strong></p>
</li>
<li><p>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时 根据需要动态创建目标类的代理对象。</p>
</li>
<li><p>动态代理使用场合:</p>
<ul>
<li>调试</li>
<li>远程方法调用</li>
</ul>
</li>
<li><p>动态代理相比于静态代理的优点：</p>
<p>抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中 处理，这样，我们可以更加灵活和统一的处理众多的方法。</p>
</li>
</ul>
<hr>
<p><strong>Java动态代理相关API</strong></p>
<p><strong>Proxy</strong> ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。</p>
<p>提供用于创建动态代理类和动态代理对象的静态方法</p>
<ul>
<li><code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</code> 创建 一个动态代理类所对应的Class对象</li>
<li><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code> 直接创建一个动态代理对象</li>
</ul>
<blockquote>
<p>第一个参数：类的加载器</p>
<p>第二个参数：被代理类实现的全部接口，从而可以实现返回的对象是实现了同一些接口的类的对象，确保一致性</p>
<p>第三个参数：InvocationHandler接口的实现类实例，确保当我们哦那个过代理类的对象调用方法a时，就会自动调用InvacationHandler接口中的invoke()</p>
</blockquote>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109110402197.png" alt="image-20230109110402197"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109110511641.png" alt="image-20230109110511641"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109110525421.png" alt="image-20230109110525421"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109110534262.png" alt="image-20230109110534262"></p>
<hr>
<p><strong>动态代理 和 AOP（Aspect Orient Programming）</strong></p>
<p>前面介绍的Proxy和InvocationHandler，很难看出这种动态代理的优势，下面介绍一种更实用的动态代理机制</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109110743336.png" alt="image-20230109110743336"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109110800267.png" alt="image-20230109110800267"></p>
<hr>
<p>使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有 太大的意义。通常都是为指定的目标对象生成动态代理</p>
<p>这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理 包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异： <strong>AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230109110909906.png" alt="image-20230109110909906"></p>
<hr>
<p><strong>反射机制 总结</strong></p>
<p><strong>一、关于java.lang.Class类的理解</strong></p>
<ul>
<li>① 类的加载过程：<br>程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。<br>接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。</li>
<li>② 换句话说，Class的实例就对应着一个运行时类。</li>
<li>③ 加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</li>
</ul>
<p><strong>二、获取Class的实例</strong></p>
<p>① 调用运行时类的属性：.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Person.class;</span><br></pre></td></tr></table></figure>

<p>② 通过运行时类的对象,调用getClass()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> p1.getClass();</span><br></pre></td></tr></table></figure>

<p>③ 调用Class的静态方法：forName(String classPath)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>④ 使用类的加载器：ClassLoader  (了解)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectionTest.class.getClassLoader();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz4</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>三、创建类的对象的方式</strong></p>
<p>① new + 构造器</p>
<p>② 要创建Xxx类的对象，可以考虑：Xxx、Xxxs、XxxFactor、XxxBuilder类中查看是否有静态方法得的存在。可以调用其静态方法，创建Xxx对象。</p>
<p>③ 通过反射机制</p>
<p><strong>四、通过反射调用指定结构</strong></p>
<p><strong>① 调用属性</strong></p>
<p><code>getDeclaredField(String name)</code>：传入指定属性名参数，返回一个Filed类对象</p>
<p><code>set()</code>：设置属性值</p>
<p><code>get()</code>：获取属性值</p>
<p><strong>② 调用方法</strong></p>
<p><code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：传入一个指定方法名的参数，还有对应方法的可变个数的形参列表，返回一个Method类的对象</p>
<p><code>invoke(Object obj, Object... args)</code>：传入方法的调用对象，以及对应的可变个数的实参列表</p>
<p><strong>③ 调用构造器</strong></p>
<p><code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code>：参数是一个可变个数的Class类对象实例的形参列表，返回一个Constructor类的对象</p>
<p><code>newInstance()</code>：传入一个与constructor对象对应的可变个数的实参</p>
<blockquote>
<p>以上结构都需要调用<code>setAccessible(true)</code>，将结构设置为可访问</p>
</blockquote>
<p><strong>五、反射的应用：动态代理</strong></p>
<p><strong>需要解决的两个主要问题</strong></p>
<p>① 如何根据加载到内存中的被代理类，动态地创建一个代理类及其对象？</p>
<p>通过Proxy.newProxyInstance()实现</p>
<p>② 当通过代理类的对象调用方法a时，如何动态去调用被代理类中的同名方法a？</p>
<p>通过InvocationHandler接口的实现类及其方法invoke()</p>
<h1 id="第十五章-gt-gt-gt-Java8的其他新特性"><a href="#第十五章-gt-gt-gt-Java8的其他新特性" class="headerlink" title="第十五章&gt;&gt;&gt;Java8的其他新特性"></a>第十五章&gt;&gt;&gt;Java8的其他新特性</h1><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110102009954.png" alt="image-20230110102009954"></p>
<ul>
<li>速度更快</li>
<li>代码更少(增加了新的语法：<strong>Lambda</strong> 表达式)</li>
<li>强大的 <strong>Stream</strong> <strong>API</strong></li>
<li>便于并行</li>
<li>最大化减少空指针异常：Optional</li>
<li>Nashorn引擎，允许在JVM上运行JS应用</li>
</ul>
<hr>
<p><strong>并行流和串行流</strong></p>
<ul>
<li>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</li>
<li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。 Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流 之间进行切换。</li>
</ul>
<h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h2><p>Lambda 是一个<strong>匿名函数</strong>，我们可以把 Lambda 表达式理解为是<strong>一段可以传递的代码</strong>（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<hr>
<p>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “**-&gt;**” ， 该操作符被称为 <strong>Lambda 操作符</strong> 或 <strong>箭头操作符</strong>。它将 Lambda 分为两个部分：</p>
<ul>
<li>左侧：指定了 Lambda 表达式需要的<strong>参数列表</strong></li>
<li>右侧：指定了 <strong>Lambda</strong> 体，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功能。</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110102352631.png" alt="image-20230110102352631"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110102359154.png" alt="image-20230110102359154"></p>
<hr>
<p><strong>类型推断</strong></p>
<p>上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“<strong>类型推断</strong>”。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110102437414.png" alt="image-20230110102437414"></p>
<h2 id="2-函数式-Functional-接口"><a href="#2-函数式-Functional-接口" class="headerlink" title="2. 函数式(Functional)接口"></a>2. 函数式(Functional)接口</h2><p><strong>什么是函数式(Functional)接口</strong></p>
<ul>
<li><strong>只包含一个抽象方法的接口，称为函数式接口。</strong></li>
<li>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式 抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</li>
<li>我们可以在一个接口上使用 <strong>@FunctionalInterface</strong> 注解，这样做可以检 查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个 接口是一个函数式接口。</li>
<li><strong>在java.util.function包下定义了Java 8 的丰富的函数式接口</strong></li>
</ul>
<hr>
<p><strong>如何理解函数式接口</strong></p>
<ul>
<li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP) 编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不 得不做出调整以便支持更加广泛的技术要求，也即<strong>java不但可以支持OOP还 可以支持OOF（面向函数编程）</strong></li>
<li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的 编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在 Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的 对象类型——<strong>函数式接口</strong>。</li>
<li>简单的说，在Java8中，<strong>Lambda表达式就是一个函数式接口的实例</strong>。这就是 Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口 的实例，那么该对象就可以用Lambda表达式来表示。</li>
<li><strong>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</strong></li>
</ul>
<hr>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110102729452.png" alt="image-20230110102729452"></p>
<hr>
<p><strong>作为参数传递 Lambda 表达式</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110102757248.png" alt="image-20230110102757248"></p>
<blockquote>
<p>作为参数传递 <strong>Lambda</strong> 表达式：为了将 <strong>Lambda</strong> 表达式作为参数传递，接收<strong>Lambda</strong>表达式的参数类型必须是与该 <strong>Lambda</strong> 表达式兼容的函数式接口的类型。</p>
</blockquote>
<hr>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110103059751.png" alt="image-20230110103059751"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110103039403.png" alt="image-20230110103039403"></p>
<h2 id="3-方法引用和构造器引用"><a href="#3-方法引用和构造器引用" class="headerlink" title="3. 方法引用和构造器引用"></a>3. 方法引用和构造器引用</h2><p><strong>方法引用(Method References)</strong></p>
<ul>
<li>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</li>
<li>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就 是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向 一个方法，可以认为是Lambda表达式的一个语法糖。</li>
<li>要求：<strong>实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的 方法的参数列表和返回值类型保持一致！</strong></li>
<li>格式：使用操作符 “**::**” 将 类(或对象) 与 方法名 分隔开来。</li>
<li>如下三种主要使用情况：<ul>
<li><strong>对象::实例方法名</strong></li>
<li><strong>类::静态方法名</strong></li>
<li><strong>类::实例方法名</strong></li>
</ul>
</li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110103222129.png" alt="image-20230110103222129"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110103252417.png" alt="image-20230110103252417"></p>
<blockquote>
<p>当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数**(<strong>或无参数</strong>)<strong>时：</strong>ClassName::methodName**</p>
</blockquote>
<hr>
<p><strong>构造器引用</strong></p>
<ul>
<li>格式： <strong>ClassName::new</strong></li>
<li>与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，要求<strong>构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</strong></li>
</ul>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110103437837.png" alt="image-20230110103437837"></p>
<hr>
<p><strong>数组引用</strong></p>
<p>格式： <strong>type[] :: new</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110103515802.png" alt="image-20230110103515802"></p>
<h2 id="4-强大的StreamAPI"><a href="#4-强大的StreamAPI" class="headerlink" title="4. 强大的StreamAPI"></a>4. 强大的StreamAPI</h2><p>Java8中有两大最为重要的改变。第一个是 <strong>Lambda</strong> 表达式；另外一个则 是 <strong>Stream API</strong>。</p>
<p><strong>Stream API ( java.util.stream)</strong> 把真正的函数式编程风格引入到Java中。这 是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程 序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
<p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进 行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 <strong>使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询</strong>。 也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种 高效且易于使用的处理数据的方式。</p>
<hr>
<p><strong>为什么使用StreamAPI</strong></p>
<ul>
<li>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数 据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要 Java层面去处理。</li>
<li>Stream 和 Collection 集合的区别：<strong>Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。</strong>前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</li>
</ul>
<hr>
<p><strong>什么是Stream</strong></p>
<p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 “集合讲的是数据，<strong>Stream</strong>讲的是计算！”</p>
<ul>
<li>Stream 自己不会存储元素。</li>
<li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li>
<li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li>
</ul>
<hr>
<p><strong>Stream的操作三大步骤</strong></p>
<ol>
<li><p><strong>创建 Stream</strong></p>
<p>一个数据源（如：集合、数组），获取一个流</p>
</li>
<li><p><strong>中间操作</strong></p>
<p>一个中间操作链，对数据源的数据进行处理</p>
</li>
<li><p><strong>终止操作(终端操作)</strong></p>
<p>一旦执行终止操作，<strong>就执行中间操作链</strong>，并产生结果。之后，不会再被使用</p>
</li>
</ol>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110103921776.png" alt="image-20230110103921776"></p>
<hr>
<p><strong>创建Stream方式一：通过集合</strong></p>
<p>Java8 中的 Collection 接口被扩展，提供了两个获取流 的方法：</p>
<ul>
<li><strong>default</strong> <strong>Stream<E> stream()</strong> <strong>:</strong> 返回一个<strong>顺序流</strong></li>
<li><strong>default</strong> <strong>Stream<E></strong> <strong>parallelStream()</strong> <strong>:</strong> 返回一个<strong>并行流</strong></li>
</ul>
<p><strong>创建Stream方式二：通过数组</strong></p>
<p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p>
<ul>
<li><strong>static</strong> <strong><T></strong> <strong>Stream<T></strong> <strong>stream(T[]</strong> <strong>array):</strong> 返回一个流</li>
</ul>
<p>重载形式，能够处理对应基本类型的数组：</p>
<ul>
<li>public static IntStream stream(int[] array)</li>
<li>public static LongStream stream(long[] array)</li>
<li>public static DoubleStream stream(double[] array)</li>
</ul>
<p><strong>创建 Stream方式三：通过Stream的of()</strong></p>
<p>可以调用Stream类静态方法 of(), 通过显示值创建一个 流。它可以接收任意数量的参数。</p>
<ul>
<li><strong>public</strong> <strong>static<T></strong> <strong>Stream<T></strong> <strong>of(T…</strong> <strong>values)</strong> <strong>:</strong> 返回一个流</li>
</ul>
<p><strong>创建 Stream方式四：创建无限流</strong></p>
<p>可以使用静态方法 Stream.iterate() 和 Stream.generate()，创建无限流。</p>
<ul>
<li><p>迭代</p>
<p><strong>public</strong> <strong>static<T></strong> <strong>Stream<T></strong> <strong>iterate(final</strong> <strong>T</strong> <strong>seed,</strong> <strong>final</strong> <strong>UnaryOperator<T></strong> <strong>f)</strong></p>
</li>
<li><p>生成</p>
<p><strong>public</strong> <strong>static<T></strong> <strong>Stream<T></strong> <strong>generate(Supplier<T></strong> <strong>s)</strong></p>
</li>
</ul>
<hr>
<p><strong>Stream的中间操作</strong></p>
<p>多个<strong>中间操作</strong>可以连接起来形成一个<strong>流水线</strong>，除非流水线上触发终止 操作，否则<strong>中间操作不会执行任何的处理</strong>！而<strong>在终止操作时一次性全 部处理，称为“惰性求值”</strong>。</p>
<p><strong>① 筛选与切片</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110104439240.png" alt="image-20230110104439240"></p>
<p><strong>② 映射</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110104524219.png" alt="image-20230110104524219"></p>
<p><strong>③ 排序</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110104545587.png" alt="image-20230110104545587"></p>
<hr>
<p><strong>Stream的终止操作</strong></p>
<ul>
<li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</li>
<li>流进行了终止操作后，不能再次使用。</li>
</ul>
<p><strong>① 匹配与查找</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110104640511.png" alt="image-20230110104640511"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110104658763.png" alt="image-20230110104658763"></p>
<p><strong>② 归约</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110104721299.png" alt="image-20230110104721299"></p>
<blockquote>
<p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p>
</blockquote>
<p><strong>③ 收集</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110104810058.png" alt="image-20230110104810058"></p>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、 Map)。</p>
<p>另外， <strong>Collectors 实用类提供了很多静态方法</strong>，可以方便地创建常见收集器实例，具体方法与实例如下表：</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110104911916.png" alt="image-20230110104911916"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110104942158.png" alt="image-20230110104942158"></p>
<h2 id="5-Optional类"><a href="#5-Optional类" class="headerlink" title="5. Optional类"></a>5. Optional类</h2><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。 以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类， Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代 码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p>
<p><strong>Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表 这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不 存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</strong></p>
<p>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在 则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<hr>
<p><strong>Optional提供很多有用的方法，这样我们就不用显式进行空值检测</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230110105116550.png" alt="image-20230110105116550"></p>
<hr>
<p><strong>Java其他新特性 总结</strong></p>
<p><strong>一、Lambda表达式的使用</strong></p>
<ol>
<li><p>举例： (o1,o2) -&gt; Integer.compare(o1,o2);</p>
</li>
<li><p>格式：</p>
<ul>
<li>-&gt; :lambda操作符 或 箭头操作符</li>
<li>-&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）</li>
<li>-&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）</li>
</ul>
</li>
<li><p>Lambda表达式的使用：（分为6种情况介绍）</p>
<ul>
<li>总结为：</li>
<li>-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略</li>
<li>-&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字</li>
</ul>
</li>
<li><p>Lambda表达式的本质：作为函数式接口的实例</p>
</li>
<li><p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。</p>
</li>
<li><p>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</p>
</li>
</ol>
<blockquote>
<p>通用格式为：( object o1, object o2…) -&gt; {方法体}</p>
</blockquote>
<p><strong>二、Java内置四大函数式接口</strong></p>
<ul>
<li>消费型接口 Consumer<T>     void accept(T t)</li>
</ul>
<ul>
<li>供给型接口 Supplier<T>          T get()</li>
<li>函数型接口 Function&lt;T,R&gt;      R apply(T t)</li>
<li>断定型接口 Predicate<T>        boolean test(T t)</li>
</ul>
<p><strong>三、方法引用</strong></p>
<ol>
<li><p>使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>
</li>
<li><p>方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以方法引用，也是函数式接口的实例。</p>
</li>
<li><p>使用格式：  类(或对象) :: 方法名</p>
</li>
<li><p>具体分为如下的三种情况：</p>
<ul>
<li>情况1     对象 :: 非静态方法</li>
<li>情况2     类 :: 静态方法</li>
<li>情况3     类 :: 非静态方法</li>
</ul>
</li>
<li><p>方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</p>
</li>
</ol>
<p><strong>四、构造器引用和数组引用</strong></p>
<p>① 构造器引用</p>
<p>和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型</p>
<p>② 数组引用</p>
<p>大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。</p>
<p><strong>五、StreamAPI</strong></p>
<ol>
<li><p>Stream关注的是对数据的运算，与CPU打交道</p>
<p>集合关注的是数据的存储，与内存打交道</p>
</li>
<li><p>注意：</p>
<ul>
<li>①Stream 自己不会存储元素。</li>
<li>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li>
<li>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</li>
</ul>
</li>
<li><p>Stream 执行流程</p>
<ul>
<li>① Stream的实例化</li>
<li>② 一系列的中间操作（过滤、映射、…)</li>
<li>③ 终止操作</li>
</ul>
</li>
<li><p>说明：</p>
<ul>
<li>一个中间操作链，对数据源的数据进行处理</li>
<li>一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</li>
</ul>
</li>
<li><p>创建Stream的方式</p>
<ul>
<li>通过集合</li>
<li>通过数组</li>
<li>通过Stream的of()</li>
<li>创建无限流</li>
</ul>
</li>
</ol>
<p><strong>六、Optional类</strong></p>
<ul>
<li>Optional类：为了在程序中避免出现空指针异常而创建的。</li>
</ul>
<ul>
<li>常用的方法：<ul>
<li>ofNullable(T t)</li>
<li>orElse(T t)</li>
</ul>
</li>
</ul>
<h1 id="第十六章-gt-gt-gt-Java9-Java11新特性"><a href="#第十六章-gt-gt-gt-Java9-Java11新特性" class="headerlink" title="第十六章&gt;&gt;&gt;Java9 ~ Java11新特性"></a>第十六章&gt;&gt;&gt;Java9 ~ Java11新特性</h1><h2 id="1-Java9新特性"><a href="#1-Java9新特性" class="headerlink" title="1. Java9新特性"></a>1. Java9新特性</h2><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111174936459.png" alt="image-20230111174936459"></p>
<h3 id="1-1-JDK-和-JRE-目录结构的改变"><a href="#1-1-JDK-和-JRE-目录结构的改变" class="headerlink" title="1.1 JDK 和 JRE 目录结构的改变"></a>1.1 JDK 和 JRE 目录结构的改变</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111175239467.png" alt="image-20230111175239467"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111175247642.png" alt="image-20230111175247642"></p>
<h3 id="1-2-模块化系统"><a href="#1-2-模块化系统" class="headerlink" title="1.2 模块化系统"></a>1.2 模块化系统</h3><blockquote>
<p>Jigsaw –&gt; Modularity</p>
</blockquote>
<ul>
<li><p><strong>谈到 Java 9 大家往往第一个想到的就是 Jigsaw 项目。</strong>众所周知，Java 已经 发展超过 20 年（95 年最初发布），Java 和相关生态在不断丰富的同时也越 来越暴露出一些问题：</p>
<ul>
<li><p><strong>Java 运行环境的膨胀和臃肿</strong>。每次JVM启动的时候，至少会有30～60MB的内存</p>
</li>
<li><p>加载，主要原因是<strong>JVM需要加载rt.jar</strong>，不管其中的类是否被classloader加载，第 一步整个jar都会被JVM加载到内存当中去（而模块化可以根据模块的需要加载程序运行需要的class）</p>
</li>
<li><p><strong>当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长</strong>。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了 Java 开发和运行效率的提升。</p>
</li>
<li><p>很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间 的依赖关系有个明确的概念。<strong>每一个公共类都可以被类路径之下任何其它的公共类所访问到，这样就会导致无意中使用了并不想被公开访问的API。</strong></p>
</li>
</ul>
</li>
<li><p>本质上讲也就是说，用模块来管理各个package，通过声明某个package 暴露，，<strong>模块(module)的概念，其实就是package外再裹一层</strong>，不声明默 认就是隐藏。因此，模块化使得代码组织上<strong>更安全</strong>，因为它可以<strong>指定哪 些部分可以暴露，哪些部分隐藏</strong>。</p>
</li>
<li><p>实现目标</p>
<ul>
<li>模块化的主要目的在于减少内存的开销</li>
<li>只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开 发和维护</li>
<li>改进 Java SE 平台，使其可以适应不同大小的计算设备</li>
<li>改进其安全性，可维护性，提高性能</li>
</ul>
</li>
</ul>
<hr>
<p>模块将由通常的类和新的模块声明文件（module-info.java）组成。该文件是位于 java代码结构的顶层，该模块描述符明确地定义了我们的<strong>模块需要什么依赖关系， 以及哪些模块被外部使用</strong>。在exports子句中未提及的所有包默认情况下将封装在模块中，不能在外部使用。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111175650456.png" alt="image-20230111175650456"></p>
<ul>
<li>要想在java9demo模块中调用java9test模块下包中的结构，需要在java9test 的module-info.java中声明：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> java9test &#123;</span><br><span class="line">    <span class="comment">//package we export</span></span><br><span class="line">    <span class="keyword">exports</span> com.atguigui.bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>exports</strong>：控制着哪些包可以被其它模块访问到。所有不被导出的包默认 都被封装在模块里面。</p>
</blockquote>
<ul>
<li>对应在java 9demo 模块的src 下创建module-info.java文件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> java9demo &#123;</span><br><span class="line">	<span class="keyword">requires</span> java9test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>requires</strong>：指明对其它模块的依赖。</p>
</blockquote>
<h3 id="1-3-Java得REPL工具：jShell命令"><a href="#1-3-Java得REPL工具：jShell命令" class="headerlink" title="1.3 Java得REPL工具：jShell命令"></a>1.3 Java得REPL工具：jShell命令</h3><p><strong>产生背景</strong></p>
<p>像<strong>Python 和 Scala  之类的语言早就有交互式编程环境 REPL  (read  -  evaluate -  print -loop)<strong>了，以交互式的方式对语句和表达式进行求值。开发者只需要输入一些代码， 就可以在编译前获得对程序的反馈。而</strong>之前的Java版本要想执行代码，必须创建文件、声明类、提供测试方法方可实现</strong>。</p>
<hr>
<p><strong>设计理念</strong></p>
<ul>
<li>即写即得、快速运行</li>
</ul>
<hr>
<p><strong>实现目标</strong></p>
<ul>
<li>Java 9 中终于拥有了 REPL工具：jShell。让Java可以像脚本语言一样运行，从 控制台启动jShell，利用jShell在没有创建类的情况下直接声明变量，计算表达式， 执行语句。即开发时可以在命令行里直接运行Java的代码，而无需创建Java文件，无需跟人解释”public static void main(String[] args)”这句废话。</li>
<li>jShell也可以从文件中加载语句或者将语句保存到文件中。</li>
<li>jShell也可以是tab键进行自动补全和自动添加分号。</li>
</ul>
<hr>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111180157336.png" alt="image-20230111180157336"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111180212734.png" alt="image-20230111180212734"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111180223229.png" alt="image-20230111180223229"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111180235762.png" alt="image-20230111180235762"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111180247993.png" alt="image-20230111180247993"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111180259939.png" alt="image-20230111180259939"></p>
<h3 id="1-4-接口的私有方法"><a href="#1-4-接口的私有方法" class="headerlink" title="1.4 接口的私有方法"></a>1.4 接口的私有方法</h3><ul>
<li>Java 8中规定接口中的方法除了抽象方法之外，还可以定义静态方法 和默认的方法。一定程度上，扩展了接口的功能，此时的接口更像是 一个抽象类。</li>
<li>在Java 9中，接口更加的灵活和强大，<strong>连方法的访问权限修饰符都可  以声明为private的了</strong>，此时方法将不会成为你对外暴露的API的一部分。</li>
</ul>
<h3 id="1-5-钻石操作符使用升级"><a href="#1-5-钻石操作符使用升级" class="headerlink" title="1.5 钻石操作符使用升级"></a>1.5 钻石操作符使用升级</h3><p>我们将能够与匿名实现类共同使用钻石操作符（diamond operator）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anonymous classes can now use type inference</span></span><br><span class="line">Comparator&lt;Object&gt; com = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1-6-try语句"><a href="#1-6-try语句" class="headerlink" title="1.6 try语句"></a>1.6 try语句</h3><p>用资源语句编写try将更容易，我们<strong>可以在try子句中使用已经初始 化过的资源，此时的资源是final的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);  <span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out);  </span><br><span class="line"><span class="keyword">try</span> (reader; writer) &#123;</span><br><span class="line">    <span class="comment">//reader是final的，不可再被赋值</span></span><br><span class="line">    <span class="comment">//reader = null;</span></span><br><span class="line">    <span class="comment">//具体读写操作省略</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-7-String存储结构变更"><a href="#1-7-String存储结构变更" class="headerlink" title="1.7 String存储结构变更"></a>1.7 String存储结构变更</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111180626005.png" alt="image-20230111180626005"></p>
<h3 id="1-8-集合工厂方法：快速创建只读集合"><a href="#1-8-集合工厂方法：快速创建只读集合" class="headerlink" title="1.8 集合工厂方法：快速创建只读集合"></a>1.8 集合工厂方法：快速创建只读集合</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111180710361.png" alt="image-20230111180710361"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111180752648.png" alt="image-20230111180752648"></p>
<h3 id="1-9-InputStream-加强"><a href="#1-9-InputStream-加强" class="headerlink" title="1.9 InputStream 加强"></a>1.9 InputStream 加强</h3><p>InputStream 终于有了一个非常有用的方法：<strong>transferTo</strong>，可以用来将数据直接 传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> cl.getResourceAsStream(<span class="string">&quot;hello.txt&quot;</span>);  <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\hello1.txt&quot;</span>)) &#123;</span><br><span class="line">	is.transferTo(os); <span class="comment">// 把输入流中的所有数据直接自动地复制到输出流中</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-10-增强的Stream-API"><a href="#1-10-增强的Stream-API" class="headerlink" title="1.10 增强的Stream API"></a>1.10 增强的Stream API</h3><p>Java 的 <strong>Steam API 是java标准库最好的改进之一，让开发者能够快速运算， 从而能够有效的利用数据并行计算</strong>。Java 8 提供的 Steam 能够利用多核架构 实现声明式的数据处理。</p>
<p>在Java 9 中，Stream API 变得更好，Stream 接口中添加了 4 个新的方法： <strong>takeWhile, dropWhile, ofNullable，还有个 iterate 方法的新重载方法</strong>，可以 让你提供一个Predicate (判断条件)来指定什么时候结束迭代。</p>
<p>除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。 现在可以<strong>通过 Optional 的新方法 stream() 将一个 Optional 对象转换为一个 (可能是空的) Stream 对象</strong>。</p>
<hr>
<p><strong>takeWhile()的使用</strong></p>
<p>用于从 Stream 中获取一部分数据，接收一个 Predicate 来进行选择。在有序的Stream 中，<strong>takeWhile 返回从开头开始的尽量多的元素。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);  </span><br><span class="line">list.stream().takeWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>); list.stream().takeWhile(x -&gt; x &lt; <span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>dropWhile()的使用</strong></p>
<p>dropWhile 的行为与takeWhile 相反，<strong>返回剩余的元素。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);  </span><br><span class="line">list.stream().dropWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);  </span><br><span class="line">System.out.println();</span><br><span class="line">list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>); list.stream().dropWhile(x -&gt; x &lt; <span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>ofNullable()的使用</strong></p>
<p>Java 8 中 <strong>Stream 不能完全为null</strong>，否则会报空指针异常。而 Java 9 中的ofNullable 方法允许我们<strong>创建一个单元素 Stream</strong>，可以包含一个非空元素，也可以创建一个空 Stream。</p>
<hr>
<p><strong>iterate()重载的使用</strong></p>
<p>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的控制终止方式：</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 现在的终止方式：</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i &lt; <span class="number">100</span>, i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>



<h3 id="1-11-Optional获取Stream的方法"><a href="#1-11-Optional获取Stream的方法" class="headerlink" title="1.11 Optional获取Stream的方法"></a>1.11 Optional获取Stream的方法</h3><p><strong>Optional</strong>类中**stream()**的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line"></span><br><span class="line">Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list);  Stream&lt;List&lt;String&gt;&gt; stream = optional.stream();  stream.flatMap(x -&gt; x.stream()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>



<h2 id="2-Java10新特性"><a href="#2-Java10新特性" class="headerlink" title="2. Java10新特性"></a>2. Java10新特性</h2><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111181413544.png" alt="image-20230111181413544"></p>
<h3 id="2-1-局部变量类型推断"><a href="#2-1-局部变量类型推断" class="headerlink" title="2.1 局部变量类型推断"></a>2.1 局部变量类型推断</h3><p><strong>产生背景</strong></p>
<ul>
<li>开发者经常抱怨Java中引用代码的程度。<strong>局部变量的显示类型声明，常常被认为 是不必须的</strong>，给一个好听的名字经常可以很清楚的表达出下面应该怎样继续。</li>
</ul>
<p><strong>好处：</strong></p>
<ul>
<li><strong>减少了啰嗦和形式的代码，避免了信息冗余，而且对齐了变量名，更容易阅读！</strong></li>
</ul>
<hr>
<p>场景一：<strong>类实例化时</strong></p>
<p>作为 Java开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第 一次用于声明变量类型，第二次用于构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>场景二：<strong>返回值类型含复杂泛型结构</strong></p>
<p>变量的声明类型书写复杂且较长，尤其是加上泛型的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator();</span><br></pre></td></tr></table></figure>

<p>场景三：<strong>我们也经常声明一种变量，它只会被使用一次，而且是用在下一行代码中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://www.atguigu.com&quot;</span>);  </span><br><span class="line"><span class="type">URLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> url.openConnection();  </span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span>  <span class="title class_">InputStreamReader</span>(connection.getInputStream()));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>尽管IDE可以帮我们自动完成这些代码，但当变量总是跳来跳去的时候，可读性还是会受到影响，因为变量类型的名称由各种不同长度的字符组成。而且，有时候开发人员会尽力避免声明中间变量，因为<strong>太多的类型声明只会分散注意力，不会带来额外的好处</strong>。</p>
</blockquote>
<hr>
<p><strong>适用于以下情况</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.局部变量的初始化</span></span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//2.增强for循环中的索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v : list) &#123;</span><br><span class="line">	System.out.println(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.传统for循环中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;  </span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>在局部变量中使用时，如下情况不适用：</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111182009563.png" alt="image-20230111182009563"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111182021350.png" alt="image-20230111182021350"></p>
<hr>
<p><strong>工作原理</strong></p>
<p><strong>在处理 var时，编译器先是查看表达式右边部分</strong>，并根据右边变量值的类型进行 推断，作为左边变量的类型，然后<strong>将该类型写入字节码当中</strong>。</p>
<hr>
<p>注意：</p>
<ul>
<li><p><strong>var</strong>不是一个关键字</p>
<p>你不需要担心变量名或方法名会与 var发生冲突，因为 var实际上并不是一个关键字，而是一个类型名，只有在编译器需要知道类型的地方才需要用到它。除此之外，它 就是一个普通合法的标识符。也就是说，<strong>除了不能用它作为类名，其他的都可以， 但极少人会用它作为类名。</strong></p>
</li>
<li><p>这不<strong>JavaScript</strong></p>
<p>首先我要说明的是，var<strong>并不会改变Java是一门静态类型语言的事实</strong>。编译器负责推 断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。下面是使用IntelliJ（实际上是Fernflower的反编译器）反编译器反编译出的代码：</p>
</li>
</ul>
<blockquote>
<p>从代码来看，就好像之前已经声明了这些类型一样。事实上，这一特性只发 生在编译阶段，与运行时无关，所以对运行时的性能不会产生任何影响。所 以请放心，这不是JavaScript。</p>
</blockquote>
<h3 id="2-2-集合新增创建不可变集合的方法"><a href="#2-2-集合新增创建不可变集合的方法" class="headerlink" title="2.2 集合新增创建不可变集合的方法"></a>2.2 集合新增创建不可变集合的方法</h3><p>自 Java  9  开始，Jdk  里面为集合（List  &#x2F;  Set  &#x2F;  Map）都添加了 **of  (jdk9新增)和 copyOf (jdk10新增)**方法，它们两个都用来创建不可变的集合，来看下它们的使用和区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例1：</span></span><br><span class="line"><span class="type">var</span> <span class="variable">list1</span> <span class="operator">=</span> List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>);  </span><br><span class="line"><span class="type">var</span> <span class="variable">copy1</span> <span class="operator">=</span> List.copyOf(list1);  System.out.println(list1 == copy1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例2：</span></span><br><span class="line"><span class="type">var</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); </span><br><span class="line"><span class="type">var</span> <span class="variable">copy2</span> <span class="operator">=</span> List.copyOf(list2);</span><br><span class="line">System.out.println(list2 == copy2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<hr>
<p>从 源 码 分 析 ， 可 以 看 出  copyOf   方 法 会 先 判 断 来 源 集 合 是 不 是 AbstractImmutableList 类型的，如果是，就直接返回，如果不是，则调用 of 创建一个新的集合。</p>
<p>示例2因为用的 new 创建的集合，不属于不可变 AbstractImmutableList 类的子类，所以 copyOf 方法又创建了一个新的实例，所以为false。</p>
<blockquote>
<p>使用of和copyOf创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 java.lang.UnsupportedOperationException 异常。</p>
</blockquote>
<h2 id="3-Java11新特性"><a href="#3-Java11新特性" class="headerlink" title="3. Java11新特性"></a>3. Java11新特性</h2><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230111182715233.png" alt="image-20230111182715233"></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230112222307082.png" alt="image-20230112222307082"></p>
<h3 id="3-1-一系列字符串处理方法"><a href="#3-1-一系列字符串处理方法" class="headerlink" title="3.1 一系列字符串处理方法"></a>3.1 一系列字符串处理方法</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230112222406043.png" alt="image-20230112222406043"></p>
<h3 id="3-2-Optional加强"><a href="#3-2-Optional加强" class="headerlink" title="3.2 Optional加强"></a>3.2 Optional加强</h3><p>Optional 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换 成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20230112222441959.png" alt="image-20230112222441959"></p>
<h3 id="3-3-局部变量类型推断升级"><a href="#3-3-局部变量类型推断升级" class="headerlink" title="3.3 局部变量类型推断升级"></a>3.3 局部变量类型推断升级</h3><p>在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样的语法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的形式: 必须要有类型, 可以加上var</span></span><br><span class="line"><span class="comment">//Consumer&lt;String&gt; con1 = (@Deprecated t) -&gt;</span></span><br><span class="line">System.out.println(t.toUpperCase());</span><br><span class="line"><span class="comment">//正确的形式:</span></span><br><span class="line"><span class="comment">//使用var的好处是在使用lambda表达式时给参数加上注解。  Consumer&lt;String&gt; con2 = (@Deprecated var t) -&gt;  System.out.println(t.toUpperCase());</span></span><br></pre></td></tr></table></figure>



<h3 id="3-4-全新的HTTP客户端API"><a href="#3-4-全新的HTTP客户端API" class="headerlink" title="3.4 全新的HTTP客户端API"></a>3.4 全新的HTTP客户端API</h3><ul>
<li>HTTP，用于传输网页的协议，早在1997年就被采用在目前的1.1版本中。直 到2015年，HTTP2才成为标准。</li>
<li>HTTP&#x2F;1.1和HTTP&#x2F;2的主要区别是如何在客户端和服务器之间构建和传输数据。 <strong>HTTP&#x2F;1.1依赖于请求&#x2F;响应周期。 HTTP&#x2F;2允许服务器“push”数据：它可以发 送比客户端请求更多的数据</strong>。这使得它可以优先处理并发送对于首先加载  网页至关重要的数据。</li>
<li>这是 Java 9 开始引入的一个处理 HTTP 请求的的 HTTP Client API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在java.net 包中找到这个 API。</li>
<li>它将<strong>替代仅适用于blocking模式的HttpURLConnection</strong>（HttpURLConnection是在HTTP 1.0的时代创建的，并使用了协议无关的 方法），并提供<strong>对WebSocket 和 HTTP&#x2F;2的支持。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();  <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span></span><br><span class="line">HttpRequest.newBuilder(URI.create(<span class="string">&quot;http://127.0.0.1:8080/test/&quot;</span>)).build(); </span><br><span class="line">BodyHandler&lt;String&gt; responseBodyHandler = BodyHandlers.ofString();  </span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, responseBodyHandler); </span><br><span class="line"><span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> response.body();</span><br><span class="line">System.out.println(body);</span><br><span class="line"></span><br><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line"><span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder(URI.create(<span class="string">&quot;http://127.0.0.1:8080/test/&quot;</span>)).build();  </span><br><span class="line">BodyHandler&lt;String&gt; responseBodyHandler = BodyHandlers.ofString(); CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; sendAsync =  client.sendAsync(request, responseBodyHandler);</span><br><span class="line">sendAsync.thenApply(t -&gt; t.body()).thenAccept(System.out::println);</span><br><span class="line"><span class="comment">//HttpResponse&lt;String&gt; response = sendAsync.get();</span></span><br><span class="line"><span class="comment">//String body = response.body();</span></span><br><span class="line"><span class="comment">//System.out.println(body);</span></span><br></pre></td></tr></table></figure>



<h3 id="3-5-更简化的编译运行程序"><a href="#3-5-更简化的编译运行程序" class="headerlink" title="3.5 更简化的编译运行程序"></a>3.5 更简化的编译运行程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译</span></span><br><span class="line">javac Javastack.java</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line">java Javastack</span><br></pre></td></tr></table></figure>

<p>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。 而在未来的Java 11 版本中，通过一个 java 命令就直接搞定了，如以下所示：<strong>java</strong> <strong>Javastack.java</strong></p>
<p>一个命令编译运行源代码的注意点：</p>
<ul>
<li>执行源文件中的第一个类, 第一个类<strong>必须包含主方法。</strong></li>
<li>并且不可以使用其它源文件中的自定义类, 本文件中的自定义类是可以使用的。</li>
</ul>
<h3 id="3-6-废弃Nashorn引擎"><a href="#3-6-废弃Nashorn引擎" class="headerlink" title="3.6 废弃Nashorn引擎"></a>3.6 废弃Nashorn引擎</h3><p>废除Nashorn javascript引擎，在后续版本准备移除掉，有需要的可以考虑使用GraalVM。</p>
<h3 id="3-7-ZGC"><a href="#3-7-ZGC" class="headerlink" title="3.7 ZGC"></a>3.7 ZGC</h3><ul>
<li><strong>GC是java主要优势之一</strong>。 然而, 当GC停顿太长, 就会开始影响应用的响应时 间。消除或者减少GC停顿时长, java将对更广泛的应用场景是一个更有吸引力 的平台。此外, 现代系统中可用内存不断增长,用户和程序员希望JVM能够以高 效的方式充分利用这些内存, 并且无需长时间的GC暂停时间。</li>
<li><strong>ZGC, A Scalable Low-Latency Garbage Collector(Experimental)ZGC, 这应该是JDK11最为瞩目的特性, 没有之一</strong>。 但是后面带了Experimental, 说明这还不建议用到生产环境。</li>
<li>ZGC是一个并发, 基于region, 压缩型的垃圾收集器, 只有root扫描阶段会 STW(stop the world), 因此GC停顿时间不会随着堆的增长和存活对象的增长 而变长。</li>
</ul>
<hr>
<ul>
<li>优势：<ul>
<li>GC暂停时间不会超过10ms</li>
<li>既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)</li>
<li>和G1相比, 应用吞吐能力不会下降超过15%</li>
<li>为未来的GC功能和利用colord指针以及Load barriers优化奠定基础</li>
<li>初始只支持64位系统</li>
</ul>
</li>
<li>ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个 程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人 兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存）， 或压缩堆。</li>
</ul>
<h3 id="3-8-其他新特性"><a href="#3-8-其他新特性" class="headerlink" title="3.8 其他新特性"></a>3.8 其他新特性</h3><ul>
<li>Unicode 10</li>
<li>Deprecate the Pack200 Tools and API</li>
<li>新的Epsilon垃圾收集器</li>
<li>完全支持Linux容器（包括Docker）</li>
<li>支持G1上的并行完全垃圾收集</li>
<li>最新的HTTPS安全协议TLS 1.3</li>
<li>Java Flight Recorder</li>
</ul>
</div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/06/19/RNZqH4gnkWSpeDm.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jia</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/03jia"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Jia's Blog website</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/19/hexo+butterfly/" title="无题">无题</a><time datetime="2023-06-19T08:15:14.198Z" title="发表于 2023-06-19 16:15:14">2023-06-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%88%E9%87%87%E7%94%A8hexo%E6%A1%86%E6%9E%B6+%E9%83%A8%E7%BD%B2%E5%88%B0github%EF%BC%89/" title="Hexo博客搭建过程">Hexo博客搭建过程</a><time datetime="2023-06-19T03:43:27.271Z" title="发表于 2023-06-19 11:43:27">2023-06-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/19/hello-world/" title="Hello World">Hello World</a><time datetime="2023-06-19T03:17:08.556Z" title="发表于 2023-06-19 11:17:08">2023-06-19</time></div></div></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><span class="card-archive-list-count">3</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">3</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">4.4k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-06-19T10:02:33.120Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/06/19/GkW9qPHwQpR3Dre.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Jia</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>